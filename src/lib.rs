//! Deterministic in-memory browser runtime for Rust tests.
//!
//! This crate provides a lightweight DOM and JavaScript-like runtime tailored
//! for deterministic unit and integration testing.
//! Use [`Harness`] as the main entry point to load HTML, simulate user actions,
//! control fake time, and assert DOM state.

use num_bigint::{BigInt as JsBigInt, Sign};
use num_traits::{One, ToPrimitive, Zero};
use regex::{Captures, Regex, RegexBuilder};
use std::cell::RefCell;
use std::collections::{HashMap, HashSet, VecDeque};
use std::error::Error as StdError;
use std::fmt;
use std::rc::Rc;

const INTERNAL_RETURN_SLOT: &str = "__bt_internal_return_value__";
const INTERNAL_SYMBOL_KEY_PREFIX: &str = "\u{0}\u{0}bt_symbol_key:";
const INTERNAL_SYMBOL_WRAPPER_KEY: &str = "\u{0}\u{0}bt_symbol_wrapper";
const INTERNAL_STRING_WRAPPER_VALUE_KEY: &str = "\u{0}\u{0}bt_string_wrapper_value";
const INTERNAL_INTL_KEY_PREFIX: &str = "\u{0}\u{0}bt_intl:";
const INTERNAL_INTL_KIND_KEY: &str = "\u{0}\u{0}bt_intl:kind";
const INTERNAL_INTL_LOCALE_KEY: &str = "\u{0}\u{0}bt_intl:locale";
const INTERNAL_INTL_OPTIONS_KEY: &str = "\u{0}\u{0}bt_intl:options";
const INTERNAL_INTL_LOCALE_DATA_KEY: &str = "\u{0}\u{0}bt_intl:localeData";
const INTERNAL_INTL_CASE_FIRST_KEY: &str = "\u{0}\u{0}bt_intl:caseFirst";
const INTERNAL_INTL_SENSITIVITY_KEY: &str = "\u{0}\u{0}bt_intl:sensitivity";
const INTERNAL_INTL_SEGMENTS_KEY: &str = "\u{0}\u{0}bt_intl:segments";
const INTERNAL_INTL_SEGMENT_INDEX_KEY: &str = "\u{0}\u{0}bt_intl:segmentIndex";
const INTERNAL_CALLABLE_KEY_PREFIX: &str = "\u{0}\u{0}bt_callable:";
const INTERNAL_CALLABLE_KIND_KEY: &str = "\u{0}\u{0}bt_callable:kind";
const INTERNAL_LOCATION_OBJECT_KEY: &str = "\u{0}\u{0}bt_location";
const INTERNAL_HISTORY_OBJECT_KEY: &str = "\u{0}\u{0}bt_history";
const INTERNAL_WINDOW_OBJECT_KEY: &str = "\u{0}\u{0}bt_window";
const INTERNAL_DOCUMENT_OBJECT_KEY: &str = "\u{0}\u{0}bt_document";
const INTERNAL_NAVIGATOR_OBJECT_KEY: &str = "\u{0}\u{0}bt_navigator";
const INTERNAL_CLIPBOARD_OBJECT_KEY: &str = "\u{0}\u{0}bt_clipboard";
const DEFAULT_LOCALE: &str = "en-US";

pub type Result<T> = std::result::Result<T, Error>;

#[derive(Debug, Clone, PartialEq)]
pub enum Error {
    HtmlParse(String),
    ScriptParse(String),
    ScriptRuntime(String),
    ScriptThrown(ThrownValue),
    SelectorNotFound(String),
    UnsupportedSelector(String),
    TypeMismatch {
        selector: String,
        expected: String,
        actual: String,
    },
    AssertionFailed {
        selector: String,
        expected: String,
        actual: String,
        dom_snippet: String,
    },
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::HtmlParse(msg) => write!(f, "html parse error: {msg}"),
            Self::ScriptParse(msg) => write!(f, "script parse error: {msg}"),
            Self::ScriptRuntime(msg) => write!(f, "script runtime error: {msg}"),
            Self::ScriptThrown(value) => {
                write!(f, "script thrown value: {}", value.as_string())
            }
            Self::SelectorNotFound(selector) => write!(f, "selector not found: {selector}"),
            Self::UnsupportedSelector(selector) => write!(f, "unsupported selector: {selector}"),
            Self::TypeMismatch {
                selector,
                expected,
                actual,
            } => write!(
                f,
                "type mismatch for {selector}: expected {expected}, actual {actual}"
            ),
            Self::AssertionFailed {
                selector,
                expected,
                actual,
                dom_snippet,
            } => write!(
                f,
                "assertion failed for {selector}: expected {expected}, actual {actual}, snippet {dom_snippet}"
            ),
        }
    }
}

impl StdError for Error {}

#[derive(Debug, Clone, PartialEq)]
pub struct ThrownValue {
    value: Value,
}

impl ThrownValue {
    fn new(value: Value) -> Self {
        Self { value }
    }

    fn into_value(self) -> Value {
        self.value
    }

    fn as_string(&self) -> String {
        self.value.as_string()
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
struct NodeId(usize);

#[derive(Debug, Clone)]
enum NodeType {
    Document,
    Element(Element),
    Text(String),
}

#[derive(Debug, Clone)]
struct Node {
    parent: Option<NodeId>,
    children: Vec<NodeId>,
    node_type: NodeType,
}

#[derive(Debug, Clone)]
struct Element {
    tag_name: String,
    attrs: HashMap<String, String>,
    value: String,
    checked: bool,
    disabled: bool,
    readonly: bool,
    required: bool,
}

#[derive(Debug, Clone)]
struct Dom {
    nodes: Vec<Node>,
    root: NodeId,
    id_index: HashMap<String, Vec<NodeId>>,
    active_element: Option<NodeId>,
    active_pseudo_element: Option<NodeId>,
}

impl Dom {
    fn new() -> Self {
        let root = Node {
            parent: None,
            children: Vec::new(),
            node_type: NodeType::Document,
        };
        Self {
            nodes: vec![root],
            root: NodeId(0),
            id_index: HashMap::new(),
            active_element: None,
            active_pseudo_element: None,
        }
    }

    fn create_node(&mut self, parent: Option<NodeId>, node_type: NodeType) -> NodeId {
        let id = NodeId(self.nodes.len());
        self.nodes.push(Node {
            parent,
            children: Vec::new(),
            node_type,
        });
        if let Some(parent_id) = parent {
            self.nodes[parent_id.0].children.push(id);
        }
        id
    }

    fn create_element(
        &mut self,
        parent: NodeId,
        tag_name: String,
        attrs: HashMap<String, String>,
    ) -> NodeId {
        let value = attrs.get("value").cloned().unwrap_or_default();
        let checked = attrs.contains_key("checked");
        let disabled = attrs.contains_key("disabled");
        let readonly = attrs.contains_key("readonly");
        let required = attrs.contains_key("required");
        let element = Element {
            tag_name,
            attrs,
            value,
            checked,
            disabled,
            readonly,
            required,
        };
        let id = self.create_node(Some(parent), NodeType::Element(element));
        if let Some(id_attr) = self
            .element(id)
            .and_then(|element| element.attrs.get("id").cloned())
        {
            self.index_id(&id_attr, id);
        }
        id
    }

    fn create_detached_element(&mut self, tag_name: String) -> NodeId {
        let element = Element {
            tag_name,
            attrs: HashMap::new(),
            value: String::new(),
            checked: false,
            disabled: false,
            readonly: false,
            required: false,
        };
        self.create_node(None, NodeType::Element(element))
    }

    fn create_detached_text(&mut self, text: String) -> NodeId {
        self.create_node(None, NodeType::Text(text))
    }

    fn create_text(&mut self, parent: NodeId, text: String) -> NodeId {
        self.create_node(Some(parent), NodeType::Text(text))
    }

    fn element(&self, node_id: NodeId) -> Option<&Element> {
        match &self.nodes[node_id.0].node_type {
            NodeType::Element(element) => Some(element),
            _ => None,
        }
    }

    fn element_mut(&mut self, node_id: NodeId) -> Option<&mut Element> {
        match &mut self.nodes[node_id.0].node_type {
            NodeType::Element(element) => Some(element),
            _ => None,
        }
    }

    fn tag_name(&self, node_id: NodeId) -> Option<&str> {
        self.element(node_id).map(|e| e.tag_name.as_str())
    }

    fn parent(&self, node_id: NodeId) -> Option<NodeId> {
        self.nodes[node_id.0].parent
    }

    fn is_descendant_of(&self, node_id: NodeId, ancestor: NodeId) -> bool {
        let mut cursor = self.parent(node_id);
        while let Some(current) = cursor {
            if current == ancestor {
                return true;
            }
            cursor = self.parent(current);
        }
        false
    }

    fn active_element(&self) -> Option<NodeId> {
        self.active_element
    }

    fn set_active_element(&mut self, node: Option<NodeId>) {
        self.active_element = node;
    }

    fn active_pseudo_element(&self) -> Option<NodeId> {
        self.active_pseudo_element
    }

    fn set_active_pseudo_element(&mut self, node: Option<NodeId>) {
        self.active_pseudo_element = node;
    }

    fn by_id(&self, id: &str) -> Option<NodeId> {
        self.id_index.get(id).and_then(|ids| ids.first().copied())
    }

    fn by_id_all(&self, id: &str) -> Vec<NodeId> {
        self.id_index.get(id).cloned().unwrap_or_default()
    }

    fn index_id(&mut self, id: &str, node_id: NodeId) {
        if id.is_empty() {
            return;
        }
        self.id_index
            .entry(id.to_string())
            .or_default()
            .push(node_id);
    }

    fn unindex_id(&mut self, id: &str, node_id: NodeId) {
        let Some(nodes) = self.id_index.get_mut(id) else {
            return;
        };
        nodes.retain(|candidate| *candidate != node_id);
        if nodes.is_empty() {
            self.id_index.remove(id);
        }
    }

    fn text_content(&self, node_id: NodeId) -> String {
        match &self.nodes[node_id.0].node_type {
            NodeType::Document | NodeType::Element(_) => {
                let mut out = String::new();
                for child in &self.nodes[node_id.0].children {
                    out.push_str(&self.text_content(*child));
                }
                out
            }
            NodeType::Text(text) => text.clone(),
        }
    }

    fn set_text_content(&mut self, node_id: NodeId, value: &str) -> Result<()> {
        if self.element(node_id).is_none() {
            return Err(Error::ScriptRuntime(
                "textContent target is not an element".into(),
            ));
        }
        self.nodes[node_id.0].children.clear();
        if !value.is_empty() {
            self.create_text(node_id, value.to_string());
        }
        Ok(())
    }

    fn inner_html(&self, node_id: NodeId) -> Result<String> {
        if self.element(node_id).is_none() {
            return Err(Error::ScriptRuntime(
                "innerHTML target is not an element".into(),
            ));
        }
        let mut out = String::new();
        for child in &self.nodes[node_id.0].children {
            out.push_str(&self.dump_node(*child));
        }
        Ok(out)
    }

    fn set_inner_html(&mut self, node_id: NodeId, html: &str) -> Result<()> {
        if self.element(node_id).is_none() {
            return Err(Error::ScriptRuntime(
                "innerHTML target is not an element".into(),
            ));
        }

        let ParseOutput { dom: fragment, .. } = parse_html(html)?;

        let old_children = std::mem::take(&mut self.nodes[node_id.0].children);
        for child in old_children {
            self.nodes[child.0].parent = None;
        }

        let children = fragment.nodes[fragment.root.0].children.clone();
        for child in children {
            let _ = self.clone_subtree_from_dom(&fragment, child, Some(node_id), true)?;
        }

        self.rebuild_id_index();
        Ok(())
    }

    fn insert_adjacent_html(
        &mut self,
        target: NodeId,
        position: InsertAdjacentPosition,
        html: &str,
    ) -> Result<()> {
        let ParseOutput { dom: fragment, .. } = parse_html(html)?;

        let mut children = fragment.nodes[fragment.root.0].children.clone();
        if matches!(position, InsertAdjacentPosition::AfterBegin) {
            children.reverse();
        }

        for child in children {
            if let Some(node) = self.clone_subtree_from_dom(&fragment, child, None, true)? {
                self.insert_adjacent_node(target, position, node)?;
            }
        }
        Ok(())
    }

    fn clone_subtree_from_dom(
        &mut self,
        source: &Dom,
        source_node: NodeId,
        parent: Option<NodeId>,
        sanitize: bool,
    ) -> Result<Option<NodeId>> {
        let node_type = match &source.nodes[source_node.0].node_type {
            NodeType::Document => {
                return Err(Error::ScriptRuntime(
                    "cannot clone document node into innerHTML target".into(),
                ));
            }
            NodeType::Element(element) => {
                if sanitize && should_strip_inner_html_element(&element.tag_name) {
                    return Ok(None);
                }
                let mut clone = element.clone();
                if sanitize {
                    sanitize_inner_html_element_attrs(&mut clone);
                }
                NodeType::Element(clone)
            }
            NodeType::Text(text) => NodeType::Text(text.clone()),
        };

        let node = self.create_node(parent, node_type);
        for child in &source.nodes[source_node.0].children {
            let _ = self.clone_subtree_from_dom(source, *child, Some(node), sanitize)?;
        }
        Ok(Some(node))
    }

    fn value(&self, node_id: NodeId) -> Result<String> {
        let element = self
            .element(node_id)
            .ok_or_else(|| Error::ScriptRuntime("value target is not an element".into()))?;
        Ok(element.value.clone())
    }

    fn set_value(&mut self, node_id: NodeId, value: &str) -> Result<()> {
        if self
            .tag_name(node_id)
            .map(|tag| tag.eq_ignore_ascii_case("select"))
            .unwrap_or(false)
        {
            return self.set_select_value(node_id, value);
        }

        let element = self
            .element_mut(node_id)
            .ok_or_else(|| Error::ScriptRuntime("value target is not an element".into()))?;
        element.value = value.to_string();
        Ok(())
    }

    fn initialize_form_control_values(&mut self) -> Result<()> {
        let nodes = self.all_element_nodes();
        for node in nodes {
            let is_textarea = self
                .tag_name(node)
                .map(|tag| tag.eq_ignore_ascii_case("textarea"))
                .unwrap_or(false);
            if is_textarea {
                let text = self.text_content(node);
                let element = self.element_mut(node).ok_or_else(|| {
                    Error::ScriptRuntime("textarea target is not an element".into())
                })?;
                element.value = text;
                continue;
            }

            let is_select = self
                .tag_name(node)
                .map(|tag| tag.eq_ignore_ascii_case("select"))
                .unwrap_or(false);
            if is_select {
                self.sync_select_value(node)?;
            }
        }
        Ok(())
    }

    fn sync_select_value_for_option(&mut self, option_node: NodeId) -> Result<()> {
        if !self
            .tag_name(option_node)
            .map(|tag| tag.eq_ignore_ascii_case("option"))
            .unwrap_or(false)
        {
            return Ok(());
        }

        let Some(select_node) = self.find_ancestor_by_tag(option_node, "select") else {
            return Ok(());
        };
        self.sync_select_value(select_node)
    }

    fn set_select_value(&mut self, select_node: NodeId, requested: &str) -> Result<()> {
        let tag = self
            .tag_name(select_node)
            .ok_or_else(|| Error::ScriptRuntime("select target is not an element".into()))?;
        if !tag.eq_ignore_ascii_case("select") {
            return Err(Error::ScriptRuntime(
                "set value target is not a select".into(),
            ));
        }

        let mut options = Vec::new();
        self.collect_select_options(select_node, &mut options);

        let mut option_values = Vec::with_capacity(options.len());
        for option in options {
            option_values.push((option, self.option_effective_value(option)?));
        }

        let matched = option_values
            .iter()
            .find(|(_, value)| value == requested)
            .map(|(node, value)| (*node, value.clone()));

        for (option, _) in &option_values {
            let option_element = self
                .element_mut(*option)
                .ok_or_else(|| Error::ScriptRuntime("option target is not an element".into()))?;
            if Some(*option) == matched.as_ref().map(|(node, _)| *node) {
                option_element
                    .attrs
                    .insert("selected".to_string(), "true".to_string());
            } else {
                option_element.attrs.remove("selected");
            }
        }

        let element = self
            .element_mut(select_node)
            .ok_or_else(|| Error::ScriptRuntime("select target is not an element".into()))?;
        element.value = matched.map(|(_, value)| value).unwrap_or_default();
        Ok(())
    }

    fn sync_select_value(&mut self, select_node: NodeId) -> Result<()> {
        let value = self.select_value_from_options(select_node)?;
        let element = self
            .element_mut(select_node)
            .ok_or_else(|| Error::ScriptRuntime("select target is not an element".into()))?;
        element.value = value;
        Ok(())
    }

    fn select_value_from_options(&self, select_node: NodeId) -> Result<String> {
        let tag = self
            .tag_name(select_node)
            .ok_or_else(|| Error::ScriptRuntime("select target is not an element".into()))?;
        if !tag.eq_ignore_ascii_case("select") {
            return Err(Error::ScriptRuntime(
                "select value target is not a select".into(),
            ));
        }

        let mut options = Vec::new();
        self.collect_select_options(select_node, &mut options);
        if options.is_empty() {
            return Ok(String::new());
        }

        let selected = options
            .iter()
            .copied()
            .find(|option| self.attr(*option, "selected").is_some())
            .unwrap_or(options[0]);
        self.option_effective_value(selected)
    }

    fn collect_select_options(&self, node: NodeId, out: &mut Vec<NodeId>) {
        for child in &self.nodes[node.0].children {
            if self
                .tag_name(*child)
                .map(|tag| tag.eq_ignore_ascii_case("option"))
                .unwrap_or(false)
            {
                out.push(*child);
            }
            self.collect_select_options(*child, out);
        }
    }

    fn option_effective_value(&self, option_node: NodeId) -> Result<String> {
        let element = self
            .element(option_node)
            .ok_or_else(|| Error::ScriptRuntime("option target is not an element".into()))?;
        if !element.tag_name.eq_ignore_ascii_case("option") {
            return Err(Error::ScriptRuntime(
                "option target is not an option".into(),
            ));
        }
        if let Some(value) = element.attrs.get("value") {
            return Ok(value.clone());
        }
        Ok(self.text_content(option_node))
    }

    fn checked(&self, node_id: NodeId) -> Result<bool> {
        let element = self
            .element(node_id)
            .ok_or_else(|| Error::ScriptRuntime("checked target is not an element".into()))?;
        Ok(element.checked)
    }

    fn set_checked(&mut self, node_id: NodeId, checked: bool) -> Result<()> {
        if checked && is_radio_input(self, node_id) {
            self.uncheck_other_radios_in_group(node_id);
        }
        let element = self
            .element_mut(node_id)
            .ok_or_else(|| Error::ScriptRuntime("checked target is not an element".into()))?;
        element.checked = checked;
        Ok(())
    }

    fn uncheck_other_radios_in_group(&mut self, target: NodeId) {
        let target_name = self.attr(target, "name").unwrap_or_default();
        if target_name.is_empty() {
            return;
        }
        let target_form = self.find_ancestor_by_tag(target, "form");

        let all_nodes = self.all_element_nodes();
        for node in all_nodes {
            if node == target {
                continue;
            }
            if !is_radio_input(self, node) {
                continue;
            }
            if self.attr(node, "name").unwrap_or_default() != target_name {
                continue;
            }
            if self.find_ancestor_by_tag(node, "form") != target_form {
                continue;
            }
            if let Some(element) = self.element_mut(node) {
                element.checked = false;
            }
        }
    }

    fn normalize_radio_groups(&mut self) -> Result<()> {
        let all_nodes = self.all_element_nodes();
        for node in all_nodes {
            if !is_radio_input(self, node) {
                continue;
            }
            if self.attr(node, "checked").is_some() {
                self.set_checked(node, true)?;
            }
        }
        Ok(())
    }

    fn disabled(&self, node_id: NodeId) -> bool {
        self.element(node_id).map(|e| e.disabled).unwrap_or(false)
    }

    fn readonly(&self, node_id: NodeId) -> bool {
        self.element(node_id).map(|e| e.readonly).unwrap_or(false)
    }

    fn required(&self, node_id: NodeId) -> bool {
        self.element(node_id).map(|e| e.required).unwrap_or(false)
    }

    fn attr(&self, node_id: NodeId, name: &str) -> Option<String> {
        self.element(node_id)
            .and_then(|e| e.attrs.get(name).cloned())
    }

    fn has_attr(&self, node_id: NodeId, name: &str) -> Result<bool> {
        let element = self
            .element(node_id)
            .ok_or_else(|| Error::ScriptRuntime("hasAttribute target is not an element".into()))?;
        Ok(element.attrs.contains_key(&name.to_ascii_lowercase()))
    }

    fn set_attr(&mut self, node_id: NodeId, name: &str, value: &str) -> Result<()> {
        let old_id = if name.eq_ignore_ascii_case("id") {
            self.element(node_id)
                .and_then(|element| element.attrs.get("id").cloned())
        } else {
            None
        };
        let connected = self.is_connected(node_id);
        let (is_option, lowered) = {
            let element = self.element_mut(node_id).ok_or_else(|| {
                Error::ScriptRuntime("setAttribute target is not an element".into())
            })?;
            let is_option = element.tag_name.eq_ignore_ascii_case("option");
            let lowered = name.to_ascii_lowercase();
            element.attrs.insert(lowered.clone(), value.to_string());

            if lowered == "value" {
                element.value = value.to_string();
            } else if lowered == "checked" {
                element.checked = true;
            } else if lowered == "disabled" {
                element.disabled = true;
            } else if lowered == "readonly" {
                element.readonly = true;
            } else if lowered == "required" {
                element.required = true;
            }
            (is_option, lowered)
        };

        if lowered == "id" && connected {
            if let Some(old) = old_id {
                self.unindex_id(&old, node_id);
            }
            if !value.is_empty() {
                self.index_id(value, node_id);
            }
        }

        if is_option && (lowered == "selected" || lowered == "value") {
            self.sync_select_value_for_option(node_id)?;
        }

        Ok(())
    }

    fn remove_attr(&mut self, node_id: NodeId, name: &str) -> Result<()> {
        let lowered = name.to_ascii_lowercase();
        let old_id = if lowered == "id" {
            self.element(node_id)
                .and_then(|element| element.attrs.get("id").cloned())
        } else {
            None
        };
        let connected = self.is_connected(node_id);
        let is_option = {
            let element = self.element_mut(node_id).ok_or_else(|| {
                Error::ScriptRuntime("removeAttribute target is not an element".into())
            })?;
            let is_option = element.tag_name.eq_ignore_ascii_case("option");
            element.attrs.remove(&lowered);

            if lowered == "value" {
                element.value.clear();
            } else if lowered == "checked" {
                element.checked = false;
            } else if lowered == "disabled" {
                element.disabled = false;
            } else if lowered == "readonly" {
                element.readonly = false;
            } else if lowered == "required" {
                element.required = false;
            }
            is_option
        };

        if lowered == "id" && connected {
            if let Some(old) = old_id {
                self.unindex_id(&old, node_id);
            }
        }

        if is_option && (lowered == "selected" || lowered == "value") {
            self.sync_select_value_for_option(node_id)?;
        }

        Ok(())
    }

    fn append_child(&mut self, parent: NodeId, child: NodeId) -> Result<()> {
        if !self.can_have_children(parent) {
            return Err(Error::ScriptRuntime(
                "appendChild target cannot have children".into(),
            ));
        }
        if child == self.root || child == parent {
            return Err(Error::ScriptRuntime("invalid appendChild node".into()));
        }
        if !self.is_valid_node(child) {
            return Err(Error::ScriptRuntime("appendChild node is invalid".into()));
        }

        // Prevent cycles: parent must not be inside child's subtree.
        let mut cursor = Some(parent);
        while let Some(node) = cursor {
            if node == child {
                return Err(Error::ScriptRuntime(
                    "appendChild would create a cycle".into(),
                ));
            }
            cursor = self.parent(node);
        }

        if let Some(old_parent) = self.parent(child) {
            self.nodes[old_parent.0].children.retain(|id| *id != child);
        }
        self.nodes[child.0].parent = Some(parent);
        self.nodes[parent.0].children.push(child);
        self.rebuild_id_index();
        Ok(())
    }

    fn prepend_child(&mut self, parent: NodeId, child: NodeId) -> Result<()> {
        let reference = self.nodes[parent.0].children.first().copied();
        if let Some(reference) = reference {
            self.insert_before(parent, child, reference)
        } else {
            self.append_child(parent, child)
        }
    }

    fn insert_before(&mut self, parent: NodeId, child: NodeId, reference: NodeId) -> Result<()> {
        if !self.can_have_children(parent) {
            return Err(Error::ScriptRuntime(
                "insertBefore target cannot have children".into(),
            ));
        }
        if child == self.root || child == parent {
            return Err(Error::ScriptRuntime("invalid insertBefore node".into()));
        }
        if !self.is_valid_node(child) || !self.is_valid_node(reference) {
            return Err(Error::ScriptRuntime("insertBefore node is invalid".into()));
        }
        if self.parent(reference) != Some(parent) {
            return Err(Error::ScriptRuntime(
                "insertBefore reference is not a direct child".into(),
            ));
        }
        if child == reference {
            return Ok(());
        }

        // Prevent cycles: parent must not be inside child's subtree.
        let mut cursor = Some(parent);
        while let Some(node) = cursor {
            if node == child {
                return Err(Error::ScriptRuntime(
                    "insertBefore would create a cycle".into(),
                ));
            }
            cursor = self.parent(node);
        }

        if let Some(old_parent) = self.parent(child) {
            self.nodes[old_parent.0].children.retain(|id| *id != child);
        }

        let Some(index) = self.nodes[parent.0]
            .children
            .iter()
            .position(|id| *id == reference)
        else {
            return Err(Error::ScriptRuntime(
                "insertBefore reference is missing".into(),
            ));
        };

        self.nodes[child.0].parent = Some(parent);
        self.nodes[parent.0].children.insert(index, child);
        self.rebuild_id_index();
        Ok(())
    }

    fn insert_after(&mut self, target: NodeId, child: NodeId) -> Result<()> {
        let Some(parent) = self.parent(target) else {
            return Ok(());
        };
        let pos = self.nodes[parent.0]
            .children
            .iter()
            .position(|id| *id == target)
            .ok_or_else(|| Error::ScriptRuntime("after target is detached".into()))?;
        let next = self.nodes[parent.0].children.get(pos + 1).copied();
        if let Some(next) = next {
            self.insert_before(parent, child, next)
        } else {
            self.append_child(parent, child)
        }
    }

    fn replace_with(&mut self, target: NodeId, child: NodeId) -> Result<()> {
        let Some(parent) = self.parent(target) else {
            return Ok(());
        };
        if target == child {
            return Ok(());
        }
        self.insert_before(parent, child, target)?;
        self.remove_child(parent, target)
    }

    fn insert_adjacent_node(
        &mut self,
        target: NodeId,
        position: InsertAdjacentPosition,
        node: NodeId,
    ) -> Result<()> {
        match position {
            InsertAdjacentPosition::BeforeBegin => {
                if let Some(parent) = self.parent(target) {
                    self.insert_before(parent, node, target)?;
                }
                Ok(())
            }
            InsertAdjacentPosition::AfterBegin => self.prepend_child(target, node),
            InsertAdjacentPosition::BeforeEnd => self.append_child(target, node),
            InsertAdjacentPosition::AfterEnd => self.insert_after(target, node),
        }
    }

    fn remove_child(&mut self, parent: NodeId, child: NodeId) -> Result<()> {
        if self.parent(child) != Some(parent) {
            return Err(Error::ScriptRuntime(
                "removeChild target is not a direct child".into(),
            ));
        }
        self.nodes[parent.0].children.retain(|id| *id != child);
        self.nodes[child.0].parent = None;
        self.rebuild_id_index();
        Ok(())
    }

    fn remove_node(&mut self, node: NodeId) -> Result<()> {
        if node == self.root {
            return Err(Error::ScriptRuntime("cannot remove document root".into()));
        }
        let Some(parent) = self.parent(node) else {
            return Ok(());
        };
        self.remove_child(parent, node)
    }

    fn dataset_get(&self, node_id: NodeId, key: &str) -> Result<String> {
        if self.element(node_id).is_none() {
            return Err(Error::ScriptRuntime(
                "dataset target is not an element".into(),
            ));
        }
        let name = dataset_key_to_attr_name(key);
        Ok(self.attr(node_id, &name).unwrap_or_default())
    }

    fn dataset_set(&mut self, node_id: NodeId, key: &str, value: &str) -> Result<()> {
        let name = dataset_key_to_attr_name(key);
        self.set_attr(node_id, &name, value)
    }

    fn style_get(&self, node_id: NodeId, key: &str) -> Result<String> {
        let element = self
            .element(node_id)
            .ok_or_else(|| Error::ScriptRuntime("style target is not an element".into()))?;
        let name = js_prop_to_css_name(key);
        let decls = parse_style_declarations(element.attrs.get("style").map(String::as_str));
        Ok(decls
            .iter()
            .find(|(prop, _)| prop == &name)
            .map(|(_, value)| value.clone())
            .unwrap_or_default())
    }

    fn style_set(&mut self, node_id: NodeId, key: &str, value: &str) -> Result<()> {
        let name = js_prop_to_css_name(key);
        let element = self
            .element_mut(node_id)
            .ok_or_else(|| Error::ScriptRuntime("style target is not an element".into()))?;

        let mut decls = parse_style_declarations(element.attrs.get("style").map(String::as_str));
        if let Some(pos) = decls.iter().position(|(prop, _)| prop == &name) {
            if value.is_empty() {
                decls.remove(pos);
            } else {
                decls[pos].1 = value.to_string();
            }
        } else if !value.is_empty() {
            decls.push((name, value.to_string()));
        }

        if decls.is_empty() {
            element.attrs.remove("style");
        } else {
            element
                .attrs
                .insert("style".to_string(), serialize_style_declarations(&decls));
        }

        Ok(())
    }

    fn offset_left(&self, node_id: NodeId) -> Result<i64> {
        if self.element(node_id).is_none() {
            return Err(Error::ScriptRuntime(
                "offsetLeft target is not an element".into(),
            ));
        }
        Ok(0)
    }

    fn offset_top(&self, node_id: NodeId) -> Result<i64> {
        if self.element(node_id).is_none() {
            return Err(Error::ScriptRuntime(
                "offsetTop target is not an element".into(),
            ));
        }
        Ok(0)
    }

    fn offset_width(&self, node_id: NodeId) -> Result<i64> {
        if self.element(node_id).is_none() {
            return Err(Error::ScriptRuntime(
                "offsetWidth target is not an element".into(),
            ));
        }
        Ok(0)
    }

    fn offset_height(&self, node_id: NodeId) -> Result<i64> {
        if self.element(node_id).is_none() {
            return Err(Error::ScriptRuntime(
                "offsetHeight target is not an element".into(),
            ));
        }
        Ok(0)
    }

    fn scroll_width(&self, node_id: NodeId) -> Result<i64> {
        if self.element(node_id).is_none() {
            return Err(Error::ScriptRuntime(
                "scrollWidth target is not an element".into(),
            ));
        }
        Ok(0)
    }

    fn scroll_height(&self, node_id: NodeId) -> Result<i64> {
        if self.element(node_id).is_none() {
            return Err(Error::ScriptRuntime(
                "scrollHeight target is not an element".into(),
            ));
        }
        Ok(0)
    }

    fn scroll_left(&self, node_id: NodeId) -> Result<i64> {
        if self.element(node_id).is_none() {
            return Err(Error::ScriptRuntime(
                "scrollLeft target is not an element".into(),
            ));
        }
        Ok(0)
    }

    fn scroll_top(&self, node_id: NodeId) -> Result<i64> {
        if self.element(node_id).is_none() {
            return Err(Error::ScriptRuntime(
                "scrollTop target is not an element".into(),
            ));
        }
        Ok(0)
    }

    fn class_contains(&self, node_id: NodeId, class_name: &str) -> Result<bool> {
        let element = self
            .element(node_id)
            .ok_or_else(|| Error::ScriptRuntime("classList target is not an element".into()))?;
        Ok(has_class(element, class_name))
    }

    fn class_add(&mut self, node_id: NodeId, class_name: &str) -> Result<()> {
        let element = self
            .element_mut(node_id)
            .ok_or_else(|| Error::ScriptRuntime("classList target is not an element".into()))?;
        let mut classes = class_tokens(element.attrs.get("class").map(String::as_str));
        if !classes.iter().any(|name| name == class_name) {
            classes.push(class_name.to_string());
        }
        set_class_attr(element, &classes);
        Ok(())
    }

    fn class_remove(&mut self, node_id: NodeId, class_name: &str) -> Result<()> {
        let element = self
            .element_mut(node_id)
            .ok_or_else(|| Error::ScriptRuntime("classList target is not an element".into()))?;
        let mut classes = class_tokens(element.attrs.get("class").map(String::as_str));
        classes.retain(|name| name != class_name);
        set_class_attr(element, &classes);
        Ok(())
    }

    fn class_toggle(&mut self, node_id: NodeId, class_name: &str) -> Result<bool> {
        let has = self.class_contains(node_id, class_name)?;
        if has {
            self.class_remove(node_id, class_name)?;
            Ok(false)
        } else {
            self.class_add(node_id, class_name)?;
            Ok(true)
        }
    }

    fn query_selector(&self, selector: &str) -> Result<Option<NodeId>> {
        let all = self.query_selector_all(selector)?;
        Ok(all.into_iter().next())
    }

    fn query_selector_all(&self, selector: &str) -> Result<Vec<NodeId>> {
        let groups = parse_selector_groups(selector)?;

        if groups.len() == 1 && groups[0].len() == 1 {
            if let Some(id) = groups[0][0].step.id_only() {
                return Ok(self.by_id_all(id));
            }
        }

        let mut ids = Vec::new();
        self.collect_elements_dfs(self.root, &mut ids);

        let mut seen = HashSet::new();
        let mut matched = Vec::new();
        for candidate in ids {
            if groups
                .iter()
                .any(|steps| self.matches_selector_chain(candidate, steps))
                && seen.insert(candidate)
            {
                matched.push(candidate);
            }
        }
        Ok(matched)
    }

    fn query_selector_from(&self, root: &NodeId, selector: &str) -> Result<Option<NodeId>> {
        let all = self.query_selector_all_from(root, selector)?;
        Ok(all.into_iter().next())
    }

    fn query_selector_all_from(&self, root: &NodeId, selector: &str) -> Result<Vec<NodeId>> {
        let groups = parse_selector_groups(selector)?;

        let mut ids = Vec::new();
        self.collect_elements_descendants_dfs(*root, &mut ids);

        let mut seen = HashSet::new();
        let mut matched = Vec::new();
        for candidate in ids {
            if groups
                .iter()
                .any(|steps| self.matches_selector_chain(candidate, steps))
                && seen.insert(candidate)
            {
                matched.push(candidate);
            }
        }
        Ok(matched)
    }

    fn matches_selector(&self, node_id: NodeId, selector: &str) -> Result<bool> {
        if self.element(node_id).is_none() {
            return Ok(false);
        }

        let groups = parse_selector_groups(selector)?;
        Ok(groups
            .iter()
            .any(|steps| self.matches_selector_chain(node_id, steps)))
    }

    fn closest(&self, node_id: NodeId, selector: &str) -> Result<Option<NodeId>> {
        if self.element(node_id).is_none() {
            return Ok(None);
        }

        let groups = parse_selector_groups(selector)?;
        let mut cursor = Some(node_id);
        while let Some(current) = cursor {
            if groups
                .iter()
                .any(|steps| self.matches_selector_chain(current, steps))
            {
                return Ok(Some(current));
            }
            cursor = self.parent(current);
        }
        Ok(None)
    }

    fn can_have_children(&self, node_id: NodeId) -> bool {
        matches!(
            self.nodes.get(node_id.0).map(|n| &n.node_type),
            Some(NodeType::Document | NodeType::Element(_))
        )
    }

    fn is_valid_node(&self, node_id: NodeId) -> bool {
        node_id.0 < self.nodes.len()
    }

    fn is_connected(&self, node_id: NodeId) -> bool {
        let mut cursor = Some(node_id);
        while let Some(node) = cursor {
            if node == self.root {
                return true;
            }
            cursor = self.parent(node);
        }
        false
    }

    fn rebuild_id_index(&mut self) {
        let mut next = HashMap::new();
        let mut stack = vec![self.root];
        while let Some(node) = stack.pop() {
            match &self.nodes[node.0].node_type {
                NodeType::Element(element) => {
                    if let Some(id) = element.attrs.get("id") {
                        Self::index_id_map(&mut next, id, node);
                    }
                }
                NodeType::Document | NodeType::Text(_) => {}
            }
            for child in self.nodes[node.0].children.iter().rev() {
                stack.push(*child);
            }
        }
        self.id_index = next;
    }

    fn index_id_map(next: &mut HashMap<String, Vec<NodeId>>, id: &str, node_id: NodeId) {
        if id.is_empty() {
            return;
        }
        next.entry(id.to_string()).or_default().push(node_id);
    }

    fn collect_elements_dfs(&self, node_id: NodeId, out: &mut Vec<NodeId>) {
        if matches!(self.nodes[node_id.0].node_type, NodeType::Element(_)) {
            out.push(node_id);
        }
        for child in &self.nodes[node_id.0].children {
            self.collect_elements_dfs(*child, out);
        }
    }

    fn collect_elements_descendants_dfs(&self, node_id: NodeId, out: &mut Vec<NodeId>) {
        for child in &self.nodes[node_id.0].children {
            self.collect_elements_dfs(*child, out);
        }
    }

    fn all_element_nodes(&self) -> Vec<NodeId> {
        let mut out = Vec::new();
        self.collect_elements_dfs(self.root, &mut out);
        out
    }

    fn child_elements(&self, node_id: NodeId) -> Vec<NodeId> {
        self.nodes[node_id.0]
            .children
            .iter()
            .copied()
            .filter(|child| self.element(*child).is_some())
            .collect()
    }

    fn child_element_count(&self, node_id: NodeId) -> usize {
        self.child_elements(node_id).len()
    }

    fn first_element_child(&self, node_id: NodeId) -> Option<NodeId> {
        self.nodes[node_id.0]
            .children
            .iter()
            .copied()
            .find(|child| self.element(*child).is_some())
    }

    fn last_element_child(&self, node_id: NodeId) -> Option<NodeId> {
        self.nodes[node_id.0]
            .children
            .iter()
            .rev()
            .copied()
            .find(|child| self.element(*child).is_some())
    }

    fn document_element(&self) -> Option<NodeId> {
        self.first_element_child(self.root)
    }

    fn head(&self) -> Option<NodeId> {
        if let Some(document_element) = self.document_element() {
            if self
                .tag_name(document_element)
                .map(|tag| tag.eq_ignore_ascii_case("html"))
                .unwrap_or(false)
            {
                return self
                    .child_elements(document_element)
                    .into_iter()
                    .find(|child| {
                        self.tag_name(*child)
                            .map(|tag| tag.eq_ignore_ascii_case("head"))
                            .unwrap_or(false)
                    });
            }
        }
        self.query_selector("head").ok().flatten()
    }

    fn body(&self) -> Option<NodeId> {
        if let Some(document_element) = self.document_element() {
            if self
                .tag_name(document_element)
                .map(|tag| tag.eq_ignore_ascii_case("html"))
                .unwrap_or(false)
            {
                return self
                    .child_elements(document_element)
                    .into_iter()
                    .find(|child| {
                        self.tag_name(*child)
                            .map(|tag| {
                                tag.eq_ignore_ascii_case("body")
                                    || tag.eq_ignore_ascii_case("frameset")
                            })
                            .unwrap_or(false)
                    });
            }
        }
        self.query_selector("body")
            .ok()
            .flatten()
            .or_else(|| self.query_selector("frameset").ok().flatten())
    }

    fn document_title(&self) -> String {
        self.query_selector("title")
            .ok()
            .flatten()
            .map(|node| self.text_content(node))
            .unwrap_or_default()
    }

    fn set_document_title(&mut self, title: &str) -> Result<()> {
        let title_node = if let Some(existing_title) = self.query_selector("title")? {
            existing_title
        } else {
            let head = self.ensure_head_element()?;
            self.create_element(head, "title".to_string(), HashMap::new())
        };
        self.set_text_content(title_node, title)
    }

    fn ensure_head_element(&mut self) -> Result<NodeId> {
        if let Some(head) = self.head() {
            return Ok(head);
        }

        let parent = if let Some(document_element) = self.document_element() {
            if self
                .tag_name(document_element)
                .map(|tag| tag.eq_ignore_ascii_case("html"))
                .unwrap_or(false)
            {
                document_element
            } else {
                self.root
            }
        } else {
            self.create_element(self.root, "html".to_string(), HashMap::new())
        };

        Ok(self.create_element(parent, "head".to_string(), HashMap::new()))
    }

    fn matches_selector_chain(&self, node_id: NodeId, steps: &[SelectorPart]) -> bool {
        if steps.is_empty() {
            return false;
        }
        if !self.matches_step(node_id, &steps[steps.len() - 1].step) {
            return false;
        }

        let mut current = node_id;
        for idx in (1..steps.len()).rev() {
            let prev_step = &steps[idx - 1].step;
            let combinator = steps[idx]
                .combinator
                .unwrap_or(SelectorCombinator::Descendant);

            let matched = match combinator {
                SelectorCombinator::Child => {
                    let Some(parent) = self.parent(current) else {
                        return false;
                    };
                    if self.matches_step(parent, prev_step) {
                        Some(parent)
                    } else {
                        None
                    }
                }
                SelectorCombinator::Descendant => {
                    let mut cursor = self.parent(current);
                    let mut found = None;
                    while let Some(parent) = cursor {
                        if self.matches_step(parent, prev_step) {
                            found = Some(parent);
                            break;
                        }
                        cursor = self.parent(parent);
                    }
                    found
                }
                SelectorCombinator::AdjacentSibling => self
                    .previous_element_sibling(current)
                    .filter(|sibling| self.matches_step(*sibling, prev_step)),
                SelectorCombinator::GeneralSibling => {
                    let mut cursor = self.previous_element_sibling(current);
                    let mut found = None;
                    while let Some(sibling) = cursor {
                        if self.matches_step(sibling, prev_step) {
                            found = Some(sibling);
                            break;
                        }
                        cursor = self.previous_element_sibling(sibling);
                    }
                    found
                }
            };

            let Some(matched) = matched else {
                return false;
            };
            current = matched;
        }

        true
    }

    fn matches_step(&self, node_id: NodeId, step: &SelectorStep) -> bool {
        let Some(element) = self.element(node_id) else {
            return false;
        };

        if !step.universal {
            if let Some(tag) = &step.tag {
                if !element.tag_name.eq_ignore_ascii_case(tag) {
                    return false;
                }
            }
        } else if step.tag.is_some() {
            return false;
        }

        if let Some(id) = &step.id {
            if element.attrs.get("id") != Some(id) {
                return false;
            }
        }

        if step
            .classes
            .iter()
            .any(|class_name| !has_class(element, class_name))
        {
            return false;
        }

        for cond in &step.attrs {
            let matched = match cond {
                SelectorAttrCondition::Exists { key } => element.attrs.contains_key(key),
                SelectorAttrCondition::Eq { key, value } => element.attrs.get(key) == Some(value),
                SelectorAttrCondition::StartsWith { key, value } => element
                    .attrs
                    .get(key)
                    .is_some_and(|attr| attr.starts_with(value)),
                SelectorAttrCondition::EndsWith { key, value } => element
                    .attrs
                    .get(key)
                    .is_some_and(|attr| attr.ends_with(value)),
                SelectorAttrCondition::Contains { key, value } => element
                    .attrs
                    .get(key)
                    .is_some_and(|attr| attr.contains(value)),
                SelectorAttrCondition::Includes { key, value } => element
                    .attrs
                    .get(key)
                    .is_some_and(|attr| attr.split_whitespace().any(|token| token == value)),
                SelectorAttrCondition::DashMatch { key, value } => element
                    .attrs
                    .get(key)
                    .is_some_and(|attr| attr == value || attr.starts_with(&format!("{value}-"))),
            };
            if !matched {
                return false;
            }
        }

        for pseudo in &step.pseudo_classes {
            let matched = match pseudo {
                SelectorPseudoClass::FirstChild => self.is_first_element_child(node_id),
                SelectorPseudoClass::LastChild => self.is_last_element_child(node_id),
                SelectorPseudoClass::FirstOfType => self.is_first_of_type(node_id),
                SelectorPseudoClass::LastOfType => self.is_last_of_type(node_id),
                SelectorPseudoClass::OnlyChild => self.is_only_element_child(node_id),
                SelectorPseudoClass::OnlyOfType => self.is_only_of_type(node_id),
                SelectorPseudoClass::Checked => {
                    self.element(node_id).is_some_and(|node| node.checked)
                }
                SelectorPseudoClass::Disabled => {
                    self.element(node_id).is_some_and(|node| node.disabled)
                }
                SelectorPseudoClass::Enabled => {
                    self.element(node_id).is_some_and(|node| !node.disabled)
                }
                SelectorPseudoClass::Required => {
                    self.element(node_id).is_some_and(|node| node.required)
                }
                SelectorPseudoClass::Optional => {
                    self.element(node_id).is_none_or(|node| !node.required)
                }
                SelectorPseudoClass::Readonly => {
                    self.element(node_id).is_some_and(|node| node.readonly)
                }
                SelectorPseudoClass::Readwrite => {
                    self.element(node_id).is_none_or(|node| !node.readonly)
                }
                SelectorPseudoClass::Empty => self.nodes[node_id.0].children.is_empty(),
                SelectorPseudoClass::Focus => self
                    .element(node_id)
                    .is_some_and(|_| self.active_element == Some(node_id)),
                SelectorPseudoClass::FocusWithin => {
                    if self.active_element == Some(node_id) {
                        true
                    } else {
                        self.active_element
                            .is_some_and(|active| self.is_descendant_of(active, node_id))
                    }
                }
                SelectorPseudoClass::Active => self
                    .element(node_id)
                    .is_some_and(|_| self.active_pseudo_element == Some(node_id)),
                SelectorPseudoClass::NthOfType(selector) => {
                    self.is_nth_element_of_type(node_id, selector)
                }
                SelectorPseudoClass::NthLastOfType(selector) => {
                    self.is_nth_last_element_of_type(node_id, selector)
                }
                SelectorPseudoClass::Is(inners) | SelectorPseudoClass::Where(inners) => inners
                    .iter()
                    .any(|inner| self.matches_selector_chain(node_id, inner)),
                SelectorPseudoClass::Has(inners) => {
                    let mut descendants = Vec::new();
                    self.collect_elements_descendants_dfs(node_id, &mut descendants);
                    inners.iter().any(|inner| {
                        descendants
                            .iter()
                            .any(|target| self.matches_selector_chain(*target, inner))
                    })
                }
                SelectorPseudoClass::NthLastChild(selector) => {
                    self.is_nth_last_element_child(node_id, selector)
                }
                SelectorPseudoClass::NthChild(selector) => {
                    self.is_nth_element_child(node_id, selector)
                }
                SelectorPseudoClass::Not(inners) => !inners
                    .iter()
                    .any(|inner| self.matches_selector_chain(node_id, inner)),
            };
            if !matched {
                return false;
            }
        }

        true
    }

    fn is_first_element_child(&self, node_id: NodeId) -> bool {
        self.previous_element_sibling(node_id).is_none()
    }

    fn is_last_element_child(&self, node_id: NodeId) -> bool {
        self.next_element_sibling(node_id).is_none()
    }

    fn is_only_element_child(&self, node_id: NodeId) -> bool {
        let Some(parent) = self.parent(node_id) else {
            return false;
        };
        let mut count = 0usize;
        for child in &self.nodes[parent.0].children {
            if self.element(*child).is_some() {
                count += 1;
            }
        }
        count == 1
    }

    fn is_nth_element_child(&self, node_id: NodeId, selector: &NthChildSelector) -> bool {
        let Some(index) = self.element_index(node_id) else {
            return false;
        };
        self.is_nth_index_element_child(index, selector)
    }

    fn is_nth_last_element_child(&self, node_id: NodeId, selector: &NthChildSelector) -> bool {
        let Some(parent) = self.parent(node_id) else {
            return false;
        };
        let mut index = 0usize;
        let mut target = None;
        for child in &self.nodes[parent.0].children {
            if self.element(*child).is_none() {
                continue;
            }
            index += 1;
            if *child == node_id {
                target = Some(index);
            }
        }
        let Some(target) = target else {
            return false;
        };
        let total = index;
        let index_from_last = (total + 1) - target;
        self.is_nth_index_element_child(index_from_last, selector)
    }

    fn is_nth_element_of_type(&self, node_id: NodeId, selector: &NthChildSelector) -> bool {
        let Some(parent) = self.parent(node_id) else {
            return false;
        };
        let Some(tag_name) = self.tag_name(node_id) else {
            return false;
        };
        let mut index = 0usize;
        let mut target = None;
        for child in &self.nodes[parent.0].children {
            let Some(element) = self.element(*child) else {
                continue;
            };
            if element.tag_name != tag_name {
                continue;
            }
            index += 1;
            if *child == node_id {
                target = Some(index);
            }
        }
        let Some(target) = target else {
            return false;
        };
        self.is_nth_index_element_child(target, selector)
    }

    fn is_nth_last_element_of_type(&self, node_id: NodeId, selector: &NthChildSelector) -> bool {
        let Some(parent) = self.parent(node_id) else {
            return false;
        };
        let Some(tag_name) = self.tag_name(node_id) else {
            return false;
        };
        let mut index = 0usize;
        let mut target = None;
        for child in &self.nodes[parent.0].children {
            let Some(element) = self.element(*child) else {
                continue;
            };
            if element.tag_name != tag_name {
                continue;
            }
            index += 1;
            if *child == node_id {
                target = Some(index);
            }
        }
        let Some(target) = target else {
            return false;
        };
        let total = index;
        let index_from_last = (total + 1) - target;
        self.is_nth_index_element_child(index_from_last, selector)
    }

    fn is_first_of_type(&self, node_id: NodeId) -> bool {
        let Some(parent) = self.parent(node_id) else {
            return false;
        };
        let Some(tag_name) = self.tag_name(node_id) else {
            return false;
        };

        for child in &self.nodes[parent.0].children {
            let Some(element) = self.element(*child) else {
                continue;
            };
            if element.tag_name == tag_name {
                return *child == node_id;
            }
        }
        false
    }

    fn is_only_of_type(&self, node_id: NodeId) -> bool {
        let Some(parent) = self.parent(node_id) else {
            return false;
        };
        let Some(tag_name) = self.tag_name(node_id) else {
            return false;
        };
        let mut same_type_count = 0usize;
        for child in &self.nodes[parent.0].children {
            let Some(element) = self.element(*child) else {
                continue;
            };
            if element.tag_name == tag_name {
                same_type_count += 1;
            }
        }
        same_type_count == 1
    }

    fn is_last_of_type(&self, node_id: NodeId) -> bool {
        let Some(parent) = self.parent(node_id) else {
            return false;
        };
        let Some(tag_name) = self.tag_name(node_id) else {
            return false;
        };

        for child in self.nodes[parent.0].children.iter().rev() {
            let Some(element) = self.element(*child) else {
                continue;
            };
            if element.tag_name == tag_name {
                return *child == node_id;
            }
        }
        false
    }

    fn is_nth_index_element_child(&self, index: usize, selector: &NthChildSelector) -> bool {
        match selector {
            NthChildSelector::Exact(expected) => index == *expected,
            NthChildSelector::Odd => index % 2 == 1,
            NthChildSelector::Even => index % 2 == 0,
            NthChildSelector::AnPlusB(a, b) => {
                let index = index as i64;
                let diff = index - *b;
                if *a == 0 {
                    return diff == 0;
                }
                diff % *a == 0 && (diff / *a) >= 0
            }
        }
    }

    fn element_index(&self, node_id: NodeId) -> Option<usize> {
        let parent = self.parent(node_id)?;
        let mut index = 0usize;
        for child in &self.nodes[parent.0].children {
            if self.element(*child).is_none() {
                continue;
            }
            index += 1;
            if *child == node_id {
                return Some(index);
            }
        }
        None
    }

    fn next_element_sibling(&self, node_id: NodeId) -> Option<NodeId> {
        let parent = self.parent(node_id)?;
        let children = &self.nodes[parent.0].children;
        let pos = children.iter().position(|id| *id == node_id)?;
        for sibling in children.iter().skip(pos + 1) {
            if self.element(*sibling).is_some() {
                return Some(*sibling);
            }
        }
        None
    }

    fn previous_element_sibling(&self, node_id: NodeId) -> Option<NodeId> {
        let parent = self.parent(node_id)?;
        let children = &self.nodes[parent.0].children;
        let pos = children.iter().position(|id| *id == node_id)?;
        for sibling in children[..pos].iter().rev() {
            if self.element(*sibling).is_some() {
                return Some(*sibling);
            }
        }
        None
    }

    fn find_ancestor_by_tag(&self, node_id: NodeId, tag: &str) -> Option<NodeId> {
        let mut cursor = self.parent(node_id);
        while let Some(current) = cursor {
            if self
                .tag_name(current)
                .map(|name| name.eq_ignore_ascii_case(tag))
                .unwrap_or(false)
            {
                return Some(current);
            }
            cursor = self.parent(current);
        }
        None
    }

    fn dump_node(&self, node_id: NodeId) -> String {
        match &self.nodes[node_id.0].node_type {
            NodeType::Document => {
                let mut out = String::new();
                for child in &self.nodes[node_id.0].children {
                    out.push_str(&self.dump_node(*child));
                }
                out
            }
            NodeType::Text(text) => escape_html_text_for_serialization(text),
            NodeType::Element(element) => {
                let mut out = String::new();
                out.push('<');
                out.push_str(&element.tag_name);
                let mut attrs = element.attrs.iter().collect::<Vec<_>>();
                attrs.sort_by(|(left, _), (right, _)| left.cmp(right));
                for (k, v) in attrs {
                    out.push(' ');
                    out.push_str(k);
                    out.push_str("=\"");
                    out.push_str(&escape_html_attr_for_serialization(v));
                    out.push('"');
                }
                out.push('>');
                if is_void_tag(&element.tag_name) {
                    return out;
                }
                let raw_text_container = element.tag_name.eq_ignore_ascii_case("script")
                    || element.tag_name.eq_ignore_ascii_case("style");
                for child in &self.nodes[node_id.0].children {
                    if raw_text_container {
                        match &self.nodes[child.0].node_type {
                            NodeType::Text(text) => out.push_str(text),
                            _ => out.push_str(&self.dump_node(*child)),
                        }
                    } else {
                        out.push_str(&self.dump_node(*child));
                    }
                }
                out.push_str("</");
                out.push_str(&element.tag_name);
                out.push('>');
                out
            }
        }
    }
}

fn has_class(element: &Element, class_name: &str) -> bool {
    element
        .attrs
        .get("class")
        .map(|classes| classes.split_whitespace().any(|c| c == class_name))
        .unwrap_or(false)
}

fn should_strip_inner_html_element(tag_name: &str) -> bool {
    tag_name.eq_ignore_ascii_case("script")
}

fn sanitize_inner_html_element_attrs(element: &mut Element) {
    element.attrs.retain(|name, value| {
        if name.starts_with("on") {
            return false;
        }
        if is_javascript_url_attr(name) && is_javascript_scheme(value) {
            return false;
        }
        true
    });
    element.checked = element.attrs.contains_key("checked");
    element.disabled = element.attrs.contains_key("disabled");
    element.readonly = element.attrs.contains_key("readonly");
    element.required = element.attrs.contains_key("required");
    element.value = element.attrs.get("value").cloned().unwrap_or_default();
}

fn is_javascript_url_attr(name: &str) -> bool {
    matches!(
        name,
        "href" | "src" | "xlink:href" | "action" | "formaction"
    )
}

fn is_javascript_scheme(value: &str) -> bool {
    let mut normalized = String::with_capacity(value.len());
    for ch in value.chars() {
        if ch.is_ascii_whitespace() || ch.is_ascii_control() {
            continue;
        }
        normalized.push(ch.to_ascii_lowercase());
    }
    normalized.starts_with("javascript:")
}

fn escape_html_text_for_serialization(value: &str) -> String {
    let mut out = String::with_capacity(value.len());
    for ch in value.chars() {
        match ch {
            '&' => out.push_str("&amp;"),
            '<' => out.push_str("&lt;"),
            '>' => out.push_str("&gt;"),
            _ => out.push(ch),
        }
    }
    out
}

fn escape_html_attr_for_serialization(value: &str) -> String {
    let mut out = String::with_capacity(value.len());
    for ch in value.chars() {
        match ch {
            '&' => out.push_str("&amp;"),
            '"' => out.push_str("&quot;"),
            '<' => out.push_str("&lt;"),
            '>' => out.push_str("&gt;"),
            _ => out.push(ch),
        }
    }
    out
}

fn class_tokens(class_attr: Option<&str>) -> Vec<String> {
    class_attr
        .map(|value| {
            value
                .split_whitespace()
                .filter(|token| !token.is_empty())
                .map(ToOwned::to_owned)
                .collect::<Vec<_>>()
        })
        .unwrap_or_default()
}

fn set_class_attr(element: &mut Element, classes: &[String]) {
    if classes.is_empty() {
        element.attrs.remove("class");
    } else {
        element.attrs.insert("class".to_string(), classes.join(" "));
    }
}

fn dataset_key_to_attr_name(key: &str) -> String {
    format!("data-{}", js_prop_to_css_name(key))
}

fn js_prop_to_css_name(prop: &str) -> String {
    let mut out = String::new();
    for ch in prop.chars() {
        if ch.is_ascii_uppercase() {
            out.push('-');
            out.push(ch.to_ascii_lowercase());
        } else {
            out.push(ch);
        }
    }
    out
}

fn parse_style_declarations(style_attr: Option<&str>) -> Vec<(String, String)> {
    let mut out = Vec::new();
    let Some(style_attr) = style_attr else {
        return out;
    };

    let mut start = 0usize;
    let mut i = 0usize;
    let bytes = style_attr.as_bytes();
    let mut paren_depth = 0isize;
    let mut quote: Option<u8> = None;

    while i < bytes.len() {
        let ch = bytes[i];
        match (quote, ch) {
            (Some(q), _) if ch == b'\\' => {
                if i + 1 < bytes.len() {
                    i += 2;
                    continue;
                }
            }
            (Some(q), _) if ch == q => {
                quote = None;
            }
            (Some(_), _) => {}
            (None, b'\'') | (None, b'"') => {
                quote = Some(ch);
            }
            (None, b'(') => paren_depth += 1,
            (None, b')') => paren_depth = paren_depth.saturating_sub(1),
            (None, b';') if paren_depth == 0 => {
                let decl = &style_attr[start..i];
                push_style_declaration(decl, &mut out);
                start = i + 1;
            }
            _ => {}
        }
        i += 1;
    }

    let decl = &style_attr[start..];
    push_style_declaration(decl, &mut out);

    out
}

fn push_style_declaration(raw_decl: &str, out: &mut Vec<(String, String)>) {
    let decl = raw_decl.trim();
    if decl.is_empty() {
        return;
    }

    let bytes = decl.as_bytes();
    let mut colon = None;
    let mut paren_depth = 0isize;
    let mut quote: Option<u8> = None;
    let mut i = 0usize;

    while i < bytes.len() {
        let ch = bytes[i];
        match (quote, ch) {
            (Some(q), _) if ch == b'\\' => {
                if i + 1 < bytes.len() {
                    i += 2;
                    continue;
                }
            }
            (Some(q), _) if ch == q => quote = None,
            (Some(_), _) => {}
            (None, b'\'') | (None, b'"') => quote = Some(ch),
            (None, b'(') => paren_depth += 1,
            (None, b')') => paren_depth = paren_depth.saturating_sub(1),
            (None, b':') if paren_depth == 0 && colon.is_none() => {
                colon = Some(i);
                break;
            }
            _ => {}
        }
        i += 1;
    }

    let Some(colon) = colon else {
        return;
    };

    let name = decl[..colon].trim().to_ascii_lowercase();
    if name.is_empty() {
        return;
    }

    let value = decl[colon + 1..].trim().to_string();

    if let Some(pos) = out.iter().position(|(existing, _)| existing == &name) {
        out[pos].1 = value;
    } else {
        out.push((name, value));
    }
}

fn serialize_style_declarations(decls: &[(String, String)]) -> String {
    let mut out = String::new();
    for (idx, (name, value)) in decls.iter().enumerate() {
        if idx > 0 {
            out.push(' ');
        }
        out.push_str(name);
        out.push_str(": ");
        out.push_str(value);
        out.push(';');
    }
    out
}

fn format_float(value: f64) -> String {
    if value.is_nan() {
        return "NaN".to_string();
    }
    if value == f64::INFINITY {
        return "Infinity".to_string();
    }
    if value == f64::NEG_INFINITY {
        return "-Infinity".to_string();
    }
    if value == 0.0 {
        return "0".to_string();
    }

    let raw = format!("{value}");
    let Some(exp_idx) = raw.find('e').or_else(|| raw.find('E')) else {
        return raw;
    };
    let mantissa = &raw[..exp_idx];
    let exponent_src = &raw[exp_idx + 1..];
    let exponent = exponent_src.parse::<i32>().unwrap_or(0);
    format!("{mantissa}e{:+}", exponent)
}

fn parse_js_parse_float(src: &str) -> f64 {
    let src = src.trim_start();
    if src.is_empty() {
        return f64::NAN;
    }

    let bytes = src.as_bytes();
    let mut i = 0usize;

    if matches!(bytes.get(i), Some(b'+') | Some(b'-')) {
        i += 1;
    }

    if src[i..].starts_with("Infinity") {
        return if matches!(bytes.first(), Some(b'-')) {
            f64::NEG_INFINITY
        } else {
            f64::INFINITY
        };
    }

    let mut int_digits = 0usize;
    while matches!(bytes.get(i), Some(b) if b.is_ascii_digit()) {
        int_digits += 1;
        i += 1;
    }

    let mut frac_digits = 0usize;
    if bytes.get(i) == Some(&b'.') {
        i += 1;
        while matches!(bytes.get(i), Some(b) if b.is_ascii_digit()) {
            frac_digits += 1;
            i += 1;
        }
    }

    if int_digits + frac_digits == 0 {
        return f64::NAN;
    }

    if matches!(bytes.get(i), Some(b'e') | Some(b'E')) {
        let exp_start = i;
        i += 1;
        if matches!(bytes.get(i), Some(b'+') | Some(b'-')) {
            i += 1;
        }

        let mut exp_digits = 0usize;
        while matches!(bytes.get(i), Some(b) if b.is_ascii_digit()) {
            exp_digits += 1;
            i += 1;
        }

        if exp_digits == 0 {
            i = exp_start;
        }
    }

    src[..i].parse::<f64>().unwrap_or(f64::NAN)
}

fn parse_js_parse_int(src: &str, radix: Option<i64>) -> f64 {
    let src = src.trim_start();
    if src.is_empty() {
        return f64::NAN;
    }

    let bytes = src.as_bytes();
    let mut i = 0usize;
    let negative = if matches!(bytes.get(i), Some(b'+') | Some(b'-')) {
        let is_negative = bytes[i] == b'-';
        i += 1;
        is_negative
    } else {
        false
    };

    let mut radix = radix.unwrap_or(0);
    if radix != 0 {
        if !(2..=36).contains(&radix) {
            return f64::NAN;
        }
    } else {
        radix = 10;
        if src[i..].starts_with("0x") || src[i..].starts_with("0X") {
            radix = 16;
            i += 2;
        }
    }

    if radix == 16 && (src[i..].starts_with("0x") || src[i..].starts_with("0X")) {
        i += 2;
    }

    let mut parsed_any = false;
    let mut value = 0.0f64;
    for ch in src[i..].chars() {
        let Some(digit) = ch.to_digit(36) else {
            break;
        };
        if i64::from(digit) >= radix {
            break;
        }
        parsed_any = true;
        value = (value * (radix as f64)) + (digit as f64);
    }

    if !parsed_any {
        return f64::NAN;
    }

    if negative { -value } else { value }
}

fn encode_binary_string_to_base64(src: &str) -> Result<String> {
    const TABLE: &[u8; 64] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    let mut bytes = Vec::with_capacity(src.len());
    for ch in src.chars() {
        let code = ch as u32;
        if code > 0xFF {
            return Err(Error::ScriptRuntime(
                "btoa input contains non-Latin1 character".into(),
            ));
        }
        bytes.push(code as u8);
    }

    let mut out = String::new();
    let mut i = 0usize;
    while i + 3 <= bytes.len() {
        let b0 = bytes[i];
        let b1 = bytes[i + 1];
        let b2 = bytes[i + 2];

        out.push(TABLE[(b0 >> 2) as usize] as char);
        out.push(TABLE[(((b0 & 0x03) << 4) | (b1 >> 4)) as usize] as char);
        out.push(TABLE[(((b1 & 0x0F) << 2) | (b2 >> 6)) as usize] as char);
        out.push(TABLE[(b2 & 0x3F) as usize] as char);
        i += 3;
    }

    let rem = bytes.len().saturating_sub(i);
    if rem == 1 {
        let b0 = bytes[i];
        out.push(TABLE[(b0 >> 2) as usize] as char);
        out.push(TABLE[((b0 & 0x03) << 4) as usize] as char);
        out.push('=');
        out.push('=');
    } else if rem == 2 {
        let b0 = bytes[i];
        let b1 = bytes[i + 1];
        out.push(TABLE[(b0 >> 2) as usize] as char);
        out.push(TABLE[(((b0 & 0x03) << 4) | (b1 >> 4)) as usize] as char);
        out.push(TABLE[((b1 & 0x0F) << 2) as usize] as char);
        out.push('=');
    }

    Ok(out)
}

fn decode_base64_to_binary_string(src: &str) -> Result<String> {
    let mut bytes: Vec<u8> = src.bytes().filter(|b| !b.is_ascii_whitespace()).collect();
    if bytes.is_empty() {
        return Ok(String::new());
    }

    match bytes.len() % 4 {
        0 => {}
        2 => bytes.extend_from_slice(b"=="),
        3 => bytes.push(b'='),
        _ => {
            return Err(Error::ScriptRuntime("atob invalid base64 input".into()));
        }
    }

    let mut out = Vec::new();
    let mut i = 0usize;
    while i < bytes.len() {
        let b0 = bytes[i];
        let b1 = bytes[i + 1];
        let b2 = bytes[i + 2];
        let b3 = bytes[i + 3];

        let v0 = decode_base64_char(b0)?;
        let v1 = decode_base64_char(b1)?;
        out.push((v0 << 2) | (v1 >> 4));

        if b2 == b'=' {
            if b3 != b'=' {
                return Err(Error::ScriptRuntime("atob invalid base64 input".into()));
            }
            i += 4;
            continue;
        }

        let v2 = decode_base64_char(b2)?;
        out.push(((v1 & 0x0F) << 4) | (v2 >> 2));

        if b3 == b'=' {
            i += 4;
            continue;
        }

        let v3 = decode_base64_char(b3)?;
        out.push(((v2 & 0x03) << 6) | v3);
        i += 4;
    }

    Ok(out.into_iter().map(char::from).collect())
}

fn decode_base64_char(ch: u8) -> Result<u8> {
    let value = match ch {
        b'A'..=b'Z' => ch - b'A',
        b'a'..=b'z' => ch - b'a' + 26,
        b'0'..=b'9' => ch - b'0' + 52,
        b'+' => 62,
        b'/' => 63,
        _ => {
            return Err(Error::ScriptRuntime("atob invalid base64 input".into()));
        }
    };
    Ok(value)
}

fn encode_uri_like(src: &str, component: bool) -> String {
    let mut out = String::new();
    for b in src.as_bytes() {
        if is_unescaped_uri_byte(*b, component) {
            out.push(*b as char);
        } else {
            out.push('%');
            out.push(to_hex_upper((*b >> 4) & 0x0F));
            out.push(to_hex_upper(*b & 0x0F));
        }
    }
    out
}

fn decode_uri_like(src: &str, component: bool) -> Result<String> {
    let preserve_reserved = !component;
    let bytes = src.as_bytes();
    let mut out = String::new();
    let mut i = 0usize;

    while i < bytes.len() {
        if bytes[i] != b'%' {
            let ch = src[i..]
                .chars()
                .next()
                .ok_or_else(|| Error::ScriptRuntime("malformed URI sequence".into()))?;
            out.push(ch);
            i += ch.len_utf8();
            continue;
        }

        let first = parse_percent_byte(bytes, i)?;
        if first < 0x80 {
            let ch = first as char;
            if preserve_reserved && is_decode_uri_reserved_char(ch) {
                let raw = src
                    .get(i..i + 3)
                    .ok_or_else(|| Error::ScriptRuntime("malformed URI sequence".into()))?;
                out.push_str(raw);
            } else {
                out.push(ch);
            }
            i += 3;
            continue;
        }

        let len = utf8_sequence_len(first)
            .ok_or_else(|| Error::ScriptRuntime("malformed URI sequence".into()))?;
        let mut raw_end = i + 3;
        let mut chunk = Vec::with_capacity(len);
        chunk.push(first);
        for _ in 1..len {
            if raw_end >= bytes.len() || bytes[raw_end] != b'%' {
                return Err(Error::ScriptRuntime("malformed URI sequence".into()));
            }
            chunk.push(parse_percent_byte(bytes, raw_end)?);
            raw_end += 3;
        }
        let decoded = std::str::from_utf8(&chunk)
            .map_err(|_| Error::ScriptRuntime("malformed URI sequence".into()))?;
        out.push_str(decoded);
        i = raw_end;
    }

    Ok(out)
}

fn js_escape(src: &str) -> String {
    let mut out = String::new();
    for unit in src.encode_utf16() {
        if unit <= 0x7F && is_unescaped_legacy_escape_byte(unit as u8) {
            out.push(unit as u8 as char);
            continue;
        }

        if unit <= 0xFF {
            let value = unit as u8;
            out.push('%');
            out.push(to_hex_upper((value >> 4) & 0x0F));
            out.push(to_hex_upper(value & 0x0F));
            continue;
        }

        out.push('%');
        out.push('u');
        out.push(to_hex_upper(((unit >> 12) & 0x0F) as u8));
        out.push(to_hex_upper(((unit >> 8) & 0x0F) as u8));
        out.push(to_hex_upper(((unit >> 4) & 0x0F) as u8));
        out.push(to_hex_upper((unit & 0x0F) as u8));
    }
    out
}

fn js_unescape(src: &str) -> String {
    let bytes = src.as_bytes();
    let mut units: Vec<u16> = Vec::with_capacity(src.len());
    let mut i = 0usize;

    while i < bytes.len() {
        if bytes[i] == b'%' {
            if i + 5 < bytes.len()
                && matches!(bytes[i + 1], b'u' | b'U')
                && from_hex_digit(bytes[i + 2]).is_some()
                && from_hex_digit(bytes[i + 3]).is_some()
                && from_hex_digit(bytes[i + 4]).is_some()
                && from_hex_digit(bytes[i + 5]).is_some()
            {
                let u = ((from_hex_digit(bytes[i + 2]).unwrap_or(0) as u16) << 12)
                    | ((from_hex_digit(bytes[i + 3]).unwrap_or(0) as u16) << 8)
                    | ((from_hex_digit(bytes[i + 4]).unwrap_or(0) as u16) << 4)
                    | (from_hex_digit(bytes[i + 5]).unwrap_or(0) as u16);
                units.push(u);
                i += 6;
                continue;
            }

            if i + 2 < bytes.len()
                && from_hex_digit(bytes[i + 1]).is_some()
                && from_hex_digit(bytes[i + 2]).is_some()
            {
                let u = ((from_hex_digit(bytes[i + 1]).unwrap_or(0) << 4)
                    | from_hex_digit(bytes[i + 2]).unwrap_or(0)) as u16;
                units.push(u);
                i += 3;
                continue;
            }
        }

        let ch = src[i..].chars().next().unwrap_or_default();
        let mut buf = [0u16; 2];
        for unit in ch.encode_utf16(&mut buf).iter().copied() {
            units.push(unit);
        }
        i += ch.len_utf8();
    }

    String::from_utf16_lossy(&units)
}

fn is_unescaped_uri_byte(b: u8, component: bool) -> bool {
    if b.is_ascii_alphanumeric() {
        return true;
    }
    if matches!(
        b,
        b'-' | b'_' | b'.' | b'!' | b'~' | b'*' | b'\'' | b'(' | b')'
    ) {
        return true;
    }
    if !component
        && matches!(
            b,
            b';' | b',' | b'/' | b'?' | b':' | b'@' | b'&' | b'=' | b'+' | b'$' | b'#'
        )
    {
        return true;
    }
    false
}

fn is_decode_uri_reserved_char(ch: char) -> bool {
    matches!(
        ch,
        ';' | ',' | '/' | '?' | ':' | '@' | '&' | '=' | '+' | '$' | '#'
    )
}

fn is_unescaped_legacy_escape_byte(b: u8) -> bool {
    b.is_ascii_alphanumeric() || matches!(b, b'*' | b'+' | b'-' | b'.' | b'/' | b'@' | b'_')
}

fn parse_percent_byte(bytes: &[u8], offset: usize) -> Result<u8> {
    if offset + 2 >= bytes.len() || bytes[offset] != b'%' {
        return Err(Error::ScriptRuntime("malformed URI sequence".into()));
    }
    let hi = from_hex_digit(bytes[offset + 1])
        .ok_or_else(|| Error::ScriptRuntime("malformed URI sequence".into()))?;
    let lo = from_hex_digit(bytes[offset + 2])
        .ok_or_else(|| Error::ScriptRuntime("malformed URI sequence".into()))?;
    Ok((hi << 4) | lo)
}

fn utf8_sequence_len(first: u8) -> Option<usize> {
    match first {
        0xC2..=0xDF => Some(2),
        0xE0..=0xEF => Some(3),
        0xF0..=0xF4 => Some(4),
        _ => None,
    }
}

fn from_hex_digit(b: u8) -> Option<u8> {
    match b {
        b'0'..=b'9' => Some(b - b'0'),
        b'a'..=b'f' => Some(b - b'a' + 10),
        b'A'..=b'F' => Some(b - b'A' + 10),
        _ => None,
    }
}

fn to_hex_upper(nibble: u8) -> char {
    match nibble {
        0..=9 => (b'0' + nibble) as char,
        10..=15 => (b'A' + (nibble - 10)) as char,
        _ => '?',
    }
}

fn truncate_chars(value: &str, max_chars: usize) -> String {
    let mut it = value.chars();
    let mut out = String::new();
    for _ in 0..max_chars {
        let Some(ch) = it.next() else {
            return out;
        };
        out.push(ch);
    }
    if it.next().is_some() {
        out.push_str("...");
    }
    out
}

#[derive(Debug, Clone, PartialEq, Eq)]
enum SelectorAttrCondition {
    Exists { key: String },
    Eq { key: String, value: String },
    StartsWith { key: String, value: String },
    EndsWith { key: String, value: String },
    Contains { key: String, value: String },
    Includes { key: String, value: String },
    DashMatch { key: String, value: String },
}

#[derive(Debug, Clone, PartialEq, Eq)]
enum SelectorPseudoClass {
    FirstChild,
    LastChild,
    FirstOfType,
    LastOfType,
    OnlyChild,
    OnlyOfType,
    Checked,
    Disabled,
    Enabled,
    Required,
    Optional,
    Readonly,
    Readwrite,
    Empty,
    Focus,
    FocusWithin,
    Active,
    NthOfType(NthChildSelector),
    NthLastOfType(NthChildSelector),
    Not(Vec<Vec<SelectorPart>>),
    Is(Vec<Vec<SelectorPart>>),
    Where(Vec<Vec<SelectorPart>>),
    Has(Vec<Vec<SelectorPart>>),
    NthChild(NthChildSelector),
    NthLastChild(NthChildSelector),
}

#[derive(Debug, Clone, PartialEq, Eq)]
enum NthChildSelector {
    Exact(usize),
    Odd,
    Even,
    AnPlusB(i64, i64),
}

#[derive(Debug, Clone, Default, PartialEq, Eq)]
struct SelectorStep {
    tag: Option<String>,
    universal: bool,
    id: Option<String>,
    classes: Vec<String>,
    attrs: Vec<SelectorAttrCondition>,
    pseudo_classes: Vec<SelectorPseudoClass>,
}

impl SelectorStep {
    fn id_only(&self) -> Option<&str> {
        if !self.universal
            && self.tag.is_none()
            && self.classes.is_empty()
            && self.attrs.is_empty()
            && self.pseudo_classes.is_empty()
        {
            self.id.as_deref()
        } else {
            None
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum SelectorCombinator {
    Descendant,
    Child,
    AdjacentSibling,
    GeneralSibling,
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct SelectorPart {
    step: SelectorStep,
    // Relation to previous (left) selector part.
    combinator: Option<SelectorCombinator>,
}

fn parse_selector_chain(selector: &str) -> Result<Vec<SelectorPart>> {
    let selector = selector.trim();
    if selector.is_empty() {
        return Err(Error::UnsupportedSelector(selector.into()));
    }

    let tokens = tokenize_selector(selector)?;
    let mut steps = Vec::new();
    let mut pending_combinator: Option<SelectorCombinator> = None;

    for token in tokens {
        if token == ">" || token == "+" || token == "~" {
            if pending_combinator.is_some() || steps.is_empty() {
                return Err(Error::UnsupportedSelector(selector.into()));
            }
            pending_combinator = Some(match token.as_str() {
                ">" => SelectorCombinator::Child,
                "+" => SelectorCombinator::AdjacentSibling,
                "~" => SelectorCombinator::GeneralSibling,
                _ => unreachable!(),
            });
            continue;
        }

        let step = parse_selector_step(&token)?;
        let combinator = if steps.is_empty() {
            None
        } else {
            Some(
                pending_combinator
                    .take()
                    .unwrap_or(SelectorCombinator::Descendant),
            )
        };
        steps.push(SelectorPart { step, combinator });
    }

    if steps.is_empty() || pending_combinator.is_some() {
        return Err(Error::UnsupportedSelector(selector.into()));
    }

    Ok(steps)
}

fn parse_selector_groups(selector: &str) -> Result<Vec<Vec<SelectorPart>>> {
    let groups = split_selector_groups(selector)?;
    let mut parsed = Vec::with_capacity(groups.len());
    for group in groups {
        parsed.push(parse_selector_chain(&group)?);
    }
    Ok(parsed)
}

fn split_selector_groups(selector: &str) -> Result<Vec<String>> {
    let mut groups = Vec::new();
    let mut current = String::new();
    let mut bracket_depth = 0usize;
    let mut paren_depth = 0usize;

    for ch in selector.chars() {
        match ch {
            '[' => {
                bracket_depth += 1;
                current.push(ch);
            }
            ']' => {
                if bracket_depth == 0 {
                    return Err(Error::UnsupportedSelector(selector.into()));
                }
                bracket_depth -= 1;
                current.push(ch);
            }
            '(' => {
                paren_depth += 1;
                current.push(ch);
            }
            ')' => {
                if paren_depth == 0 {
                    return Err(Error::UnsupportedSelector(selector.into()));
                }
                paren_depth -= 1;
                current.push(ch);
            }
            ',' if bracket_depth == 0 && paren_depth == 0 => {
                let trimmed = current.trim();
                if trimmed.is_empty() {
                    return Err(Error::UnsupportedSelector(selector.into()));
                }
                groups.push(trimmed.to_string());
                current.clear();
            }
            _ => current.push(ch),
        }
    }

    if bracket_depth != 0 {
        return Err(Error::UnsupportedSelector(selector.into()));
    }
    if paren_depth != 0 {
        return Err(Error::UnsupportedSelector(selector.into()));
    }

    let trimmed = current.trim();
    if trimmed.is_empty() {
        return Err(Error::UnsupportedSelector(selector.into()));
    }
    groups.push(trimmed.to_string());
    Ok(groups)
}

fn tokenize_selector(selector: &str) -> Result<Vec<String>> {
    let mut tokens = Vec::new();
    let mut current = String::new();
    let mut bracket_depth = 0usize;
    let mut paren_depth = 0usize;

    for ch in selector.chars() {
        match ch {
            '[' => {
                bracket_depth += 1;
                current.push(ch);
            }
            ']' => {
                if bracket_depth == 0 {
                    return Err(Error::UnsupportedSelector(selector.into()));
                }
                bracket_depth -= 1;
                current.push(ch);
            }
            '(' => {
                paren_depth += 1;
                current.push(ch);
            }
            ')' => {
                if paren_depth == 0 {
                    return Err(Error::UnsupportedSelector(selector.into()));
                }
                paren_depth -= 1;
                current.push(ch);
            }
            '>' | '+' | '~' if bracket_depth == 0 && paren_depth == 0 => {
                if !current.trim().is_empty() {
                    tokens.push(current.trim().to_string());
                }
                current.clear();
                tokens.push(ch.to_string());
            }
            ch if ch.is_ascii_whitespace() && bracket_depth == 0 && paren_depth == 0 => {
                if !current.trim().is_empty() {
                    tokens.push(current.trim().to_string());
                }
                current.clear();
            }
            _ => current.push(ch),
        }
    }

    if bracket_depth != 0 {
        return Err(Error::UnsupportedSelector(selector.into()));
    }
    if paren_depth != 0 {
        return Err(Error::UnsupportedSelector(selector.into()));
    }

    if !current.trim().is_empty() {
        tokens.push(current.trim().to_string());
    }

    Ok(tokens)
}

fn parse_selector_step(part: &str) -> Result<SelectorStep> {
    let part = part.trim();
    if part.is_empty() {
        return Err(Error::UnsupportedSelector(part.into()));
    }

    let bytes = part.as_bytes();
    let mut i = 0usize;
    let mut step = SelectorStep::default();

    while i < bytes.len() {
        match bytes[i] {
            b'*' => {
                if step.universal {
                    return Err(Error::UnsupportedSelector(part.into()));
                }
                step.universal = true;
                i += 1;
            }
            b'#' => {
                i += 1;
                let Some((id, next)) = parse_selector_ident(part, i) else {
                    return Err(Error::UnsupportedSelector(part.into()));
                };
                if step.id.replace(id).is_some() {
                    return Err(Error::UnsupportedSelector(part.into()));
                }
                i = next;
            }
            b'.' => {
                i += 1;
                let Some((class_name, next)) = parse_selector_ident(part, i) else {
                    return Err(Error::UnsupportedSelector(part.into()));
                };
                step.classes.push(class_name);
                i = next;
            }
            b'[' => {
                let (attr, next) = parse_selector_attr_condition(part, i)?;
                step.attrs.push(attr);
                i = next;
            }
            b':' => {
                let Some((pseudo, next)) = parse_selector_pseudo(part, i) else {
                    return Err(Error::UnsupportedSelector(part.into()));
                };
                step.pseudo_classes.push(pseudo);
                i = next;
            }
            _ => {
                if step.tag.is_some()
                    || step.id.is_some()
                    || !step.classes.is_empty()
                    || step.universal
                {
                    return Err(Error::UnsupportedSelector(part.into()));
                }
                let Some((tag, next)) = parse_selector_ident(part, i) else {
                    return Err(Error::UnsupportedSelector(part.into()));
                };
                step.tag = Some(tag);
                i = next;
            }
        }
    }

    if step.tag.is_none()
        && step.id.is_none()
        && step.classes.is_empty()
        && step.attrs.is_empty()
        && !step.universal
        && step.pseudo_classes.is_empty()
    {
        return Err(Error::UnsupportedSelector(part.into()));
    }
    Ok(step)
}

fn parse_selector_pseudo(part: &str, start: usize) -> Option<(SelectorPseudoClass, usize)> {
    if part.as_bytes().get(start)? != &b':' {
        return None;
    }
    let start = start + 1;
    let tail = part.get(start..)?;
    if let Some(rest) = tail.strip_prefix("first-child") {
        if rest.is_empty() || is_selector_continuation(rest.as_bytes().first()?) {
            let consumed = start + "first-child".len();
            return Some((SelectorPseudoClass::FirstChild, consumed));
        }
    }

    if let Some(rest) = tail.strip_prefix("last-child") {
        if rest.is_empty() || is_selector_continuation(rest.as_bytes().first()?) {
            let consumed = start + "last-child".len();
            return Some((SelectorPseudoClass::LastChild, consumed));
        }
    }

    if let Some(rest) = tail.strip_prefix("first-of-type") {
        if rest.is_empty() || is_selector_continuation(rest.as_bytes().first()?) {
            let consumed = start + "first-of-type".len();
            return Some((SelectorPseudoClass::FirstOfType, consumed));
        }
    }

    if let Some(rest) = tail.strip_prefix("last-of-type") {
        if rest.is_empty() || is_selector_continuation(rest.as_bytes().first()?) {
            let consumed = start + "last-of-type".len();
            return Some((SelectorPseudoClass::LastOfType, consumed));
        }
    }

    if let Some(rest) = tail.strip_prefix("only-child") {
        if rest.is_empty() || is_selector_continuation(rest.as_bytes().first()?) {
            let consumed = start + "only-child".len();
            return Some((SelectorPseudoClass::OnlyChild, consumed));
        }
    }

    if let Some(rest) = tail.strip_prefix("only-of-type") {
        if rest.is_empty() || is_selector_continuation(rest.as_bytes().first()?) {
            let consumed = start + "only-of-type".len();
            return Some((SelectorPseudoClass::OnlyOfType, consumed));
        }
    }

    if let Some(rest) = tail.strip_prefix("checked") {
        if rest.is_empty() || is_selector_continuation(rest.as_bytes().first()?) {
            let consumed = start + "checked".len();
            return Some((SelectorPseudoClass::Checked, consumed));
        }
    }

    if let Some(rest) = tail.strip_prefix("disabled") {
        if rest.is_empty() || is_selector_continuation(rest.as_bytes().first()?) {
            let consumed = start + "disabled".len();
            return Some((SelectorPseudoClass::Disabled, consumed));
        }
    }

    if let Some(rest) = tail.strip_prefix("required") {
        if rest.is_empty() || is_selector_continuation(rest.as_bytes().first()?) {
            let consumed = start + "required".len();
            return Some((SelectorPseudoClass::Required, consumed));
        }
    }

    if let Some(rest) = tail.strip_prefix("optional") {
        if rest.is_empty() || is_selector_continuation(rest.as_bytes().first()?) {
            let consumed = start + "optional".len();
            return Some((SelectorPseudoClass::Optional, consumed));
        }
    }

    if let Some(rest) = tail.strip_prefix("read-only") {
        if rest.is_empty() || is_selector_continuation(rest.as_bytes().first()?) {
            let consumed = start + "read-only".len();
            return Some((SelectorPseudoClass::Readonly, consumed));
        }
    }

    if let Some(rest) = tail.strip_prefix("readonly") {
        if rest.is_empty() || is_selector_continuation(rest.as_bytes().first()?) {
            let consumed = start + "readonly".len();
            return Some((SelectorPseudoClass::Readonly, consumed));
        }
    }

    if let Some(rest) = tail.strip_prefix("read-write") {
        if rest.is_empty() || is_selector_continuation(rest.as_bytes().first()?) {
            let consumed = start + "read-write".len();
            return Some((SelectorPseudoClass::Readwrite, consumed));
        }
    }

    if let Some(rest) = tail.strip_prefix("empty") {
        if rest.is_empty() || is_selector_continuation(rest.as_bytes().first()?) {
            let consumed = start + "empty".len();
            return Some((SelectorPseudoClass::Empty, consumed));
        }
    }

    if let Some(rest) = tail.strip_prefix("focus-within") {
        if rest.is_empty() || is_selector_continuation(rest.as_bytes().first()?) {
            let consumed = start + "focus-within".len();
            return Some((SelectorPseudoClass::FocusWithin, consumed));
        }
    }

    if let Some(rest) = tail.strip_prefix("focus") {
        if rest.is_empty() || is_selector_continuation(rest.as_bytes().first()?) {
            let consumed = start + "focus".len();
            return Some((SelectorPseudoClass::Focus, consumed));
        }
    }

    if let Some(rest) = tail.strip_prefix("active") {
        if rest.is_empty() || is_selector_continuation(rest.as_bytes().first()?) {
            let consumed = start + "active".len();
            return Some((SelectorPseudoClass::Active, consumed));
        }
    }

    if let Some(rest) = tail.strip_prefix("enabled") {
        if rest.is_empty() || is_selector_continuation(rest.as_bytes().first()?) {
            let consumed = start + "enabled".len();
            return Some((SelectorPseudoClass::Enabled, consumed));
        }
    }

    if let Some((inners, next)) = parse_pseudo_selector_list(part, start, "not(") {
        return Some((SelectorPseudoClass::Not(inners), next));
    }

    if let Some((inners, next)) = parse_pseudo_selector_list(part, start, "is(") {
        return Some((SelectorPseudoClass::Is(inners), next));
    }

    if let Some((inners, next)) = parse_pseudo_selector_list(part, start, "where(") {
        return Some((SelectorPseudoClass::Where(inners), next));
    }

    if let Some((inners, next)) = parse_pseudo_selector_list(part, start, "has(") {
        return Some((SelectorPseudoClass::Has(inners), next));
    }

    if let Some(rest) = tail.strip_prefix("nth-last-of-type(") {
        let body = rest;
        let Some(close_pos) = find_matching_paren(body) else {
            return None;
        };
        let raw = body[..close_pos].trim();
        if raw.is_empty() {
            return None;
        }
        let selector = parse_nth_child_selector(raw)?;
        let next = start + "nth-last-of-type(".len() + close_pos + 1;
        if let Some(ch) = part.as_bytes().get(next) {
            if !is_selector_continuation(ch) {
                return None;
            }
        }
        return Some((SelectorPseudoClass::NthLastOfType(selector), next));
    }

    if let Some(rest) = tail.strip_prefix("nth-of-type(") {
        let body = rest;
        let Some(close_pos) = find_matching_paren(body) else {
            return None;
        };
        let raw = body[..close_pos].trim();
        if raw.is_empty() {
            return None;
        }
        let selector = parse_nth_child_selector(raw)?;
        let next = start + "nth-of-type(".len() + close_pos + 1;
        if let Some(ch) = part.as_bytes().get(next) {
            if !is_selector_continuation(ch) {
                return None;
            }
        }
        return Some((SelectorPseudoClass::NthOfType(selector), next));
    }

    if let Some(rest) = tail.strip_prefix("nth-last-child(") {
        let body = rest;
        let Some(close_pos) = find_matching_paren(body) else {
            return None;
        };
        let raw = body[..close_pos].trim();
        if raw.is_empty() {
            return None;
        }
        let selector = parse_nth_child_selector(raw)?;
        let next = start + "nth-last-child(".len() + close_pos + 1;
        if let Some(ch) = part.as_bytes().get(next) {
            if !is_selector_continuation(ch) {
                return None;
            }
        }
        return Some((SelectorPseudoClass::NthLastChild(selector), next));
    }

    if let Some(rest) = tail.strip_prefix("nth-child(") {
        let body = rest;
        let Some(close_pos) = find_matching_paren(body) else {
            return None;
        };
        let raw = body[..close_pos].trim();
        if raw.is_empty() {
            return None;
        }
        let selector = parse_nth_child_selector(raw)?;
        let next = start + "nth-child(".len() + close_pos + 1;
        if let Some(ch) = part.as_bytes().get(next) {
            if !is_selector_continuation(ch) {
                return None;
            }
        }
        return Some((SelectorPseudoClass::NthChild(selector), next));
    }

    None
}

fn parse_pseudo_selector_list(
    part: &str,
    start: usize,
    prefix: &str,
) -> Option<(Vec<Vec<SelectorPart>>, usize)> {
    let Some(rest) = part.get(start..).and_then(|tail| tail.strip_prefix(prefix)) else {
        return None;
    };

    let Some(close_pos) = find_matching_paren(rest) else {
        return None;
    };
    let body = rest[..close_pos].trim();
    if body.is_empty() {
        return None;
    }

    let mut groups = split_selector_groups(body).ok()?;
    if groups.is_empty() {
        return None;
    }

    let mut selectors = Vec::with_capacity(groups.len());
    for group in &mut groups {
        let chain = parse_selector_chain(group.trim()).ok()?;
        if chain.is_empty() {
            return None;
        }
        selectors.push(chain);
    }

    let next = start + prefix.len() + close_pos + 1;
    if let Some(ch) = part.as_bytes().get(next) {
        if !is_selector_continuation(ch) {
            return None;
        }
    }
    Some((selectors, next))
}

fn find_matching_paren(body: &str) -> Option<usize> {
    let mut paren_depth = 1usize;
    let mut bracket_depth = 0usize;
    let mut quote: Option<u8> = None;
    let mut escaped = false;

    for (idx, b) in body.bytes().enumerate() {
        if let Some(q) = quote {
            if escaped {
                escaped = false;
                continue;
            }
            if b == b'\\' {
                escaped = true;
                continue;
            }
            if b == q {
                quote = None;
            }
            continue;
        }

        match b {
            b'\'' | b'"' => quote = Some(b),
            b'[' => {
                bracket_depth += 1;
            }
            b']' => {
                if bracket_depth == 0 {
                    return None;
                }
                bracket_depth -= 1;
            }
            b'(' if bracket_depth == 0 => {
                paren_depth += 1;
            }
            b')' if bracket_depth == 0 => {
                paren_depth = paren_depth.checked_sub(1)?;
                if paren_depth == 0 {
                    return Some(idx);
                }
            }
            _ => {}
        }
    }
    None
}

fn parse_nth_child_selector(raw: &str) -> Option<NthChildSelector> {
    let compact = raw
        .chars()
        .filter(|c| !c.is_ascii_whitespace())
        .collect::<String>()
        .to_ascii_lowercase();
    if compact.is_empty() {
        return None;
    }

    match compact.as_str() {
        "odd" => Some(NthChildSelector::Odd),
        "even" => Some(NthChildSelector::Even),
        other => {
            if other.contains('n') {
                parse_nth_child_expression(other)
            } else {
                if other.starts_with('+') || other.starts_with('-') {
                    None
                } else {
                    let value = other.parse::<usize>().ok()?;
                    if value == 0 {
                        None
                    } else {
                        Some(NthChildSelector::Exact(value))
                    }
                }
            }
        }
    }
}

fn parse_nth_child_expression(raw: &str) -> Option<NthChildSelector> {
    let expr = raw
        .chars()
        .filter(|c| !c.is_ascii_whitespace())
        .collect::<String>();
    let expr = expr.to_ascii_lowercase();
    if expr.matches('n').count() != 1 {
        return None;
    }
    if expr.starts_with(|c: char| c == '+' || c == '-') && expr.len() == 1 {
        return None;
    }

    let n_pos = expr.find('n')?;
    let (a_part, rest) = expr.split_at(n_pos);
    let b_part = &rest[1..];

    let a = match a_part {
        "" => 1,
        "-" => -1,
        "+" => return None,
        _ => a_part.parse::<i64>().ok()?,
    };

    if b_part.is_empty() {
        return Some(NthChildSelector::AnPlusB(a, 0));
    }

    let mut sign = 1;
    let raw_b = if let Some(rest) = b_part.strip_prefix('+') {
        rest
    } else if let Some(rest) = b_part.strip_prefix('-') {
        sign = -1;
        rest
    } else {
        return None;
    };
    if raw_b.is_empty() {
        return None;
    }
    let b = raw_b.parse::<i64>().ok()?;
    Some(NthChildSelector::AnPlusB(a, b * sign))
}

fn is_selector_continuation(next: &u8) -> bool {
    matches!(next, b'.' | b'#' | b'[' | b':')
}

fn parse_selector_ident(src: &str, start: usize) -> Option<(String, usize)> {
    let bytes = src.as_bytes();
    if start >= bytes.len() || !is_selector_ident_char(bytes[start]) {
        return None;
    }
    let mut end = start + 1;
    while end < bytes.len() && is_selector_ident_char(bytes[end]) {
        end += 1;
    }
    Some((src.get(start..end)?.to_string(), end))
}

fn is_selector_ident_char(b: u8) -> bool {
    b.is_ascii_alphanumeric() || b == b'_' || b == b'-'
}

fn parse_selector_attr_condition(
    src: &str,
    open_bracket: usize,
) -> Result<(SelectorAttrCondition, usize)> {
    let bytes = src.as_bytes();
    let mut i = open_bracket + 1;

    while i < bytes.len() && bytes[i].is_ascii_whitespace() {
        i += 1;
    }
    if i >= bytes.len() {
        return Err(Error::UnsupportedSelector(src.into()));
    }

    let key_start = i;
    while i < bytes.len() {
        if is_selector_attr_name_char(bytes[i]) {
            i += 1;
            continue;
        }
        break;
    }
    if key_start == i {
        return Err(Error::UnsupportedSelector(src.into()));
    }
    let key = src
        .get(key_start..i)
        .ok_or_else(|| Error::UnsupportedSelector(src.into()))?
        .to_ascii_lowercase();

    while i < bytes.len() && bytes[i].is_ascii_whitespace() {
        i += 1;
    }
    if i >= bytes.len() {
        return Err(Error::UnsupportedSelector(src.into()));
    }

    if bytes[i] == b']' {
        return Ok((SelectorAttrCondition::Exists { key }, i + 1));
    }

    let (op, mut next) = match bytes.get(i) {
        Some(b'=') => (SelectorAttrConditionType::Eq, i + 1),
        Some(b'^') if bytes.get(i + 1) == Some(&b'=') => {
            (SelectorAttrConditionType::StartsWith, i + 2)
        }
        Some(b'$') if bytes.get(i + 1) == Some(&b'=') => {
            (SelectorAttrConditionType::EndsWith, i + 2)
        }
        Some(b'*') if bytes.get(i + 1) == Some(&b'=') => {
            (SelectorAttrConditionType::Contains, i + 2)
        }
        Some(b'~') if bytes.get(i + 1) == Some(&b'=') => {
            (SelectorAttrConditionType::Includes, i + 2)
        }
        Some(b'|') if bytes.get(i + 1) == Some(&b'=') => {
            (SelectorAttrConditionType::DashMatch, i + 2)
        }
        _ => return Err(Error::UnsupportedSelector(src.into())),
    };

    i = next;
    while i < bytes.len() && bytes[i].is_ascii_whitespace() {
        i += 1;
    }
    if i >= bytes.len() {
        return Err(Error::UnsupportedSelector(src.into()));
    }

    let (value, after_value) = parse_selector_attr_value(src, i)?;
    next = after_value;

    i = next;
    while i < bytes.len() && bytes[i].is_ascii_whitespace() {
        i += 1;
    }
    if i >= bytes.len() || bytes[i] != b']' {
        return Err(Error::UnsupportedSelector(src.into()));
    }

    let cond = match op {
        SelectorAttrConditionType::Eq => SelectorAttrCondition::Eq { key, value },
        SelectorAttrConditionType::StartsWith => SelectorAttrCondition::StartsWith { key, value },
        SelectorAttrConditionType::EndsWith => SelectorAttrCondition::EndsWith { key, value },
        SelectorAttrConditionType::Contains => SelectorAttrCondition::Contains { key, value },
        SelectorAttrConditionType::Includes => SelectorAttrCondition::Includes { key, value },
        SelectorAttrConditionType::DashMatch => SelectorAttrCondition::DashMatch { key, value },
    };

    Ok((cond, i + 1))
}

#[derive(Debug, Clone, Copy)]
enum SelectorAttrConditionType {
    Eq,
    StartsWith,
    EndsWith,
    Contains,
    Includes,
    DashMatch,
}

fn is_selector_attr_name_char(b: u8) -> bool {
    b.is_ascii_alphanumeric() || b == b'_' || b == b'-' || b == b':'
}

fn parse_selector_attr_value(src: &str, start: usize) -> Result<(String, usize)> {
    let bytes = src.as_bytes();
    if start >= bytes.len() {
        return Err(Error::UnsupportedSelector(src.into()));
    }

    if bytes[start] == b'"' || bytes[start] == b'\'' {
        let quote = bytes[start];
        let mut i = start + 1;
        while i < bytes.len() {
            if bytes[i] == b'\\' {
                i = (i + 2).min(bytes.len());
                continue;
            }
            if bytes[i] == quote {
                let raw = src
                    .get(start + 1..i)
                    .ok_or_else(|| Error::UnsupportedSelector(src.into()))?;
                return Ok((unescape_string(raw), i + 1));
            }
            i += 1;
        }
        return Err(Error::UnsupportedSelector(src.into()));
    }

    let start_value = start;
    let mut i = start;
    while i < bytes.len() {
        if bytes[i].is_ascii_whitespace() || bytes[i] == b']' {
            break;
        }
        if bytes[i] == b'\\' {
            i = (i + 2).min(bytes.len());
            continue;
        }
        i += 1;
    }
    if i == start_value {
        return Ok(("".to_string(), i));
    }
    let raw = src
        .get(start_value..i)
        .ok_or_else(|| Error::UnsupportedSelector(src.into()))?;
    Ok((unescape_string(raw), i))
}

#[derive(Debug, Clone, PartialEq)]
struct ArrayBufferValue {
    bytes: Vec<u8>,
    max_byte_length: Option<usize>,
    detached: bool,
}

impl ArrayBufferValue {
    fn byte_length(&self) -> usize {
        if self.detached { 0 } else { self.bytes.len() }
    }

    fn max_byte_length(&self) -> usize {
        if self.detached {
            0
        } else {
            self.max_byte_length.unwrap_or(self.bytes.len())
        }
    }

    fn resizable(&self) -> bool {
        !self.detached && self.max_byte_length.is_some()
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum TypedArrayKind {
    Int8,
    Uint8,
    Uint8Clamped,
    Int16,
    Uint16,
    Int32,
    Uint32,
    Float16,
    Float32,
    Float64,
    BigInt64,
    BigUint64,
}

impl TypedArrayKind {
    fn bytes_per_element(&self) -> usize {
        match self {
            Self::Int8 | Self::Uint8 | Self::Uint8Clamped => 1,
            Self::Int16 | Self::Uint16 | Self::Float16 => 2,
            Self::Int32 | Self::Uint32 | Self::Float32 => 4,
            Self::Float64 | Self::BigInt64 | Self::BigUint64 => 8,
        }
    }

    fn is_bigint(&self) -> bool {
        matches!(self, Self::BigInt64 | Self::BigUint64)
    }

    fn name(&self) -> &'static str {
        match self {
            Self::Int8 => "Int8Array",
            Self::Uint8 => "Uint8Array",
            Self::Uint8Clamped => "Uint8ClampedArray",
            Self::Int16 => "Int16Array",
            Self::Uint16 => "Uint16Array",
            Self::Int32 => "Int32Array",
            Self::Uint32 => "Uint32Array",
            Self::Float16 => "Float16Array",
            Self::Float32 => "Float32Array",
            Self::Float64 => "Float64Array",
            Self::BigInt64 => "BigInt64Array",
            Self::BigUint64 => "BigUint64Array",
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
enum TypedArrayConstructorKind {
    Concrete(TypedArrayKind),
    Abstract,
}

#[derive(Debug, Clone, PartialEq)]
struct TypedArrayValue {
    kind: TypedArrayKind,
    buffer: Rc<RefCell<ArrayBufferValue>>,
    byte_offset: usize,
    fixed_length: Option<usize>,
}

impl TypedArrayValue {
    fn observed_length(&self) -> usize {
        let buffer_len = self.buffer.borrow().byte_length();
        let bytes_per = self.kind.bytes_per_element();
        if self.byte_offset >= buffer_len {
            return 0;
        }

        let available_bytes = buffer_len - self.byte_offset;
        if let Some(fixed_length) = self.fixed_length {
            let fixed_bytes = fixed_length.saturating_mul(bytes_per);
            if available_bytes < fixed_bytes {
                0
            } else {
                fixed_length
            }
        } else {
            available_bytes / bytes_per
        }
    }

    fn observed_byte_length(&self) -> usize {
        self.observed_length()
            .saturating_mul(self.kind.bytes_per_element())
    }
}

#[derive(Debug, Clone, PartialEq)]
struct MapValue {
    entries: Vec<(Value, Value)>,
    properties: Vec<(String, Value)>,
}

#[derive(Debug, Clone, PartialEq)]
struct SetValue {
    values: Vec<Value>,
    properties: Vec<(String, Value)>,
}

#[derive(Debug, Clone)]
struct PromiseValue {
    id: usize,
    state: PromiseState,
    reactions: Vec<PromiseReaction>,
}

impl PartialEq for PromiseValue {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}

#[derive(Debug, Clone)]
enum PromiseState {
    Pending,
    Fulfilled(Value),
    Rejected(Value),
}

#[derive(Debug, Clone)]
struct PromiseReaction {
    kind: PromiseReactionKind,
}

#[derive(Debug, Clone)]
enum PromiseReactionKind {
    Then {
        on_fulfilled: Option<Value>,
        on_rejected: Option<Value>,
        result: Rc<RefCell<PromiseValue>>,
    },
    Finally {
        callback: Option<Value>,
        result: Rc<RefCell<PromiseValue>>,
    },
    FinallyContinuation {
        original: PromiseSettledValue,
        result: Rc<RefCell<PromiseValue>>,
    },
    ResolveTo {
        target: Rc<RefCell<PromiseValue>>,
    },
    All {
        state: Rc<RefCell<PromiseAllState>>,
        index: usize,
    },
    AllSettled {
        state: Rc<RefCell<PromiseAllSettledState>>,
        index: usize,
    },
    Any {
        state: Rc<RefCell<PromiseAnyState>>,
        index: usize,
    },
    Race {
        state: Rc<RefCell<PromiseRaceState>>,
    },
}

#[derive(Debug, Clone)]
enum PromiseSettledValue {
    Fulfilled(Value),
    Rejected(Value),
}

#[derive(Debug, Clone)]
struct PromiseAllState {
    result: Rc<RefCell<PromiseValue>>,
    remaining: usize,
    values: Vec<Option<Value>>,
    settled: bool,
}

#[derive(Debug, Clone)]
struct PromiseAllSettledState {
    result: Rc<RefCell<PromiseValue>>,
    remaining: usize,
    values: Vec<Option<Value>>,
}

#[derive(Debug, Clone)]
struct PromiseAnyState {
    result: Rc<RefCell<PromiseValue>>,
    remaining: usize,
    reasons: Vec<Option<Value>>,
    settled: bool,
}

#[derive(Debug, Clone)]
struct PromiseRaceState {
    result: Rc<RefCell<PromiseValue>>,
    settled: bool,
}

#[derive(Debug, Clone)]
struct PromiseCapabilityFunction {
    promise: Rc<RefCell<PromiseValue>>,
    reject: bool,
    already_called: Rc<RefCell<bool>>,
}

impl PartialEq for PromiseCapabilityFunction {
    fn eq(&self, other: &Self) -> bool {
        self.reject == other.reject
            && self.promise.borrow().id == other.promise.borrow().id
            && Rc::ptr_eq(&self.already_called, &other.already_called)
    }
}

#[derive(Debug, Clone)]
struct SymbolValue {
    id: usize,
    description: Option<String>,
    registry_key: Option<String>,
}

impl PartialEq for SymbolValue {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}

#[derive(Debug, Clone, PartialEq)]
enum Value {
    String(String),
    StringConstructor,
    Bool(bool),
    Number(i64),
    Float(f64),
    BigInt(JsBigInt),
    Array(Rc<RefCell<Vec<Value>>>),
    Object(Rc<RefCell<Vec<(String, Value)>>>),
    Promise(Rc<RefCell<PromiseValue>>),
    Map(Rc<RefCell<MapValue>>),
    Set(Rc<RefCell<SetValue>>),
    ArrayBuffer(Rc<RefCell<ArrayBufferValue>>),
    TypedArray(Rc<RefCell<TypedArrayValue>>),
    TypedArrayConstructor(TypedArrayConstructorKind),
    ArrayBufferConstructor,
    PromiseConstructor,
    MapConstructor,
    SetConstructor,
    SymbolConstructor,
    RegExpConstructor,
    PromiseCapability(Rc<PromiseCapabilityFunction>),
    Symbol(Rc<SymbolValue>),
    RegExp(Rc<RefCell<RegexValue>>),
    Date(Rc<RefCell<i64>>),
    Null,
    Undefined,
    Node(NodeId),
    NodeList(Vec<NodeId>),
    FormData(Vec<(String, String)>),
    Function(Rc<FunctionValue>),
}

#[derive(Debug, Clone)]
struct RegexValue {
    source: String,
    flags: String,
    global: bool,
    ignore_case: bool,
    multiline: bool,
    dot_all: bool,
    sticky: bool,
    has_indices: bool,
    unicode: bool,
    compiled: Regex,
    last_index: usize,
    properties: Vec<(String, Value)>,
}

impl PartialEq for RegexValue {
    fn eq(&self, other: &Self) -> bool {
        self.source == other.source
            && self.flags == other.flags
            && self.global == other.global
            && self.ignore_case == other.ignore_case
            && self.multiline == other.multiline
            && self.dot_all == other.dot_all
            && self.sticky == other.sticky
            && self.has_indices == other.has_indices
            && self.unicode == other.unicode
            && self.last_index == other.last_index
            && self.properties == other.properties
    }
}

#[derive(Debug, Clone)]
struct FunctionValue {
    handler: ScriptHandler,
    captured_env: HashMap<String, Value>,
    global_scope: bool,
    is_async: bool,
}

impl PartialEq for FunctionValue {
    fn eq(&self, other: &Self) -> bool {
        self.handler == other.handler
            && self.global_scope == other.global_scope
            && self.is_async == other.is_async
    }
}

#[derive(Debug, Clone, Copy)]
struct RegexFlags {
    global: bool,
    ignore_case: bool,
    multiline: bool,
    dot_all: bool,
    sticky: bool,
    has_indices: bool,
    unicode: bool,
}

impl Value {
    fn truthy(&self) -> bool {
        match self {
            Self::Bool(v) => *v,
            Self::String(v) => !v.is_empty(),
            Self::StringConstructor => true,
            Self::Number(v) => *v != 0,
            Self::Float(v) => *v != 0.0,
            Self::BigInt(v) => !v.is_zero(),
            Self::Array(_) => true,
            Self::Object(_) => true,
            Self::Promise(_) => true,
            Self::Map(_) => true,
            Self::Set(_) => true,
            Self::ArrayBuffer(_) => true,
            Self::TypedArray(_) => true,
            Self::TypedArrayConstructor(_) => true,
            Self::ArrayBufferConstructor => true,
            Self::PromiseConstructor => true,
            Self::MapConstructor => true,
            Self::SetConstructor => true,
            Self::SymbolConstructor => true,
            Self::RegExpConstructor => true,
            Self::PromiseCapability(_) => true,
            Self::Symbol(_) => true,
            Self::RegExp(_) => true,
            Self::Date(_) => true,
            Self::Null => false,
            Self::Undefined => false,
            Self::Node(_) => true,
            Self::NodeList(nodes) => !nodes.is_empty(),
            Self::FormData(_) => true,
            Self::Function(_) => true,
        }
    }

    fn as_string(&self) -> String {
        match self {
            Self::String(v) => v.clone(),
            Self::StringConstructor => "String".to_string(),
            Self::Bool(v) => {
                if *v {
                    "true".into()
                } else {
                    "false".into()
                }
            }
            Self::Number(v) => v.to_string(),
            Self::Float(v) => format_float(*v),
            Self::BigInt(v) => v.to_string(),
            Self::Array(values) => {
                let values = values.borrow();
                let mut out = String::new();
                for (idx, value) in values.iter().enumerate() {
                    if idx > 0 {
                        out.push(',');
                    }
                    if matches!(value, Value::Null | Value::Undefined) {
                        continue;
                    }
                    out.push_str(&value.as_string());
                }
                out
            }
            Self::Object(entries) => {
                let entries = entries.borrow();
                match entries.iter().find_map(|(key, value)| {
                    (key == INTERNAL_STRING_WRAPPER_VALUE_KEY).then(|| value)
                }) {
                    Some(Value::String(value)) => value.clone(),
                    _ => "[object Object]".into(),
                }
            }
            Self::Promise(_) => "[object Promise]".into(),
            Self::Map(_) => "[object Map]".into(),
            Self::Set(_) => "[object Set]".into(),
            Self::ArrayBuffer(_) => "[object ArrayBuffer]".into(),
            Self::TypedArray(value) => {
                let value = value.borrow();
                format!("[object {}]", value.kind.name())
            }
            Self::TypedArrayConstructor(kind) => match kind {
                TypedArrayConstructorKind::Concrete(kind) => kind.name().to_string(),
                TypedArrayConstructorKind::Abstract => "TypedArray".to_string(),
            },
            Self::ArrayBufferConstructor => "ArrayBuffer".to_string(),
            Self::PromiseConstructor => "Promise".to_string(),
            Self::MapConstructor => "Map".to_string(),
            Self::SetConstructor => "Set".to_string(),
            Self::SymbolConstructor => "Symbol".to_string(),
            Self::RegExpConstructor => "RegExp".to_string(),
            Self::PromiseCapability(_) => "[object Function]".into(),
            Self::Symbol(value) => {
                if let Some(description) = &value.description {
                    format!("Symbol({description})")
                } else {
                    "Symbol()".to_string()
                }
            }
            Self::RegExp(value) => {
                let value = value.borrow();
                format!("/{}/{}", value.source, value.flags)
            }
            Self::Date(_) => "[object Date]".into(),
            Self::Null => "null".into(),
            Self::Undefined => "undefined".into(),
            Self::Node(node) => format!("node-{}", node.0),
            Self::NodeList(_) => "[object NodeList]".into(),
            Self::FormData(_) => "[object FormData]".into(),
            Self::Function(_) => "[object Function]".into(),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
enum DomProp {
    Value,
    Checked,
    Open,
    ReturnValue,
    ClosedBy,
    Readonly,
    Required,
    Disabled,
    TextContent,
    InnerHtml,
    ClassName,
    Id,
    Name,
    OffsetWidth,
    OffsetHeight,
    OffsetLeft,
    OffsetTop,
    ScrollWidth,
    ScrollHeight,
    ScrollLeft,
    ScrollTop,
    Dataset(String),
    Style(String),
    ActiveElement,
    CharacterSet,
    CompatMode,
    ContentType,
    ReadyState,
    Referrer,
    Title,
    Url,
    DocumentUri,
    Location,
    LocationHref,
    LocationProtocol,
    LocationHost,
    LocationHostname,
    LocationPort,
    LocationPathname,
    LocationSearch,
    LocationHash,
    LocationOrigin,
    LocationAncestorOrigins,
    History,
    HistoryLength,
    HistoryState,
    HistoryScrollRestoration,
    DefaultView,
    Hidden,
    VisibilityState,
    Forms,
    Images,
    Links,
    Scripts,
    Children,
    ChildElementCount,
    FirstElementChild,
    LastElementChild,
    CurrentScript,
    FormsLength,
    ImagesLength,
    LinksLength,
    ScriptsLength,
    ChildrenLength,
}

#[derive(Debug, Clone, PartialEq, Eq)]
enum DomIndex {
    Static(usize),
    Dynamic(String),
}

impl DomIndex {
    fn describe(&self) -> String {
        match self {
            Self::Static(index) => index.to_string(),
            Self::Dynamic(expr) => expr.clone(),
        }
    }

    fn static_index(&self) -> Option<usize> {
        match self {
            Self::Static(index) => Some(*index),
            Self::Dynamic(_) => None,
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
enum DomQuery {
    DocumentRoot,
    DocumentBody,
    DocumentHead,
    DocumentElement,
    ById(String),
    BySelector(String),
    BySelectorAll {
        selector: String,
    },
    BySelectorAllIndex {
        selector: String,
        index: DomIndex,
    },
    QuerySelector {
        target: Box<DomQuery>,
        selector: String,
    },
    QuerySelectorAll {
        target: Box<DomQuery>,
        selector: String,
    },
    Index {
        target: Box<DomQuery>,
        index: DomIndex,
    },
    QuerySelectorAllIndex {
        target: Box<DomQuery>,
        selector: String,
        index: DomIndex,
    },
    FormElementsIndex {
        form: Box<DomQuery>,
        index: DomIndex,
    },
    Var(String),
    VarPath {
        base: String,
        path: Vec<String>,
    },
}

#[derive(Debug, Clone, PartialEq, Eq)]
enum FormDataSource {
    NewForm(DomQuery),
    Var(String),
}

impl DomQuery {
    fn describe_call(&self) -> String {
        match self {
            Self::DocumentRoot => "document".into(),
            Self::DocumentBody => "document.body".into(),
            Self::DocumentHead => "document.head".into(),
            Self::DocumentElement => "document.documentElement".into(),
            Self::ById(id) => format!("document.getElementById('{id}')"),
            Self::BySelector(selector) => format!("document.querySelector('{selector}')"),
            Self::BySelectorAll { selector } => format!("document.querySelectorAll('{selector}')"),
            Self::BySelectorAllIndex { selector, index } => {
                format!(
                    "document.querySelectorAll('{selector}')[{}]",
                    index.describe()
                )
            }
            Self::QuerySelector { target, selector } => {
                format!("{}.querySelector('{selector}')", target.describe_call())
            }
            Self::QuerySelectorAll { target, selector } => {
                format!("{}.querySelectorAll('{selector}')", target.describe_call())
            }
            Self::Index { target, index } => {
                format!("{}[{}]", target.describe_call(), index.describe())
            }
            Self::QuerySelectorAllIndex {
                target,
                selector,
                index,
            } => {
                format!(
                    "{}.querySelectorAll('{selector}')[{}]",
                    target.describe_call(),
                    index.describe()
                )
            }
            Self::FormElementsIndex { form, index } => {
                format!("{}.elements[{}]", form.describe_call(), index.describe())
            }
            Self::Var(name) => name.clone(),
            Self::VarPath { base, path } => format!("{base}.{}", path.join(".")),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum ClassListMethod {
    Add,
    Remove,
    Toggle,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum BinaryOp {
    Or,
    And,
    Nullish,
    Eq,
    Ne,
    StrictEq,
    StrictNe,
    BitOr,
    BitXor,
    BitAnd,
    ShiftLeft,
    ShiftRight,
    UnsignedShiftRight,
    Pow,
    Lt,
    Gt,
    Le,
    Ge,
    In,
    InstanceOf,
    Sub,
    Mul,
    Div,
    Mod,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum VarAssignOp {
    Assign,
    Add,
    Sub,
    Mul,
    Div,
    Pow,
    Mod,
    BitOr,
    BitXor,
    BitAnd,
    ShiftLeft,
    ShiftRight,
    UnsignedShiftRight,
    LogicalAnd,
    LogicalOr,
    Nullish,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum EventExprProp {
    Type,
    Target,
    CurrentTarget,
    TargetName,
    CurrentTargetName,
    DefaultPrevented,
    IsTrusted,
    Bubbles,
    Cancelable,
    TargetId,
    CurrentTargetId,
    EventPhase,
    TimeStamp,
    State,
    OldState,
    NewState,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum MatchMediaProp {
    Matches,
    Media,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum IntlFormatterKind {
    Collator,
    DateTimeFormat,
    DisplayNames,
    DurationFormat,
    ListFormat,
    NumberFormat,
    PluralRules,
    RelativeTimeFormat,
    Segmenter,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum IntlStaticMethod {
    CollatorSupportedLocalesOf,
    DateTimeFormatSupportedLocalesOf,
    DisplayNamesSupportedLocalesOf,
    DurationFormatSupportedLocalesOf,
    ListFormatSupportedLocalesOf,
    PluralRulesSupportedLocalesOf,
    RelativeTimeFormatSupportedLocalesOf,
    SegmenterSupportedLocalesOf,
    GetCanonicalLocales,
    SupportedValuesOf,
}

impl IntlFormatterKind {
    fn storage_name(self) -> &'static str {
        match self {
            Self::Collator => "Collator",
            Self::DateTimeFormat => "DateTimeFormat",
            Self::DisplayNames => "DisplayNames",
            Self::DurationFormat => "DurationFormat",
            Self::ListFormat => "ListFormat",
            Self::NumberFormat => "NumberFormat",
            Self::PluralRules => "PluralRules",
            Self::RelativeTimeFormat => "RelativeTimeFormat",
            Self::Segmenter => "Segmenter",
        }
    }

    fn from_storage_name(value: &str) -> Option<Self> {
        match value {
            "Collator" => Some(Self::Collator),
            "DateTimeFormat" => Some(Self::DateTimeFormat),
            "DisplayNames" => Some(Self::DisplayNames),
            "DurationFormat" => Some(Self::DurationFormat),
            "ListFormat" => Some(Self::ListFormat),
            "NumberFormat" => Some(Self::NumberFormat),
            "PluralRules" => Some(Self::PluralRules),
            "RelativeTimeFormat" => Some(Self::RelativeTimeFormat),
            "Segmenter" => Some(Self::Segmenter),
            _ => None,
        }
    }
}

#[derive(Debug, Clone)]
struct IntlDateTimeOptions {
    calendar: String,
    numbering_system: String,
    time_zone: String,
    date_style: Option<String>,
    time_style: Option<String>,
    weekday: Option<String>,
    year: Option<String>,
    month: Option<String>,
    day: Option<String>,
    hour: Option<String>,
    minute: Option<String>,
    second: Option<String>,
    fractional_second_digits: Option<u8>,
    time_zone_name: Option<String>,
    hour12: Option<bool>,
    day_period: Option<String>,
}

#[derive(Debug, Clone, Copy)]
struct IntlDateTimeComponents {
    year: i64,
    month: u32,
    day: u32,
    hour: u32,
    minute: u32,
    second: u32,
    millisecond: u32,
    weekday: u32,
    offset_minutes: i64,
}

#[derive(Debug, Clone)]
struct IntlPart {
    part_type: String,
    value: String,
}

#[derive(Debug, Clone)]
struct IntlRelativeTimePart {
    part_type: String,
    value: String,
    unit: Option<String>,
}

#[derive(Debug, Clone)]
struct IntlDisplayNamesOptions {
    style: String,
    display_type: String,
    fallback: String,
    language_display: String,
}

#[derive(Debug, Clone)]
struct IntlDurationOptions {
    style: String,
}

#[derive(Debug, Clone)]
struct IntlListOptions {
    style: String,
    list_type: String,
}

#[derive(Debug, Clone)]
struct IntlPluralRulesOptions {
    rule_type: String,
}

#[derive(Debug, Clone)]
struct IntlRelativeTimeOptions {
    style: String,
    numeric: String,
    locale_matcher: String,
}

#[derive(Debug, Clone)]
struct IntlSegmenterOptions {
    granularity: String,
    locale_matcher: String,
}

#[derive(Debug, Clone)]
struct IntlLocaleOptions {
    language: Option<String>,
    script: Option<String>,
    region: Option<String>,
    calendar: Option<String>,
    case_first: Option<String>,
    collation: Option<String>,
    hour_cycle: Option<String>,
    numbering_system: Option<String>,
    numeric: Option<bool>,
}

#[derive(Debug, Clone)]
struct IntlLocaleData {
    language: String,
    script: Option<String>,
    region: Option<String>,
    variants: Vec<String>,
    calendar: Option<String>,
    case_first: Option<String>,
    collation: Option<String>,
    hour_cycle: Option<String>,
    numbering_system: Option<String>,
    numeric: Option<bool>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum IntlLocaleMethod {
    GetCalendars,
    GetCollations,
    GetHourCycles,
    GetNumberingSystems,
    GetTextInfo,
    GetTimeZones,
    GetWeekInfo,
    Maximize,
    Minimize,
    ToString,
}

#[derive(Debug, Clone, PartialEq)]
enum Expr {
    String(String),
    Bool(bool),
    Null,
    Undefined,
    Number(i64),
    Float(f64),
    BigInt(JsBigInt),
    DateNow,
    PerformanceNow,
    DateNew {
        value: Option<Box<Expr>>,
    },
    DateParse(Box<Expr>),
    DateUtc {
        args: Vec<Expr>,
    },
    DateGetTime(String),
    DateSetTime {
        target: String,
        value: Box<Expr>,
    },
    DateToIsoString(String),
    DateGetFullYear(String),
    DateGetMonth(String),
    DateGetDate(String),
    DateGetHours(String),
    DateGetMinutes(String),
    DateGetSeconds(String),
    IntlFormatterConstruct {
        kind: IntlFormatterKind,
        locales: Option<Box<Expr>>,
        options: Option<Box<Expr>>,
        called_with_new: bool,
    },
    IntlFormat {
        formatter: Box<Expr>,
        value: Option<Box<Expr>>,
    },
    IntlFormatGetter {
        formatter: Box<Expr>,
    },
    IntlCollatorCompare {
        collator: Box<Expr>,
        left: Box<Expr>,
        right: Box<Expr>,
    },
    IntlCollatorCompareGetter {
        collator: Box<Expr>,
    },
    IntlDateTimeFormatToParts {
        formatter: Box<Expr>,
        value: Option<Box<Expr>>,
    },
    IntlDateTimeFormatRange {
        formatter: Box<Expr>,
        start: Box<Expr>,
        end: Box<Expr>,
    },
    IntlDateTimeFormatRangeToParts {
        formatter: Box<Expr>,
        start: Box<Expr>,
        end: Box<Expr>,
    },
    IntlDateTimeResolvedOptions {
        formatter: Box<Expr>,
    },
    IntlDisplayNamesOf {
        display_names: Box<Expr>,
        code: Box<Expr>,
    },
    IntlPluralRulesSelect {
        plural_rules: Box<Expr>,
        value: Box<Expr>,
    },
    IntlPluralRulesSelectRange {
        plural_rules: Box<Expr>,
        start: Box<Expr>,
        end: Box<Expr>,
    },
    IntlRelativeTimeFormat {
        formatter: Box<Expr>,
        value: Box<Expr>,
        unit: Box<Expr>,
    },
    IntlRelativeTimeFormatToParts {
        formatter: Box<Expr>,
        value: Box<Expr>,
        unit: Box<Expr>,
    },
    IntlSegmenterSegment {
        segmenter: Box<Expr>,
        value: Box<Expr>,
    },
    IntlStaticMethod {
        method: IntlStaticMethod,
        args: Vec<Expr>,
    },
    IntlConstruct {
        args: Vec<Expr>,
    },
    IntlLocaleConstruct {
        tag: Box<Expr>,
        options: Option<Box<Expr>>,
        called_with_new: bool,
    },
    IntlLocaleMethod {
        locale: Box<Expr>,
        method: IntlLocaleMethod,
    },
    RegexLiteral {
        pattern: String,
        flags: String,
    },
    RegexNew {
        pattern: Box<Expr>,
        flags: Option<Box<Expr>>,
    },
    RegExpConstructor,
    RegExpStaticMethod {
        method: RegExpStaticMethod,
        args: Vec<Expr>,
    },
    RegexTest {
        regex: Box<Expr>,
        input: Box<Expr>,
    },
    RegexExec {
        regex: Box<Expr>,
        input: Box<Expr>,
    },
    RegexToString {
        regex: Box<Expr>,
    },
    MathConst(MathConst),
    MathMethod {
        method: MathMethod,
        args: Vec<Expr>,
    },
    StringConstruct {
        value: Option<Box<Expr>>,
        called_with_new: bool,
    },
    StringStaticMethod {
        method: StringStaticMethod,
        args: Vec<Expr>,
    },
    StringConstructor,
    NumberConstruct {
        value: Option<Box<Expr>>,
    },
    NumberConst(NumberConst),
    NumberMethod {
        method: NumberMethod,
        args: Vec<Expr>,
    },
    NumberInstanceMethod {
        value: Box<Expr>,
        method: NumberInstanceMethod,
        args: Vec<Expr>,
    },
    BigIntConstruct {
        value: Option<Box<Expr>>,
        called_with_new: bool,
    },
    BigIntMethod {
        method: BigIntMethod,
        args: Vec<Expr>,
    },
    BigIntInstanceMethod {
        value: Box<Expr>,
        method: BigIntInstanceMethod,
        args: Vec<Expr>,
    },
    ArrayBufferConstruct {
        byte_length: Option<Box<Expr>>,
        options: Option<Box<Expr>>,
        called_with_new: bool,
    },
    ArrayBufferConstructor,
    ArrayBufferIsView(Box<Expr>),
    ArrayBufferDetached(String),
    ArrayBufferMaxByteLength(String),
    ArrayBufferResizable(String),
    ArrayBufferResize {
        target: String,
        new_byte_length: Box<Expr>,
    },
    ArrayBufferSlice {
        target: String,
        start: Option<Box<Expr>>,
        end: Option<Box<Expr>>,
    },
    ArrayBufferTransfer {
        target: String,
        to_fixed_length: bool,
    },
    TypedArrayConstructorRef(TypedArrayConstructorKind),
    TypedArrayConstruct {
        kind: TypedArrayKind,
        args: Vec<Expr>,
        called_with_new: bool,
    },
    TypedArrayConstructWithCallee {
        callee: Box<Expr>,
        args: Vec<Expr>,
        called_with_new: bool,
    },
    PromiseConstruct {
        executor: Option<Box<Expr>>,
        called_with_new: bool,
    },
    PromiseConstructor,
    PromiseStaticMethod {
        method: PromiseStaticMethod,
        args: Vec<Expr>,
    },
    PromiseMethod {
        target: Box<Expr>,
        method: PromiseInstanceMethod,
        args: Vec<Expr>,
    },
    MapConstruct {
        iterable: Option<Box<Expr>>,
        called_with_new: bool,
    },
    MapConstructor,
    MapStaticMethod {
        method: MapStaticMethod,
        args: Vec<Expr>,
    },
    MapMethod {
        target: String,
        method: MapInstanceMethod,
        args: Vec<Expr>,
    },
    SetConstruct {
        iterable: Option<Box<Expr>>,
        called_with_new: bool,
    },
    SetConstructor,
    SetMethod {
        target: String,
        method: SetInstanceMethod,
        args: Vec<Expr>,
    },
    SymbolConstruct {
        description: Option<Box<Expr>>,
        called_with_new: bool,
    },
    SymbolConstructor,
    SymbolStaticMethod {
        method: SymbolStaticMethod,
        args: Vec<Expr>,
    },
    SymbolStaticProperty(SymbolStaticProperty),
    TypedArrayStaticBytesPerElement(TypedArrayKind),
    TypedArrayStaticMethod {
        kind: TypedArrayKind,
        method: TypedArrayStaticMethod,
        args: Vec<Expr>,
    },
    TypedArrayByteLength(String),
    TypedArrayByteOffset(String),
    TypedArrayBuffer(String),
    TypedArrayBytesPerElement(String),
    TypedArrayMethod {
        target: String,
        method: TypedArrayInstanceMethod,
        args: Vec<Expr>,
    },
    EncodeUri(Box<Expr>),
    EncodeUriComponent(Box<Expr>),
    DecodeUri(Box<Expr>),
    DecodeUriComponent(Box<Expr>),
    Escape(Box<Expr>),
    Unescape(Box<Expr>),
    IsNaN(Box<Expr>),
    IsFinite(Box<Expr>),
    Atob(Box<Expr>),
    Btoa(Box<Expr>),
    ParseInt {
        value: Box<Expr>,
        radix: Option<Box<Expr>>,
    },
    ParseFloat(Box<Expr>),
    JsonParse(Box<Expr>),
    JsonStringify(Box<Expr>),
    ObjectConstruct {
        value: Option<Box<Expr>>,
    },
    ObjectLiteral(Vec<ObjectLiteralEntry>),
    ObjectGet {
        target: String,
        key: String,
    },
    ObjectPathGet {
        target: String,
        path: Vec<String>,
    },
    ObjectGetOwnPropertySymbols(Box<Expr>),
    ObjectKeys(Box<Expr>),
    ObjectValues(Box<Expr>),
    ObjectEntries(Box<Expr>),
    ObjectHasOwn {
        object: Box<Expr>,
        key: Box<Expr>,
    },
    ObjectGetPrototypeOf(Box<Expr>),
    ObjectFreeze(Box<Expr>),
    ObjectHasOwnProperty {
        target: String,
        key: Box<Expr>,
    },
    ArrayLiteral(Vec<Expr>),
    ArrayIsArray(Box<Expr>),
    ArrayFrom {
        source: Box<Expr>,
        map_fn: Option<Box<Expr>>,
    },
    ArrayLength(String),
    ArrayIndex {
        target: String,
        index: Box<Expr>,
    },
    ArrayPush {
        target: String,
        args: Vec<Expr>,
    },
    ArrayPop(String),
    ArrayShift(String),
    ArrayUnshift {
        target: String,
        args: Vec<Expr>,
    },
    ArrayMap {
        target: String,
        callback: ScriptHandler,
    },
    ArrayFilter {
        target: String,
        callback: ScriptHandler,
    },
    ArrayReduce {
        target: String,
        callback: ScriptHandler,
        initial: Option<Box<Expr>>,
    },
    ArrayForEach {
        target: String,
        callback: ScriptHandler,
    },
    ArrayFind {
        target: String,
        callback: ScriptHandler,
    },
    ArraySome {
        target: String,
        callback: ScriptHandler,
    },
    ArrayEvery {
        target: String,
        callback: ScriptHandler,
    },
    ArrayIncludes {
        target: String,
        search: Box<Expr>,
        from_index: Option<Box<Expr>>,
    },
    ArraySlice {
        target: String,
        start: Option<Box<Expr>>,
        end: Option<Box<Expr>>,
    },
    ArraySplice {
        target: String,
        start: Box<Expr>,
        delete_count: Option<Box<Expr>>,
        items: Vec<Expr>,
    },
    ArrayJoin {
        target: String,
        separator: Option<Box<Expr>>,
    },
    ArraySort {
        target: String,
        comparator: Option<Box<Expr>>,
    },
    StringTrim {
        value: Box<Expr>,
        mode: StringTrimMode,
    },
    StringToUpperCase(Box<Expr>),
    StringToLowerCase(Box<Expr>),
    StringIncludes {
        value: Box<Expr>,
        search: Box<Expr>,
        position: Option<Box<Expr>>,
    },
    StringStartsWith {
        value: Box<Expr>,
        search: Box<Expr>,
        position: Option<Box<Expr>>,
    },
    StringEndsWith {
        value: Box<Expr>,
        search: Box<Expr>,
        length: Option<Box<Expr>>,
    },
    StringSlice {
        value: Box<Expr>,
        start: Option<Box<Expr>>,
        end: Option<Box<Expr>>,
    },
    StringSubstring {
        value: Box<Expr>,
        start: Option<Box<Expr>>,
        end: Option<Box<Expr>>,
    },
    StringMatch {
        value: Box<Expr>,
        pattern: Box<Expr>,
    },
    StringSplit {
        value: Box<Expr>,
        separator: Option<Box<Expr>>,
        limit: Option<Box<Expr>>,
    },
    StringReplace {
        value: Box<Expr>,
        from: Box<Expr>,
        to: Box<Expr>,
    },
    StringReplaceAll {
        value: Box<Expr>,
        from: Box<Expr>,
        to: Box<Expr>,
    },
    StringIndexOf {
        value: Box<Expr>,
        search: Box<Expr>,
        position: Option<Box<Expr>>,
    },
    StringLastIndexOf {
        value: Box<Expr>,
        search: Box<Expr>,
        position: Option<Box<Expr>>,
    },
    StringCharAt {
        value: Box<Expr>,
        index: Option<Box<Expr>>,
    },
    StringCharCodeAt {
        value: Box<Expr>,
        index: Option<Box<Expr>>,
    },
    StringCodePointAt {
        value: Box<Expr>,
        index: Option<Box<Expr>>,
    },
    StringAt {
        value: Box<Expr>,
        index: Option<Box<Expr>>,
    },
    StringConcat {
        value: Box<Expr>,
        args: Vec<Expr>,
    },
    StringSearch {
        value: Box<Expr>,
        pattern: Box<Expr>,
    },
    StringRepeat {
        value: Box<Expr>,
        count: Box<Expr>,
    },
    StringPadStart {
        value: Box<Expr>,
        target_length: Box<Expr>,
        pad: Option<Box<Expr>>,
    },
    StringPadEnd {
        value: Box<Expr>,
        target_length: Box<Expr>,
        pad: Option<Box<Expr>>,
    },
    StringLocaleCompare {
        value: Box<Expr>,
        compare: Box<Expr>,
        locales: Option<Box<Expr>>,
        options: Option<Box<Expr>>,
    },
    StringIsWellFormed(Box<Expr>),
    StringToWellFormed(Box<Expr>),
    StringValueOf(Box<Expr>),
    StringToString(Box<Expr>),
    StructuredClone(Box<Expr>),
    Fetch(Box<Expr>),
    MatchMedia(Box<Expr>),
    MatchMediaProp {
        query: Box<Expr>,
        prop: MatchMediaProp,
    },
    Alert(Box<Expr>),
    Confirm(Box<Expr>),
    Prompt {
        message: Box<Expr>,
        default: Option<Box<Expr>>,
    },
    FunctionConstructor {
        args: Vec<Expr>,
    },
    FunctionCall {
        target: String,
        args: Vec<Expr>,
    },
    Var(String),
    DomRef(DomQuery),
    CreateElement(String),
    CreateTextNode(String),
    SetTimeout {
        handler: TimerInvocation,
        delay_ms: Box<Expr>,
    },
    SetInterval {
        handler: TimerInvocation,
        delay_ms: Box<Expr>,
    },
    RequestAnimationFrame {
        callback: TimerCallback,
    },
    Function {
        handler: ScriptHandler,
        is_async: bool,
    },
    QueueMicrotask {
        handler: ScriptHandler,
    },
    Binary {
        left: Box<Expr>,
        op: BinaryOp,
        right: Box<Expr>,
    },
    DomRead {
        target: DomQuery,
        prop: DomProp,
    },
    LocationMethodCall {
        method: LocationMethod,
        url: Option<Box<Expr>>,
    },
    HistoryMethodCall {
        method: HistoryMethod,
        args: Vec<Expr>,
    },
    ClipboardMethodCall {
        method: ClipboardMethod,
        args: Vec<Expr>,
    },
    DocumentHasFocus,
    DomMatches {
        target: DomQuery,
        selector: String,
    },
    DomClosest {
        target: DomQuery,
        selector: String,
    },
    DomComputedStyleProperty {
        target: DomQuery,
        property: String,
    },
    ClassListContains {
        target: DomQuery,
        class_name: String,
    },
    QuerySelectorAllLength {
        target: DomQuery,
    },
    FormElementsLength {
        form: DomQuery,
    },
    FormDataNew {
        form: DomQuery,
    },
    FormDataGet {
        source: FormDataSource,
        name: String,
    },
    FormDataHas {
        source: FormDataSource,
        name: String,
    },
    FormDataGetAll {
        source: FormDataSource,
        name: String,
    },
    FormDataGetAllLength {
        source: FormDataSource,
        name: String,
    },
    DomGetAttribute {
        target: DomQuery,
        name: String,
    },
    DomHasAttribute {
        target: DomQuery,
        name: String,
    },
    EventProp {
        event_var: String,
        prop: EventExprProp,
    },
    Neg(Box<Expr>),
    Pos(Box<Expr>),
    BitNot(Box<Expr>),
    Not(Box<Expr>),
    Void(Box<Expr>),
    Delete(Box<Expr>),
    TypeOf(Box<Expr>),
    Await(Box<Expr>),
    Yield(Box<Expr>),
    YieldStar(Box<Expr>),
    Comma(Vec<Expr>),
    Spread(Box<Expr>),
    Add(Vec<Expr>),
    Ternary {
        cond: Box<Expr>,
        on_true: Box<Expr>,
        on_false: Box<Expr>,
    },
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum EventMethod {
    PreventDefault,
    StopPropagation,
    StopImmediatePropagation,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum StringTrimMode {
    Both,
    Start,
    End,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum StringStaticMethod {
    FromCharCode,
    FromCodePoint,
    Raw,
}

#[derive(Debug, Clone, PartialEq)]
enum ObjectLiteralKey {
    Static(String),
    Computed(Box<Expr>),
}

#[derive(Debug, Clone, PartialEq)]
enum ObjectLiteralEntry {
    Pair(ObjectLiteralKey, Expr),
    Spread(Expr),
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum MathConst {
    E,
    Ln10,
    Ln2,
    Log10E,
    Log2E,
    Pi,
    Sqrt1_2,
    Sqrt2,
    ToStringTag,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum MathMethod {
    Abs,
    Acos,
    Acosh,
    Asin,
    Asinh,
    Atan,
    Atan2,
    Atanh,
    Cbrt,
    Ceil,
    Clz32,
    Cos,
    Cosh,
    Exp,
    Expm1,
    Floor,
    F16Round,
    FRound,
    Hypot,
    Imul,
    Log,
    Log10,
    Log1p,
    Log2,
    Max,
    Min,
    Pow,
    Random,
    Round,
    Sign,
    Sin,
    Sinh,
    Sqrt,
    SumPrecise,
    Tan,
    Tanh,
    Trunc,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum NumberConst {
    Epsilon,
    MaxSafeInteger,
    MaxValue,
    MinSafeInteger,
    MinValue,
    NaN,
    NegativeInfinity,
    PositiveInfinity,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum NumberMethod {
    IsFinite,
    IsInteger,
    IsNaN,
    IsSafeInteger,
    ParseFloat,
    ParseInt,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum NumberInstanceMethod {
    ToExponential,
    ToFixed,
    ToLocaleString,
    ToPrecision,
    ToString,
    ValueOf,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum TypedArrayStaticMethod {
    From,
    Of,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum TypedArrayInstanceMethod {
    At,
    CopyWithin,
    Entries,
    Fill,
    FindIndex,
    FindLast,
    FindLastIndex,
    IndexOf,
    Keys,
    LastIndexOf,
    ReduceRight,
    Reverse,
    Set,
    Sort,
    Subarray,
    ToReversed,
    ToSorted,
    Values,
    With,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum MapStaticMethod {
    GroupBy,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum SymbolStaticMethod {
    For,
    KeyFor,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum SymbolStaticProperty {
    AsyncDispose,
    AsyncIterator,
    Dispose,
    HasInstance,
    IsConcatSpreadable,
    Iterator,
    Match,
    MatchAll,
    Replace,
    Search,
    Species,
    Split,
    ToPrimitive,
    ToStringTag,
    Unscopables,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum RegExpStaticMethod {
    Escape,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum PromiseStaticMethod {
    Resolve,
    Reject,
    All,
    AllSettled,
    Any,
    Race,
    Try,
    WithResolvers,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum MapInstanceMethod {
    Get,
    Has,
    Delete,
    Clear,
    ForEach,
    GetOrInsert,
    GetOrInsertComputed,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum PromiseInstanceMethod {
    Then,
    Catch,
    Finally,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum SetInstanceMethod {
    Add,
    Union,
    Intersection,
    Difference,
    SymmetricDifference,
    IsDisjointFrom,
    IsSubsetOf,
    IsSupersetOf,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum BigIntMethod {
    AsIntN,
    AsUintN,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum BigIntInstanceMethod {
    ToLocaleString,
    ToString,
    ValueOf,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum NodeTreeMethod {
    After,
    Append,
    AppendChild,
    Before,
    ReplaceWith,
    Prepend,
    RemoveChild,
    InsertBefore,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum InsertAdjacentPosition {
    BeforeBegin,
    AfterBegin,
    BeforeEnd,
    AfterEnd,
}

#[derive(Debug, Clone, PartialEq)]
enum Stmt {
    VarDecl {
        name: String,
        expr: Expr,
    },
    FunctionDecl {
        name: String,
        handler: ScriptHandler,
        is_async: bool,
    },
    VarAssign {
        name: String,
        op: VarAssignOp,
        expr: Expr,
    },
    VarUpdate {
        name: String,
        delta: i8,
    },
    ArrayDestructureAssign {
        targets: Vec<Option<String>>,
        expr: Expr,
    },
    ObjectDestructureAssign {
        bindings: Vec<(String, String)>,
        expr: Expr,
    },
    ObjectAssign {
        target: String,
        key: Expr,
        expr: Expr,
    },
    FormDataAppend {
        target_var: String,
        name: Expr,
        value: Expr,
    },
    DomAssign {
        target: DomQuery,
        prop: DomProp,
        expr: Expr,
    },
    ClassListCall {
        target: DomQuery,
        method: ClassListMethod,
        class_names: Vec<String>,
        force: Option<Expr>,
    },
    ClassListForEach {
        target: DomQuery,
        item_var: String,
        index_var: Option<String>,
        body: Vec<Stmt>,
    },
    DomSetAttribute {
        target: DomQuery,
        name: String,
        value: Expr,
    },
    DomRemoveAttribute {
        target: DomQuery,
        name: String,
    },
    NodeTreeMutation {
        target: DomQuery,
        method: NodeTreeMethod,
        child: Expr,
        reference: Option<Expr>,
    },
    InsertAdjacentElement {
        target: DomQuery,
        position: InsertAdjacentPosition,
        node: Expr,
    },
    InsertAdjacentText {
        target: DomQuery,
        position: InsertAdjacentPosition,
        text: Expr,
    },
    InsertAdjacentHTML {
        target: DomQuery,
        position: Expr,
        html: Expr,
    },
    SetTimeout {
        handler: TimerInvocation,
        delay_ms: Expr,
    },
    SetInterval {
        handler: TimerInvocation,
        delay_ms: Expr,
    },
    QueueMicrotask {
        handler: ScriptHandler,
    },
    ClearTimeout {
        timer_id: Expr,
    },
    NodeRemove {
        target: DomQuery,
    },
    ForEach {
        target: Option<DomQuery>,
        selector: String,
        item_var: String,
        index_var: Option<String>,
        body: Vec<Stmt>,
    },
    ArrayForEach {
        target: String,
        callback: ScriptHandler,
    },
    For {
        init: Option<Box<Stmt>>,
        cond: Option<Expr>,
        post: Option<Box<Stmt>>,
        body: Vec<Stmt>,
    },
    ForIn {
        item_var: String,
        iterable: Expr,
        body: Vec<Stmt>,
    },
    ForOf {
        item_var: String,
        iterable: Expr,
        body: Vec<Stmt>,
    },
    DoWhile {
        cond: Expr,
        body: Vec<Stmt>,
    },
    Break,
    Continue,
    While {
        cond: Expr,
        body: Vec<Stmt>,
    },
    Try {
        try_stmts: Vec<Stmt>,
        catch_binding: Option<CatchBinding>,
        catch_stmts: Option<Vec<Stmt>>,
        finally_stmts: Option<Vec<Stmt>>,
    },
    Throw {
        value: Expr,
    },
    Return {
        value: Option<Expr>,
    },
    If {
        cond: Expr,
        then_stmts: Vec<Stmt>,
        else_stmts: Vec<Stmt>,
    },
    EventCall {
        event_var: String,
        method: EventMethod,
    },
    ListenerMutation {
        target: DomQuery,
        op: ListenerRegistrationOp,
        event_type: String,
        capture: bool,
        handler: ScriptHandler,
    },
    DispatchEvent {
        target: DomQuery,
        event_type: Expr,
    },
    DomMethodCall {
        target: DomQuery,
        method: DomMethod,
        arg: Option<Expr>,
    },
    Expr(Expr),
}

#[derive(Debug, Clone, PartialEq)]
enum CatchBinding {
    Identifier(String),
    ArrayPattern(Vec<Option<String>>),
    ObjectPattern(Vec<(String, String)>),
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum ExecFlow {
    Continue,
    Break,
    ContinueLoop,
    Return,
}

#[derive(Debug, Clone, PartialEq, Eq)]
enum DomMethod {
    Focus,
    Blur,
    Click,
    ScrollIntoView,
    Submit,
    Reset,
    Show,
    ShowModal,
    Close,
    RequestClose,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum LocationMethod {
    Assign,
    Reload,
    Replace,
    ToString,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum HistoryMethod {
    Back,
    Forward,
    Go,
    PushState,
    ReplaceState,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum ClipboardMethod {
    ReadText,
    WriteText,
}

#[derive(Debug, Clone, PartialEq)]
struct ScriptHandler {
    params: Vec<FunctionParam>,
    stmts: Vec<Stmt>,
}

#[derive(Debug, Clone, PartialEq)]
struct FunctionParam {
    name: String,
    default: Option<Expr>,
}

impl ScriptHandler {
    fn first_event_param(&self) -> Option<&str> {
        self.params.first().map(|param| param.name.as_str())
    }
}

#[derive(Debug, Clone, PartialEq)]
enum TimerCallback {
    Inline(ScriptHandler),
    Reference(String),
}

#[derive(Debug, Clone, PartialEq)]
struct TimerInvocation {
    callback: TimerCallback,
    args: Vec<Expr>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct LocationParts {
    scheme: String,
    has_authority: bool,
    hostname: String,
    port: String,
    pathname: String,
    opaque_path: String,
    search: String,
    hash: String,
}

impl LocationParts {
    fn protocol(&self) -> String {
        format!("{}:", self.scheme)
    }

    fn host(&self) -> String {
        if self.port.is_empty() {
            self.hostname.clone()
        } else {
            format!("{}:{}", self.hostname, self.port)
        }
    }

    fn origin(&self) -> String {
        if self.has_authority && !self.hostname.is_empty() {
            format!("{}//{}", self.protocol(), self.host())
        } else {
            "null".to_string()
        }
    }

    fn href(&self) -> String {
        if self.has_authority {
            let path = if self.pathname.is_empty() {
                "/".to_string()
            } else {
                self.pathname.clone()
            };
            format!(
                "{}//{}{}{}{}",
                self.protocol(),
                self.host(),
                path,
                self.search,
                self.hash
            )
        } else {
            format!(
                "{}{}{}{}",
                self.protocol(),
                self.opaque_path,
                self.search,
                self.hash
            )
        }
    }

    fn parse(input: &str) -> Option<Self> {
        let trimmed = input.trim();
        let scheme_end = trimmed.find(':')?;
        let scheme = trimmed[..scheme_end].to_ascii_lowercase();
        if !is_valid_url_scheme(&scheme) {
            return None;
        }
        let rest = &trimmed[scheme_end + 1..];
        if let Some(without_slashes) = rest.strip_prefix("//") {
            let authority_end = without_slashes
                .find(|ch| ['/', '?', '#'].contains(&ch))
                .unwrap_or(without_slashes.len());
            let authority = &without_slashes[..authority_end];
            let tail = &without_slashes[authority_end..];
            let (hostname, port) = split_hostname_and_port(authority);
            let (pathname, search, hash) = split_path_search_hash(tail);
            let pathname = if pathname.is_empty() {
                "/".to_string()
            } else {
                normalize_pathname(&pathname)
            };
            Some(Self {
                scheme,
                has_authority: true,
                hostname,
                port,
                pathname,
                opaque_path: String::new(),
                search,
                hash,
            })
        } else {
            let (opaque_path, search, hash) = split_opaque_search_hash(rest);
            Some(Self {
                scheme,
                has_authority: false,
                hostname: String::new(),
                port: String::new(),
                pathname: String::new(),
                opaque_path,
                search,
                hash,
            })
        }
    }
}

fn is_valid_url_scheme(scheme: &str) -> bool {
    let mut chars = scheme.chars();
    let Some(first) = chars.next() else {
        return false;
    };
    if !first.is_ascii_alphabetic() {
        return false;
    }
    chars.all(|ch| ch.is_ascii_alphanumeric() || matches!(ch, '+' | '-' | '.'))
}

fn split_hostname_and_port(authority: &str) -> (String, String) {
    if authority.is_empty() {
        return (String::new(), String::new());
    }

    if let Some(rest) = authority.strip_prefix('[') {
        if let Some(end_idx) = rest.find(']') {
            let hostname = authority[..end_idx + 2].to_string();
            let suffix = &authority[end_idx + 2..];
            if let Some(port) = suffix.strip_prefix(':') {
                return (hostname, port.to_string());
            }
            return (hostname, String::new());
        }
    }

    if let Some(idx) = authority.rfind(':') {
        let hostname = &authority[..idx];
        let port = &authority[idx + 1..];
        if !hostname.contains(':') {
            return (hostname.to_string(), port.to_string());
        }
    }
    (authority.to_string(), String::new())
}

fn split_path_search_hash(tail: &str) -> (String, String, String) {
    let mut pathname = tail;
    let mut search = "";
    let mut hash = "";

    if let Some(hash_pos) = tail.find('#') {
        pathname = &tail[..hash_pos];
        hash = &tail[hash_pos..];
    }

    if let Some(search_pos) = pathname.find('?') {
        search = &pathname[search_pos..];
        pathname = &pathname[..search_pos];
    }

    (pathname.to_string(), search.to_string(), hash.to_string())
}

fn split_opaque_search_hash(rest: &str) -> (String, String, String) {
    let mut opaque_path = rest;
    let mut search = "";
    let mut hash = "";

    if let Some(hash_pos) = rest.find('#') {
        opaque_path = &rest[..hash_pos];
        hash = &rest[hash_pos..];
    }

    if let Some(search_pos) = opaque_path.find('?') {
        search = &opaque_path[search_pos..];
        opaque_path = &opaque_path[..search_pos];
    }

    (
        opaque_path.to_string(),
        search.to_string(),
        hash.to_string(),
    )
}

fn normalize_pathname(pathname: &str) -> String {
    let starts_with_slash = pathname.starts_with('/');
    let ends_with_slash = pathname.ends_with('/') && pathname.len() > 1;
    let mut parts = Vec::new();
    for segment in pathname.split('/') {
        if segment.is_empty() || segment == "." {
            continue;
        }
        if segment == ".." {
            parts.pop();
            continue;
        }
        parts.push(segment);
    }
    let mut out = if starts_with_slash {
        format!("/{}", parts.join("/"))
    } else {
        parts.join("/")
    };
    if out.is_empty() {
        out.push('/');
    }
    if ends_with_slash && !out.ends_with('/') {
        out.push('/');
    }
    out
}

fn ensure_search_prefix(value: &str) -> String {
    if value.is_empty() {
        String::new()
    } else if value.starts_with('?') {
        value.to_string()
    } else {
        format!("?{value}")
    }
}

fn ensure_hash_prefix(value: &str) -> String {
    if value.is_empty() {
        String::new()
    } else if value.starts_with('#') {
        value.to_string()
    } else {
        format!("#{value}")
    }
}

#[derive(Debug, Clone)]
struct Listener {
    capture: bool,
    handler: ScriptHandler,
}

#[derive(Debug, Default, Clone)]
struct ListenerStore {
    map: HashMap<NodeId, HashMap<String, Vec<Listener>>>,
}

impl ListenerStore {
    fn add(&mut self, node_id: NodeId, event: String, listener: Listener) {
        self.map
            .entry(node_id)
            .or_default()
            .entry(event)
            .or_default()
            .push(listener);
    }

    fn remove(
        &mut self,
        node_id: NodeId,
        event: &str,
        capture: bool,
        handler: &ScriptHandler,
    ) -> bool {
        let Some(events) = self.map.get_mut(&node_id) else {
            return false;
        };
        let Some(listeners) = events.get_mut(event) else {
            return false;
        };

        if let Some(pos) = listeners
            .iter()
            .position(|listener| listener.capture == capture && listener.handler == *handler)
        {
            listeners.remove(pos);
            if listeners.is_empty() {
                events.remove(event);
            }
            if events.is_empty() {
                self.map.remove(&node_id);
            }
            return true;
        }

        false
    }

    fn get(&self, node_id: NodeId, event: &str, capture: bool) -> Vec<Listener> {
        self.map
            .get(&node_id)
            .and_then(|events| events.get(event))
            .map(|listeners| {
                listeners
                    .iter()
                    .filter(|listener| listener.capture == capture)
                    .cloned()
                    .collect()
            })
            .unwrap_or_default()
    }
}

#[derive(Debug, Clone)]
struct EventState {
    event_type: String,
    target: NodeId,
    current_target: NodeId,
    event_phase: i32,
    time_stamp_ms: i64,
    default_prevented: bool,
    is_trusted: bool,
    bubbles: bool,
    cancelable: bool,
    state: Option<Value>,
    old_state: Option<String>,
    new_state: Option<String>,
    propagation_stopped: bool,
    immediate_propagation_stopped: bool,
}

impl EventState {
    fn new(event_type: &str, target: NodeId, time_stamp_ms: i64) -> Self {
        Self {
            event_type: event_type.to_string(),
            target,
            current_target: target,
            event_phase: 2,
            time_stamp_ms,
            default_prevented: false,
            is_trusted: true,
            bubbles: true,
            cancelable: true,
            state: None,
            old_state: None,
            new_state: None,
            propagation_stopped: false,
            immediate_propagation_stopped: false,
        }
    }

    fn new_untrusted(event_type: &str, target: NodeId, time_stamp_ms: i64) -> Self {
        let mut event = Self::new(event_type, target, time_stamp_ms);
        event.is_trusted = false;
        event.bubbles = false;
        event.cancelable = false;
        event
    }
}

#[derive(Debug, Clone)]
struct ParseOutput {
    dom: Dom,
    scripts: Vec<String>,
}

#[derive(Debug, Clone)]
struct ScheduledTask {
    id: i64,
    due_at: i64,
    order: i64,
    interval_ms: Option<i64>,
    callback: TimerCallback,
    callback_args: Vec<Value>,
    env: HashMap<String, Value>,
}

#[derive(Debug, Clone)]
enum ScheduledMicrotask {
    Script {
        handler: ScriptHandler,
        env: HashMap<String, Value>,
    },
    Promise {
        reaction: PromiseReactionKind,
        settled: PromiseSettledValue,
    },
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct PendingTimer {
    pub id: i64,
    pub due_at: i64,
    pub order: i64,
    pub interval_ms: Option<i64>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum LocationNavigationKind {
    Assign,
    Replace,
    HrefSet,
    Reload,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct LocationNavigation {
    pub kind: LocationNavigationKind,
    pub from: String,
    pub to: String,
}

#[derive(Debug, Clone, PartialEq)]
struct HistoryEntry {
    url: String,
    state: Value,
}

#[derive(Debug)]
pub struct Harness {
    dom: Dom,
    listeners: ListenerStore,
    script_env: HashMap<String, Value>,
    document_url: String,
    window_object: Rc<RefCell<Vec<(String, Value)>>>,
    document_object: Rc<RefCell<Vec<(String, Value)>>>,
    location_object: Rc<RefCell<Vec<(String, Value)>>>,
    history_object: Rc<RefCell<Vec<(String, Value)>>>,
    history_entries: Vec<HistoryEntry>,
    history_index: usize,
    history_scroll_restoration: String,
    location_mock_pages: HashMap<String, String>,
    location_navigations: Vec<LocationNavigation>,
    location_reload_count: usize,
    task_queue: Vec<ScheduledTask>,
    microtask_queue: VecDeque<ScheduledMicrotask>,
    dialog_return_values: HashMap<NodeId, String>,
    active_element: Option<NodeId>,
    now_ms: i64,
    timer_step_limit: usize,
    next_timer_id: i64,
    next_task_order: i64,
    next_promise_id: usize,
    next_symbol_id: usize,
    task_depth: usize,
    running_timer_id: Option<i64>,
    running_timer_canceled: bool,
    rng_state: u64,
    clipboard_text: String,
    fetch_mocks: HashMap<String, String>,
    fetch_calls: Vec<String>,
    match_media_mocks: HashMap<String, bool>,
    match_media_calls: Vec<String>,
    default_match_media_matches: bool,
    alert_messages: Vec<String>,
    confirm_responses: VecDeque<bool>,
    default_confirm_response: bool,
    prompt_responses: VecDeque<Option<String>>,
    default_prompt_response: Option<String>,
    symbol_registry: HashMap<String, Rc<SymbolValue>>,
    symbols_by_id: HashMap<usize, Rc<SymbolValue>>,
    well_known_symbols: HashMap<String, Rc<SymbolValue>>,
    trace: bool,
    trace_events: bool,
    trace_timers: bool,
    trace_logs: Vec<String>,
    trace_log_limit: usize,
    trace_to_stderr: bool,
}

#[derive(Debug)]
pub struct MockWindow {
    pages: Vec<MockPage>,
    current: usize,
}

#[derive(Debug)]
pub struct MockPage {
    pub url: String,
    harness: Harness,
}

impl MockWindow {
    pub fn new() -> Self {
        Self {
            pages: Vec::new(),
            current: 0,
        }
    }

    pub fn open_page(&mut self, url: &str, html: &str) -> Result<usize> {
        let mut harness = Harness::from_html(html)?;
        harness.document_url = url.to_string();
        if let Some(index) = self
            .pages
            .iter()
            .position(|page| page.url.eq_ignore_ascii_case(url))
        {
            self.pages[index] = MockPage {
                url: url.to_string(),
                harness,
            };
            self.current = index;
            Ok(index)
        } else {
            self.pages.push(MockPage {
                url: url.to_string(),
                harness,
            });
            self.current = self.pages.len() - 1;
            Ok(self.current)
        }
    }

    pub fn page_count(&self) -> usize {
        self.pages.len()
    }

    pub fn switch_to(&mut self, url: &str) -> Result<()> {
        let index = self
            .pages
            .iter()
            .position(|page| page.url == url)
            .ok_or_else(|| Error::ScriptRuntime(format!("unknown page: {url}")))?;
        self.current = index;
        Ok(())
    }

    pub fn switch_to_index(&mut self, index: usize) -> Result<()> {
        if index >= self.pages.len() {
            return Err(Error::ScriptRuntime(format!(
                "page index out of range: {index}"
            )));
        }
        self.current = index;
        Ok(())
    }

    pub fn current_url(&self) -> Result<&str> {
        self.pages
            .get(self.current)
            .map(|page| page.url.as_str())
            .ok_or_else(|| Error::ScriptRuntime("window has no pages".into()))
    }

    pub fn current_document_mut(&mut self) -> Result<&mut Harness> {
        self.pages
            .get_mut(self.current)
            .map(|page| &mut page.harness)
            .ok_or_else(|| Error::ScriptRuntime("window has no pages".into()))
    }

    pub fn current_document(&self) -> Result<&Harness> {
        self.pages
            .get(self.current)
            .map(|page| &page.harness)
            .ok_or_else(|| Error::ScriptRuntime("window has no pages".into()))
    }

    pub fn with_current_document<R>(
        &mut self,
        f: impl FnOnce(&mut Harness) -> Result<R>,
    ) -> Result<R> {
        let harness = self.current_document_mut()?;
        f(harness)
    }

    pub fn type_text(&mut self, selector: &str, text: &str) -> Result<()> {
        let page = self.current_document_mut()?;
        page.type_text(selector, text)
    }

    pub fn set_checked(&mut self, selector: &str, checked: bool) -> Result<()> {
        let page = self.current_document_mut()?;
        page.set_checked(selector, checked)
    }

    pub fn click(&mut self, selector: &str) -> Result<()> {
        let page = self.current_document_mut()?;
        page.click(selector)
    }

    pub fn submit(&mut self, selector: &str) -> Result<()> {
        let page = self.current_document_mut()?;
        page.submit(selector)
    }

    pub fn dispatch(&mut self, selector: &str, event: &str) -> Result<()> {
        let page = self.current_document_mut()?;
        page.dispatch(selector, event)
    }

    pub fn assert_text(&mut self, selector: &str, expected: &str) -> Result<()> {
        let page = self.current_document_mut()?;
        page.assert_text(selector, expected)
    }

    pub fn assert_value(&mut self, selector: &str, expected: &str) -> Result<()> {
        let page = self.current_document_mut()?;
        page.assert_value(selector, expected)
    }

    pub fn assert_checked(&mut self, selector: &str, expected: bool) -> Result<()> {
        let page = self.current_document_mut()?;
        page.assert_checked(selector, expected)
    }

    pub fn assert_exists(&mut self, selector: &str) -> Result<()> {
        let page = self.current_document_mut()?;
        page.assert_exists(selector)
    }

    pub fn take_trace_logs(&mut self) -> Result<Vec<String>> {
        let page = self.current_document_mut()?;
        Ok(page.take_trace_logs())
    }
}

impl MockPage {
    pub fn url(&self) -> &str {
        self.url.as_str()
    }

    pub fn harness(&self) -> &Harness {
        &self.harness
    }

    pub fn harness_mut(&mut self) -> &mut Harness {
        &mut self.harness
    }
}

impl Harness {
    pub fn from_html(html: &str) -> Result<Self> {
        let ParseOutput { dom, scripts } = parse_html(html)?;
        let mut harness = Self {
            dom,
            listeners: ListenerStore::default(),
            script_env: HashMap::new(),
            document_url: "about:blank".to_string(),
            window_object: Rc::new(RefCell::new(Vec::new())),
            document_object: Rc::new(RefCell::new(Vec::new())),
            location_object: Rc::new(RefCell::new(Vec::new())),
            history_object: Rc::new(RefCell::new(Vec::new())),
            history_entries: vec![HistoryEntry {
                url: "about:blank".to_string(),
                state: Value::Null,
            }],
            history_index: 0,
            history_scroll_restoration: "auto".to_string(),
            location_mock_pages: HashMap::new(),
            location_navigations: Vec::new(),
            location_reload_count: 0,
            task_queue: Vec::new(),
            microtask_queue: VecDeque::new(),
            dialog_return_values: HashMap::new(),
            active_element: None,
            now_ms: 0,
            timer_step_limit: 10_000,
            next_timer_id: 1,
            next_task_order: 0,
            next_promise_id: 1,
            next_symbol_id: 1,
            task_depth: 0,
            running_timer_id: None,
            running_timer_canceled: false,
            rng_state: 0x9E37_79B9_7F4A_7C15,
            clipboard_text: String::new(),
            fetch_mocks: HashMap::new(),
            fetch_calls: Vec::new(),
            match_media_mocks: HashMap::new(),
            match_media_calls: Vec::new(),
            default_match_media_matches: false,
            alert_messages: Vec::new(),
            confirm_responses: VecDeque::new(),
            default_confirm_response: false,
            prompt_responses: VecDeque::new(),
            default_prompt_response: None,
            symbol_registry: HashMap::new(),
            symbols_by_id: HashMap::new(),
            well_known_symbols: HashMap::new(),
            trace: false,
            trace_events: true,
            trace_timers: true,
            trace_logs: Vec::new(),
            trace_log_limit: 10_000,
            trace_to_stderr: true,
        };

        harness.initialize_global_bindings();

        for script in scripts {
            harness.compile_and_register_script(&script)?;
        }

        Ok(harness)
    }

    fn initialize_global_bindings(&mut self) {
        self.sync_location_object();
        self.sync_history_object();
        self.window_object = Rc::new(RefCell::new(Vec::new()));
        self.document_object = Rc::new(RefCell::new(Vec::new()));
        let clipboard = Self::new_object_value(vec![
            (INTERNAL_CLIPBOARD_OBJECT_KEY.into(), Value::Bool(true)),
            ("readText".into(), Self::new_builtin_placeholder_function()),
            ("writeText".into(), Self::new_builtin_placeholder_function()),
        ]);
        let location = Value::Object(self.location_object.clone());
        let history = Value::Object(self.history_object.clone());

        let navigator = Self::new_object_value(vec![
            (INTERNAL_NAVIGATOR_OBJECT_KEY.into(), Value::Bool(true)),
            ("language".into(), Value::String(DEFAULT_LOCALE.to_string())),
            (
                "languages".into(),
                Self::new_array_value(vec![
                    Value::String(DEFAULT_LOCALE.to_string()),
                    Value::String("en".to_string()),
                ]),
            ),
            ("clipboard".into(), clipboard),
        ]);

        let mut intl_entries = vec![
            ("Collator".into(), Self::new_builtin_placeholder_function()),
            (
                "DateTimeFormat".into(),
                Self::new_builtin_placeholder_function(),
            ),
            (
                "DisplayNames".into(),
                Self::new_builtin_placeholder_function(),
            ),
            (
                "DurationFormat".into(),
                Self::new_builtin_placeholder_function(),
            ),
            (
                "ListFormat".into(),
                Self::new_builtin_placeholder_function(),
            ),
            ("Locale".into(), Self::new_builtin_placeholder_function()),
            (
                "NumberFormat".into(),
                Self::new_builtin_placeholder_function(),
            ),
            (
                "PluralRules".into(),
                Self::new_builtin_placeholder_function(),
            ),
            (
                "RelativeTimeFormat".into(),
                Self::new_builtin_placeholder_function(),
            ),
            ("Segmenter".into(), Self::new_builtin_placeholder_function()),
            (
                "getCanonicalLocales".into(),
                Self::new_builtin_placeholder_function(),
            ),
            (
                "supportedValuesOf".into(),
                Self::new_builtin_placeholder_function(),
            ),
        ];
        let to_string_tag = self.eval_symbol_static_property(SymbolStaticProperty::ToStringTag);
        let to_string_tag_key = self.property_key_to_storage_key(&to_string_tag);
        Self::object_set_entry(
            &mut intl_entries,
            to_string_tag_key,
            Value::String("Intl".to_string()),
        );
        let intl = Self::new_object_value(intl_entries);

        self.sync_document_object();
        self.sync_window_object(&navigator, &intl);

        let window = Value::Object(self.window_object.clone());
        let document = Value::Object(self.document_object.clone());

        self.script_env.insert("document".to_string(), document);
        self.script_env
            .insert("navigator".to_string(), navigator.clone());
        self.script_env
            .insert("clientInformation".to_string(), navigator.clone());
        self.script_env.insert("Intl".to_string(), intl);
        self.script_env
            .insert("String".to_string(), Value::StringConstructor);
        self.script_env.insert("location".to_string(), location);
        self.script_env.insert("history".to_string(), history);
        self.script_env.insert("window".to_string(), window.clone());
        self.script_env.insert("self".to_string(), window.clone());
        self.script_env.insert("top".to_string(), window.clone());
        self.script_env.insert("parent".to_string(), window.clone());
        self.script_env.insert("frames".to_string(), window);
    }

    fn current_location_parts(&self) -> LocationParts {
        LocationParts::parse(&self.document_url).unwrap_or_else(|| LocationParts {
            scheme: "about".to_string(),
            has_authority: false,
            hostname: String::new(),
            port: String::new(),
            pathname: String::new(),
            opaque_path: "blank".to_string(),
            search: String::new(),
            hash: String::new(),
        })
    }

    fn window_is_secure_context(&self) -> bool {
        matches!(
            self.current_location_parts().scheme.as_str(),
            "https" | "wss"
        )
    }

    fn document_builtin_keys() -> &'static [&'static str] {
        &["defaultView", "location", "URL", "documentURI"]
    }

    fn sync_document_object(&mut self) {
        let mut extras = Vec::new();
        {
            let entries = self.document_object.borrow();
            for (key, value) in entries.iter() {
                if Self::is_internal_object_key(key) {
                    continue;
                }
                if Self::document_builtin_keys()
                    .iter()
                    .any(|builtin| builtin == key)
                {
                    continue;
                }
                extras.push((key.clone(), value.clone()));
            }
        }

        let mut entries = vec![
            (INTERNAL_DOCUMENT_OBJECT_KEY.to_string(), Value::Bool(true)),
            (
                "defaultView".to_string(),
                Value::Object(self.window_object.clone()),
            ),
            (
                "location".to_string(),
                Value::Object(self.location_object.clone()),
            ),
            ("URL".to_string(), Value::String(self.document_url.clone())),
            (
                "documentURI".to_string(),
                Value::String(self.document_url.clone()),
            ),
        ];
        entries.extend(extras);
        *self.document_object.borrow_mut() = entries;
    }

    fn window_builtin_keys() -> &'static [&'static str] {
        &[
            "window",
            "self",
            "top",
            "parent",
            "frames",
            "length",
            "closed",
            "location",
            "history",
            "navigator",
            "clientInformation",
            "document",
            "origin",
            "isSecureContext",
            "Intl",
            "String",
            "name",
        ]
    }

    fn sync_window_object(&mut self, navigator: &Value, intl: &Value) {
        let mut extras = Vec::new();
        let mut name_value = Value::String(String::new());
        {
            let entries = self.window_object.borrow();
            for (key, value) in entries.iter() {
                if Self::is_internal_object_key(key) {
                    continue;
                }
                if key == "name" {
                    name_value = Value::String(value.as_string());
                    continue;
                }
                if Self::window_builtin_keys()
                    .iter()
                    .any(|builtin| builtin == key)
                {
                    continue;
                }
                extras.push((key.clone(), value.clone()));
            }
        }

        let window_ref = Value::Object(self.window_object.clone());
        let mut entries = vec![
            (INTERNAL_WINDOW_OBJECT_KEY.to_string(), Value::Bool(true)),
            ("window".to_string(), window_ref.clone()),
            ("self".to_string(), window_ref.clone()),
            ("top".to_string(), window_ref.clone()),
            ("parent".to_string(), window_ref.clone()),
            ("frames".to_string(), window_ref),
            ("length".to_string(), Value::Number(0)),
            ("closed".to_string(), Value::Bool(false)),
            (
                "location".to_string(),
                Value::Object(self.location_object.clone()),
            ),
            (
                "history".to_string(),
                Value::Object(self.history_object.clone()),
            ),
            ("navigator".to_string(), navigator.clone()),
            ("clientInformation".to_string(), navigator.clone()),
            (
                "document".to_string(),
                Value::Object(self.document_object.clone()),
            ),
            (
                "origin".to_string(),
                Value::String(self.current_location_parts().origin()),
            ),
            (
                "isSecureContext".to_string(),
                Value::Bool(self.window_is_secure_context()),
            ),
            ("Intl".to_string(), intl.clone()),
            ("String".to_string(), Value::StringConstructor),
            ("name".to_string(), name_value),
        ];
        entries.extend(extras);
        *self.window_object.borrow_mut() = entries;
    }

    fn sync_window_runtime_properties(&mut self) {
        let mut entries = self.window_object.borrow_mut();
        Self::object_set_entry(
            &mut entries,
            "origin".to_string(),
            Value::String(self.current_location_parts().origin()),
        );
        Self::object_set_entry(
            &mut entries,
            "isSecureContext".to_string(),
            Value::Bool(self.window_is_secure_context()),
        );
    }

    fn location_builtin_keys() -> &'static [&'static str] {
        &[
            "href",
            "protocol",
            "host",
            "hostname",
            "port",
            "pathname",
            "search",
            "hash",
            "origin",
            "ancestorOrigins",
            "assign",
            "reload",
            "replace",
            "toString",
        ]
    }

    fn sync_location_object(&mut self) {
        let mut extras = Vec::new();
        {
            let entries = self.location_object.borrow();
            for (key, value) in entries.iter() {
                if Self::is_internal_object_key(key) {
                    continue;
                }
                if Self::location_builtin_keys()
                    .iter()
                    .any(|builtin| builtin == key)
                {
                    continue;
                }
                extras.push((key.clone(), value.clone()));
            }
        }

        let parts = self.current_location_parts();
        let mut entries = vec![
            (INTERNAL_LOCATION_OBJECT_KEY.to_string(), Value::Bool(true)),
            (
                INTERNAL_STRING_WRAPPER_VALUE_KEY.to_string(),
                Value::String(parts.href()),
            ),
            ("href".to_string(), Value::String(parts.href())),
            ("protocol".to_string(), Value::String(parts.protocol())),
            ("host".to_string(), Value::String(parts.host())),
            (
                "hostname".to_string(),
                Value::String(parts.hostname.clone()),
            ),
            ("port".to_string(), Value::String(parts.port.clone())),
            (
                "pathname".to_string(),
                Value::String(if parts.has_authority {
                    parts.pathname.clone()
                } else {
                    parts.opaque_path.clone()
                }),
            ),
            ("search".to_string(), Value::String(parts.search.clone())),
            ("hash".to_string(), Value::String(parts.hash.clone())),
            ("origin".to_string(), Value::String(parts.origin())),
            (
                "ancestorOrigins".to_string(),
                Self::new_array_value(Vec::new()),
            ),
            (
                "assign".to_string(),
                Self::new_builtin_placeholder_function(),
            ),
            (
                "reload".to_string(),
                Self::new_builtin_placeholder_function(),
            ),
            (
                "replace".to_string(),
                Self::new_builtin_placeholder_function(),
            ),
            (
                "toString".to_string(),
                Self::new_builtin_placeholder_function(),
            ),
        ];
        entries.extend(extras);
        *self.location_object.borrow_mut() = entries;
    }

    fn is_location_object(entries: &[(String, Value)]) -> bool {
        matches!(
            Self::object_get_entry(entries, INTERNAL_LOCATION_OBJECT_KEY),
            Some(Value::Bool(true))
        )
    }

    fn history_builtin_keys() -> &'static [&'static str] {
        &[
            "length",
            "scrollRestoration",
            "state",
            "back",
            "forward",
            "go",
            "pushState",
            "replaceState",
        ]
    }

    fn current_history_state(&self) -> Value {
        self.history_entries
            .get(self.history_index)
            .map(|entry| entry.state.clone())
            .unwrap_or(Value::Null)
    }

    fn sync_history_object(&mut self) {
        let mut extras = Vec::new();
        {
            let entries = self.history_object.borrow();
            for (key, value) in entries.iter() {
                if Self::is_internal_object_key(key) {
                    continue;
                }
                if Self::history_builtin_keys()
                    .iter()
                    .any(|builtin| builtin == key)
                {
                    continue;
                }
                extras.push((key.clone(), value.clone()));
            }
        }

        let mut entries = vec![
            (INTERNAL_HISTORY_OBJECT_KEY.to_string(), Value::Bool(true)),
            (
                "length".to_string(),
                Value::Number(self.history_entries.len() as i64),
            ),
            (
                "scrollRestoration".to_string(),
                Value::String(self.history_scroll_restoration.clone()),
            ),
            ("state".to_string(), self.current_history_state()),
            ("back".to_string(), Self::new_builtin_placeholder_function()),
            (
                "forward".to_string(),
                Self::new_builtin_placeholder_function(),
            ),
            ("go".to_string(), Self::new_builtin_placeholder_function()),
            (
                "pushState".to_string(),
                Self::new_builtin_placeholder_function(),
            ),
            (
                "replaceState".to_string(),
                Self::new_builtin_placeholder_function(),
            ),
        ];
        entries.extend(extras);
        *self.history_object.borrow_mut() = entries;
    }

    fn is_history_object(entries: &[(String, Value)]) -> bool {
        matches!(
            Self::object_get_entry(entries, INTERNAL_HISTORY_OBJECT_KEY),
            Some(Value::Bool(true))
        )
    }

    fn is_window_object(entries: &[(String, Value)]) -> bool {
        matches!(
            Self::object_get_entry(entries, INTERNAL_WINDOW_OBJECT_KEY),
            Some(Value::Bool(true))
        )
    }

    fn is_navigator_object(entries: &[(String, Value)]) -> bool {
        matches!(
            Self::object_get_entry(entries, INTERNAL_NAVIGATOR_OBJECT_KEY),
            Some(Value::Bool(true))
        )
    }

    fn set_navigator_property(
        &mut self,
        navigator_object: &Rc<RefCell<Vec<(String, Value)>>>,
        key: &str,
        value: Value,
    ) -> Result<()> {
        match key {
            "clipboard" => Err(Error::ScriptRuntime(
                "navigator.clipboard is read-only".into(),
            )),
            _ => {
                Self::object_set_entry(&mut navigator_object.borrow_mut(), key.to_string(), value);
                Ok(())
            }
        }
    }

    fn set_window_property(&mut self, key: &str, value: Value) -> Result<()> {
        match key {
            "window" | "self" | "top" | "parent" | "frames" | "length" | "closed" | "history"
            | "navigator" | "clientInformation" | "document" | "origin" | "isSecureContext" => {
                Err(Error::ScriptRuntime(format!("window.{key} is read-only")))
            }
            "location" => self.set_location_property("href", value),
            "name" => {
                Self::object_set_entry(
                    &mut self.window_object.borrow_mut(),
                    "name".to_string(),
                    Value::String(value.as_string()),
                );
                Ok(())
            }
            _ => {
                Self::object_set_entry(
                    &mut self.window_object.borrow_mut(),
                    key.to_string(),
                    value,
                );
                Ok(())
            }
        }
    }

    fn set_history_property(&mut self, key: &str, value: Value) -> Result<()> {
        match key {
            "length" => Err(Error::ScriptRuntime("history.length is read-only".into())),
            "state" => Err(Error::ScriptRuntime("history.state is read-only".into())),
            "scrollRestoration" => {
                let mode = value.as_string();
                if mode != "auto" && mode != "manual" {
                    return Err(Error::ScriptRuntime(
                        "history.scrollRestoration must be 'auto' or 'manual'".into(),
                    ));
                }
                self.history_scroll_restoration = mode;
                self.sync_history_object();
                self.sync_window_runtime_properties();
                Ok(())
            }
            _ => {
                Self::object_set_entry(
                    &mut self.history_object.borrow_mut(),
                    key.to_string(),
                    value,
                );
                Ok(())
            }
        }
    }

    fn resolve_location_target_url(&self, input: &str) -> String {
        let input = input.trim();
        if input.is_empty() {
            return self.document_url.clone();
        }

        if let Some(parts) = LocationParts::parse(input) {
            return parts.href();
        }

        let base = self.current_location_parts();
        if input.starts_with("//") {
            return LocationParts::parse(&format!("{}{}", base.protocol(), input))
                .map(|parts| parts.href())
                .unwrap_or_else(|| input.to_string());
        }

        let mut next = base.clone();
        if input.starts_with('#') {
            next.hash = ensure_hash_prefix(input);
            return next.href();
        }

        if input.starts_with('?') {
            next.search = ensure_search_prefix(input);
            next.hash.clear();
            return next.href();
        }

        if input.starts_with('/') {
            if next.has_authority {
                next.pathname = normalize_pathname(input);
            } else {
                next.opaque_path = input.to_string();
            }
            next.search.clear();
            next.hash.clear();
            return next.href();
        }

        let mut relative = input;
        let mut next_search = String::new();
        let mut next_hash = String::new();
        if let Some(hash_pos) = relative.find('#') {
            next_hash = ensure_hash_prefix(&relative[hash_pos + 1..]);
            relative = &relative[..hash_pos];
        }
        if let Some(search_pos) = relative.find('?') {
            next_search = ensure_search_prefix(&relative[search_pos + 1..]);
            relative = &relative[..search_pos];
        }

        if next.has_authority {
            let base_dir = if let Some((prefix, _)) = next.pathname.rsplit_once('/') {
                if prefix.is_empty() {
                    "/".to_string()
                } else {
                    format!("{prefix}/")
                }
            } else {
                "/".to_string()
            };
            next.pathname = normalize_pathname(&format!("{base_dir}{relative}"));
        } else {
            next.opaque_path = relative.to_string();
        }
        next.search = next_search;
        next.hash = next_hash;
        next.href()
    }

    fn is_hash_only_navigation(from: &str, to: &str) -> bool {
        let Some(from_parts) = LocationParts::parse(from) else {
            return false;
        };
        let Some(to_parts) = LocationParts::parse(to) else {
            return false;
        };
        from_parts.scheme == to_parts.scheme
            && from_parts.has_authority == to_parts.has_authority
            && from_parts.hostname == to_parts.hostname
            && from_parts.port == to_parts.port
            && from_parts.pathname == to_parts.pathname
            && from_parts.opaque_path == to_parts.opaque_path
            && from_parts.search == to_parts.search
            && from_parts.hash != to_parts.hash
    }

    fn navigate_location(&mut self, next_url: &str, kind: LocationNavigationKind) -> Result<()> {
        let from = self.document_url.clone();
        let to = self.resolve_location_target_url(next_url);
        self.document_url = to.clone();
        match kind {
            LocationNavigationKind::Replace => {
                self.history_replace_current_entry(&to, Value::Null);
            }
            LocationNavigationKind::Assign | LocationNavigationKind::HrefSet => {
                self.history_push_entry(&to, Value::Null);
            }
            LocationNavigationKind::Reload => {}
        }
        self.sync_location_object();
        self.sync_history_object();
        self.sync_document_object();
        self.sync_window_runtime_properties();
        self.location_navigations.push(LocationNavigation {
            kind,
            from,
            to: to.clone(),
        });

        if !Self::is_hash_only_navigation(
            &self
                .location_navigations
                .last()
                .map(|nav| nav.from.clone())
                .unwrap_or_default(),
            &to,
        ) {
            let _ = self.load_location_mock_page_if_exists(&to)?;
        }
        Ok(())
    }

    fn reload_location(&mut self) -> Result<()> {
        self.location_reload_count += 1;
        let current = self.document_url.clone();
        self.location_navigations.push(LocationNavigation {
            kind: LocationNavigationKind::Reload,
            from: current.clone(),
            to: current.clone(),
        });
        self.sync_location_object();
        self.sync_history_object();
        self.sync_document_object();
        self.sync_window_runtime_properties();
        let _ = self.load_location_mock_page_if_exists(&current)?;
        Ok(())
    }

    fn load_location_mock_page_if_exists(&mut self, url: &str) -> Result<bool> {
        let Some(html) = self.location_mock_pages.get(url).cloned() else {
            return Ok(false);
        };
        self.replace_document_with_html(&html)?;
        Ok(true)
    }

    fn history_push_entry(&mut self, url: &str, state: Value) {
        let next = self
            .history_index
            .saturating_add(1)
            .min(self.history_entries.len());
        self.history_entries.truncate(next);
        self.history_entries.push(HistoryEntry {
            url: url.to_string(),
            state,
        });
        self.history_index = self.history_entries.len().saturating_sub(1);
    }

    fn history_replace_current_entry(&mut self, url: &str, state: Value) {
        if self.history_entries.is_empty() {
            self.history_entries.push(HistoryEntry {
                url: url.to_string(),
                state,
            });
            self.history_index = 0;
            return;
        }
        let index = self
            .history_index
            .min(self.history_entries.len().saturating_sub(1));
        self.history_entries[index] = HistoryEntry {
            url: url.to_string(),
            state,
        };
        self.history_index = index;
    }

    fn history_push_state(&mut self, state: Value, url: Option<&str>, replace: bool) -> Result<()> {
        let cloned = Self::structured_clone_value(&state, &mut Vec::new(), &mut Vec::new())?;
        let target_url = url.unwrap_or(&self.document_url);
        let next_url = self.resolve_location_target_url(target_url);
        self.document_url = next_url.clone();

        if replace {
            self.history_replace_current_entry(&next_url, cloned);
        } else {
            self.history_push_entry(&next_url, cloned);
        }
        self.sync_location_object();
        self.sync_history_object();
        self.sync_document_object();
        self.sync_window_runtime_properties();
        Ok(())
    }

    fn history_go_with_env(&mut self, delta: i64) -> Result<()> {
        if delta == 0 {
            self.reload_location()?;
            return Ok(());
        }

        let current = self.history_index as i64;
        let target = current.saturating_add(delta);
        if target < 0 || target >= self.history_entries.len() as i64 {
            return Ok(());
        }
        let target = target as usize;
        if target == self.history_index {
            return Ok(());
        }

        let from = self.document_url.clone();
        self.history_index = target;
        let entry = self
            .history_entries
            .get(target)
            .cloned()
            .unwrap_or(HistoryEntry {
                url: self.document_url.clone(),
                state: Value::Null,
            });
        self.document_url = entry.url.clone();
        self.sync_location_object();
        self.sync_history_object();
        self.sync_document_object();
        self.sync_window_runtime_properties();

        if !Self::is_hash_only_navigation(&from, &entry.url) {
            let _ = self.load_location_mock_page_if_exists(&entry.url)?;
        }

        let mut pop_env = self.script_env.clone();
        let _ = self.dispatch_event_with_options(
            self.dom.root,
            "popstate",
            &mut pop_env,
            true,
            false,
            false,
            Some(entry.state),
            None,
            None,
        )?;
        self.script_env = pop_env;
        Ok(())
    }

    fn replace_document_with_html(&mut self, html: &str) -> Result<()> {
        let ParseOutput { dom, scripts } = parse_html(html)?;
        self.dom = dom;
        self.listeners = ListenerStore::default();
        self.script_env.clear();
        self.task_queue.clear();
        self.microtask_queue.clear();
        self.active_element = None;
        self.running_timer_id = None;
        self.running_timer_canceled = false;
        self.dom.set_active_element(None);
        self.dom.set_active_pseudo_element(None);
        self.initialize_global_bindings();
        for script in scripts {
            self.compile_and_register_script(&script)?;
        }
        Ok(())
    }

    fn set_location_property(&mut self, key: &str, value: Value) -> Result<()> {
        match key {
            "href" => self.navigate_location(&value.as_string(), LocationNavigationKind::HrefSet),
            "protocol" => {
                let mut parts = self.current_location_parts();
                let protocol = value.as_string();
                let protocol = protocol.trim_end_matches(':').to_ascii_lowercase();
                if !is_valid_url_scheme(&protocol) {
                    return Err(Error::ScriptRuntime(format!(
                        "invalid location.protocol value: {}",
                        value.as_string()
                    )));
                }
                parts.scheme = protocol;
                self.navigate_location(&parts.href(), LocationNavigationKind::HrefSet)
            }
            "host" => {
                let mut parts = self.current_location_parts();
                let host = value.as_string();
                let (hostname, port) = split_hostname_and_port(host.trim());
                parts.hostname = hostname;
                parts.port = port;
                self.navigate_location(&parts.href(), LocationNavigationKind::HrefSet)
            }
            "hostname" => {
                let mut parts = self.current_location_parts();
                parts.hostname = value.as_string();
                self.navigate_location(&parts.href(), LocationNavigationKind::HrefSet)
            }
            "port" => {
                let mut parts = self.current_location_parts();
                parts.port = value.as_string();
                self.navigate_location(&parts.href(), LocationNavigationKind::HrefSet)
            }
            "pathname" => {
                let mut parts = self.current_location_parts();
                let raw = value.as_string();
                if parts.has_authority {
                    let normalized_input = if raw.starts_with('/') {
                        raw
                    } else {
                        format!("/{raw}")
                    };
                    parts.pathname = normalize_pathname(&normalized_input);
                } else {
                    parts.opaque_path = raw;
                }
                self.navigate_location(&parts.href(), LocationNavigationKind::HrefSet)
            }
            "search" => {
                let mut parts = self.current_location_parts();
                parts.search = ensure_search_prefix(&value.as_string());
                self.navigate_location(&parts.href(), LocationNavigationKind::HrefSet)
            }
            "hash" => {
                let mut parts = self.current_location_parts();
                parts.hash = ensure_hash_prefix(&value.as_string());
                self.navigate_location(&parts.href(), LocationNavigationKind::HrefSet)
            }
            "origin" | "ancestorOrigins" => {
                Err(Error::ScriptRuntime(format!("location.{key} is read-only")))
            }
            _ => {
                Self::object_set_entry(
                    &mut self.location_object.borrow_mut(),
                    key.to_string(),
                    value,
                );
                Ok(())
            }
        }
    }

    pub fn enable_trace(&mut self, enabled: bool) {
        self.trace = enabled;
    }

    pub fn take_trace_logs(&mut self) -> Vec<String> {
        std::mem::take(&mut self.trace_logs)
    }

    pub fn set_trace_stderr(&mut self, enabled: bool) {
        self.trace_to_stderr = enabled;
    }

    pub fn set_trace_events(&mut self, enabled: bool) {
        self.trace_events = enabled;
    }

    pub fn set_trace_timers(&mut self, enabled: bool) {
        self.trace_timers = enabled;
    }

    pub fn set_trace_log_limit(&mut self, max_entries: usize) -> Result<()> {
        if max_entries == 0 {
            return Err(Error::ScriptRuntime(
                "set_trace_log_limit requires at least 1 entry".into(),
            ));
        }
        self.trace_log_limit = max_entries;
        while self.trace_logs.len() > self.trace_log_limit {
            self.trace_logs.remove(0);
        }
        Ok(())
    }

    pub fn set_random_seed(&mut self, seed: u64) {
        self.rng_state = if seed == 0 {
            0xA5A5_A5A5_A5A5_A5A5
        } else {
            seed
        };
    }

    pub fn set_fetch_mock(&mut self, url: &str, body: &str) {
        self.fetch_mocks.insert(url.to_string(), body.to_string());
    }

    pub fn set_clipboard_text(&mut self, text: &str) {
        self.clipboard_text = text.to_string();
    }

    pub fn clipboard_text(&self) -> String {
        self.clipboard_text.clone()
    }

    pub fn set_location_mock_page(&mut self, url: &str, html: &str) {
        let normalized = self.resolve_location_target_url(url);
        self.location_mock_pages
            .insert(normalized, html.to_string());
    }

    pub fn clear_location_mock_pages(&mut self) {
        self.location_mock_pages.clear();
    }

    pub fn take_location_navigations(&mut self) -> Vec<LocationNavigation> {
        std::mem::take(&mut self.location_navigations)
    }

    pub fn location_reload_count(&self) -> usize {
        self.location_reload_count
    }

    pub fn clear_fetch_mocks(&mut self) {
        self.fetch_mocks.clear();
    }

    pub fn take_fetch_calls(&mut self) -> Vec<String> {
        std::mem::take(&mut self.fetch_calls)
    }

    pub fn set_match_media_mock(&mut self, query: &str, matches: bool) {
        self.match_media_mocks.insert(query.to_string(), matches);
    }

    pub fn clear_match_media_mocks(&mut self) {
        self.match_media_mocks.clear();
    }

    pub fn set_default_match_media_matches(&mut self, matches: bool) {
        self.default_match_media_matches = matches;
    }

    pub fn take_match_media_calls(&mut self) -> Vec<String> {
        std::mem::take(&mut self.match_media_calls)
    }

    pub fn enqueue_confirm_response(&mut self, accepted: bool) {
        self.confirm_responses.push_back(accepted);
    }

    pub fn set_default_confirm_response(&mut self, accepted: bool) {
        self.default_confirm_response = accepted;
    }

    pub fn enqueue_prompt_response(&mut self, value: Option<&str>) {
        self.prompt_responses
            .push_back(value.map(std::string::ToString::to_string));
    }

    pub fn set_default_prompt_response(&mut self, value: Option<&str>) {
        self.default_prompt_response = value.map(std::string::ToString::to_string);
    }

    pub fn take_alert_messages(&mut self) -> Vec<String> {
        std::mem::take(&mut self.alert_messages)
    }

    pub fn set_timer_step_limit(&mut self, max_steps: usize) -> Result<()> {
        if max_steps == 0 {
            return Err(Error::ScriptRuntime(
                "set_timer_step_limit requires at least 1 step".into(),
            ));
        }
        self.timer_step_limit = max_steps;
        Ok(())
    }

    pub fn type_text(&mut self, selector: &str, text: &str) -> Result<()> {
        let target = self.select_one(selector)?;
        if self.dom.disabled(target) {
            return Ok(());
        }
        if self.dom.readonly(target) {
            return Ok(());
        }

        let tag = self
            .dom
            .tag_name(target)
            .ok_or_else(|| Error::TypeMismatch {
                selector: selector.to_string(),
                expected: "input or textarea".into(),
                actual: "non-element".into(),
            })?
            .to_ascii_lowercase();

        if tag != "input" && tag != "textarea" {
            return Err(Error::TypeMismatch {
                selector: selector.to_string(),
                expected: "input or textarea".into(),
                actual: tag,
            });
        }

        self.dom.set_value(target, text)?;
        self.dispatch_event(target, "input")?;
        Ok(())
    }

    pub fn set_checked(&mut self, selector: &str, checked: bool) -> Result<()> {
        let target = self.select_one(selector)?;
        if self.dom.disabled(target) {
            return Ok(());
        }
        let tag = self
            .dom
            .tag_name(target)
            .unwrap_or_default()
            .to_ascii_lowercase();
        if tag != "input" {
            return Err(Error::TypeMismatch {
                selector: selector.to_string(),
                expected: "input[type=checkbox|radio]".into(),
                actual: tag,
            });
        }

        let kind = self
            .dom
            .attr(target, "type")
            .unwrap_or_else(|| "text".into())
            .to_ascii_lowercase();
        if kind != "checkbox" && kind != "radio" {
            return Err(Error::TypeMismatch {
                selector: selector.to_string(),
                expected: "input[type=checkbox|radio]".into(),
                actual: format!("input[type={kind}]"),
            });
        }

        let current = self.dom.checked(target)?;
        if current != checked {
            self.dom.set_checked(target, checked)?;
            self.dispatch_event(target, "input")?;
            self.dispatch_event(target, "change")?;
        }

        Ok(())
    }

    pub fn click(&mut self, selector: &str) -> Result<()> {
        let target = self.select_one(selector)?;
        self.click_node(target)
    }

    fn click_node_with_env(
        &mut self,
        target: NodeId,
        env: &mut HashMap<String, Value>,
    ) -> Result<()> {
        if self.dom.disabled(target) {
            return Ok(());
        }

        self.dom.set_active_pseudo_element(Some(target));
        let result: Result<()> = (|| {
            let click_outcome = self.dispatch_event_with_env(target, "click", env, true)?;
            if click_outcome.default_prevented {
                return Ok(());
            }

            if is_checkbox_input(&self.dom, target) {
                let current = self.dom.checked(target)?;
                self.dom.set_checked(target, !current)?;
                self.dispatch_event(target, "input")?;
                self.dispatch_event(target, "change")?;
            }

            if is_radio_input(&self.dom, target) {
                let current = self.dom.checked(target)?;
                if !current {
                    self.dom.set_checked(target, true)?;
                    self.dispatch_event(target, "input")?;
                    self.dispatch_event(target, "change")?;
                }
            }

            if is_submit_control(&self.dom, target) {
                if let Some(form_id) = self.resolve_form_for_submit(target) {
                    if !self.form_is_valid_for_submit(form_id)? {
                        return Ok(());
                    }
                    let submit_outcome =
                        self.dispatch_event_with_env(form_id, "submit", env, true)?;
                    if !submit_outcome.default_prevented {
                        self.maybe_close_dialog_for_form_submit_with_env(form_id, env)?;
                    }
                }
            }

            Ok(())
        })();
        self.dom.set_active_pseudo_element(None);
        result
    }

    fn click_node(&mut self, target: NodeId) -> Result<()> {
        let mut env = self.script_env.clone();
        self.click_node_with_env(target, &mut env)
    }

    pub fn focus(&mut self, selector: &str) -> Result<()> {
        let target = self.select_one(selector)?;
        self.focus_node(target)
    }

    pub fn blur(&mut self, selector: &str) -> Result<()> {
        let target = self.select_one(selector)?;
        self.blur_node(target)
    }

    pub fn submit(&mut self, selector: &str) -> Result<()> {
        let target = self.select_one(selector)?;

        let form = if self
            .dom
            .tag_name(target)
            .map(|t| t.eq_ignore_ascii_case("form"))
            .unwrap_or(false)
        {
            Some(target)
        } else {
            self.resolve_form_for_submit(target)
        };

        if let Some(form_id) = form {
            let submit_outcome = self.dispatch_event(form_id, "submit")?;
            if !submit_outcome.default_prevented {
                let mut env = self.script_env.clone();
                self.maybe_close_dialog_for_form_submit_with_env(form_id, &mut env)?;
                self.script_env = env;
            }
        }

        Ok(())
    }

    fn submit_form_with_env(
        &mut self,
        target: NodeId,
        env: &mut HashMap<String, Value>,
    ) -> Result<()> {
        let form = if self
            .dom
            .tag_name(target)
            .map(|t| t.eq_ignore_ascii_case("form"))
            .unwrap_or(false)
        {
            Some(target)
        } else {
            self.resolve_form_for_submit(target)
        };

        if let Some(form_id) = form {
            let submit_outcome = self.dispatch_event_with_env(form_id, "submit", env, true)?;
            if !submit_outcome.default_prevented {
                self.maybe_close_dialog_for_form_submit_with_env(form_id, env)?;
            }
        }

        Ok(())
    }

    fn maybe_close_dialog_for_form_submit_with_env(
        &mut self,
        form: NodeId,
        env: &mut HashMap<String, Value>,
    ) -> Result<()> {
        let Some(method) = self.dom.attr(form, "method") else {
            return Ok(());
        };
        if !method.eq_ignore_ascii_case("dialog") {
            return Ok(());
        }
        let Some(dialog) = self.dom.find_ancestor_by_tag(form, "dialog") else {
            return Ok(());
        };
        let _ = self.transition_dialog_open_state_with_env(dialog, false, true, env)?;
        Ok(())
    }

    fn reset_form_with_env(
        &mut self,
        target: NodeId,
        env: &mut HashMap<String, Value>,
    ) -> Result<()> {
        let Some(form_id) = self.resolve_form_for_submit(target) else {
            return Ok(());
        };

        let outcome = self.dispatch_event_with_env(form_id, "reset", env, true)?;
        if outcome.default_prevented {
            return Ok(());
        }

        let controls = self.form_elements(form_id)?;
        for control in controls {
            if is_checkbox_input(&self.dom, control) || is_radio_input(&self.dom, control) {
                let default_checked = self.dom.attr(control, "checked").is_some();
                self.dom.set_checked(control, default_checked)?;
                continue;
            }

            if self
                .dom
                .tag_name(control)
                .map(|tag| tag.eq_ignore_ascii_case("select"))
                .unwrap_or(false)
            {
                self.dom.sync_select_value(control)?;
                continue;
            }

            let default_value = self.dom.attr(control, "value").unwrap_or_default();
            self.dom.set_value(control, &default_value)?;
        }

        Ok(())
    }

    pub fn dispatch(&mut self, selector: &str, event: &str) -> Result<()> {
        let target = self.select_one(selector)?;
        let mut env = self.script_env.clone();
        let _ = self.dispatch_event_with_env(target, event, &mut env, false)?;
        self.script_env = env;
        Ok(())
    }

    pub fn now_ms(&self) -> i64 {
        self.now_ms
    }

    pub fn clear_timer(&mut self, timer_id: i64) -> bool {
        let existed = self.running_timer_id == Some(timer_id)
            || self.task_queue.iter().any(|task| task.id == timer_id);
        self.clear_timeout(timer_id);
        existed
    }

    pub fn clear_all_timers(&mut self) -> usize {
        let cleared = self.task_queue.len();
        self.task_queue.clear();
        if self.running_timer_id.is_some() {
            self.running_timer_canceled = true;
        }
        self.trace_timer_line(format!("[timer] clear_all cleared={cleared}"));
        cleared
    }

    pub fn pending_timers(&self) -> Vec<PendingTimer> {
        let mut timers = self
            .task_queue
            .iter()
            .map(|task| PendingTimer {
                id: task.id,
                due_at: task.due_at,
                order: task.order,
                interval_ms: task.interval_ms,
            })
            .collect::<Vec<_>>();
        timers.sort_by_key(|timer| (timer.due_at, timer.order));
        timers
    }

    pub fn advance_time(&mut self, delta_ms: i64) -> Result<()> {
        if delta_ms < 0 {
            return Err(Error::ScriptRuntime(
                "advance_time requires non-negative milliseconds".into(),
            ));
        }
        let from = self.now_ms;
        self.now_ms = self.now_ms.saturating_add(delta_ms);
        let ran = self.run_due_timers_internal()?;
        self.trace_timer_line(format!(
            "[timer] advance delta_ms={} from={} to={} ran_due={}",
            delta_ms, from, self.now_ms, ran
        ));
        Ok(())
    }

    pub fn advance_time_to(&mut self, target_ms: i64) -> Result<()> {
        if target_ms < self.now_ms {
            return Err(Error::ScriptRuntime(format!(
                "advance_time_to requires target >= now_ms (target={target_ms}, now_ms={})",
                self.now_ms
            )));
        }
        let from = self.now_ms;
        self.now_ms = target_ms;
        let ran = self.run_due_timers_internal()?;
        self.trace_timer_line(format!(
            "[timer] advance_to from={} to={} ran_due={}",
            from, self.now_ms, ran
        ));
        Ok(())
    }

    pub fn flush(&mut self) -> Result<()> {
        let from = self.now_ms;
        let ran = self.run_timer_queue(None, true)?;
        self.trace_timer_line(format!(
            "[timer] flush from={} to={} ran={}",
            from, self.now_ms, ran
        ));
        Ok(())
    }

    pub fn run_next_timer(&mut self) -> Result<bool> {
        let Some(next_idx) = self.next_task_index(None) else {
            self.trace_timer_line("[timer] run_next none".into());
            return Ok(false);
        };

        let task = self.task_queue.remove(next_idx);
        if task.due_at > self.now_ms {
            self.now_ms = task.due_at;
        }
        self.execute_timer_task(task)?;
        Ok(true)
    }

    pub fn run_next_due_timer(&mut self) -> Result<bool> {
        let Some(next_idx) = self.next_task_index(Some(self.now_ms)) else {
            self.trace_timer_line("[timer] run_next_due none".into());
            return Ok(false);
        };

        let task = self.task_queue.remove(next_idx);
        self.execute_timer_task(task)?;
        Ok(true)
    }

    pub fn run_due_timers(&mut self) -> Result<usize> {
        let ran = self.run_due_timers_internal()?;
        self.trace_timer_line(format!(
            "[timer] run_due now_ms={} ran={}",
            self.now_ms, ran
        ));
        Ok(ran)
    }

    fn run_due_timers_internal(&mut self) -> Result<usize> {
        self.run_timer_queue(Some(self.now_ms), false)
    }

    fn run_timer_queue(&mut self, due_limit: Option<i64>, advance_clock: bool) -> Result<usize> {
        let mut steps = 0usize;
        while let Some(next_idx) = self.next_task_index(due_limit) {
            steps += 1;
            if steps > self.timer_step_limit {
                return Err(self.timer_step_limit_error(self.timer_step_limit, steps, due_limit));
            }
            let task = self.task_queue.remove(next_idx);
            if advance_clock && task.due_at > self.now_ms {
                self.now_ms = task.due_at;
            }
            self.execute_timer_task(task)?;
        }
        Ok(steps)
    }

    fn timer_step_limit_error(
        &self,
        max_steps: usize,
        steps: usize,
        due_limit: Option<i64>,
    ) -> Error {
        let due_limit_desc = due_limit
            .map(|value| value.to_string())
            .unwrap_or_else(|| "none".into());

        let next_task_desc = self
            .next_task_index(due_limit)
            .and_then(|idx| self.task_queue.get(idx))
            .map(|task| {
                let interval_desc = task
                    .interval_ms
                    .map(|value| value.to_string())
                    .unwrap_or_else(|| "none".into());
                format!(
                    "id={},due_at={},order={},interval_ms={}",
                    task.id, task.due_at, task.order, interval_desc
                )
            })
            .unwrap_or_else(|| "none".into());

        Error::ScriptRuntime(format!(
            "flush exceeded max task steps (possible uncleared setInterval): limit={max_steps}, steps={steps}, now_ms={}, due_limit={}, pending_tasks={}, next_task={}",
            self.now_ms,
            due_limit_desc,
            self.task_queue.len(),
            next_task_desc
        ))
    }

    fn next_task_index(&self, due_limit: Option<i64>) -> Option<usize> {
        self.task_queue
            .iter()
            .enumerate()
            .filter(|(_, task)| {
                if let Some(limit) = due_limit {
                    task.due_at <= limit
                } else {
                    true
                }
            })
            .min_by_key(|(_, task)| (task.due_at, task.order))
            .map(|(idx, _)| idx)
    }

    fn execute_timer_task(&mut self, mut task: ScheduledTask) -> Result<()> {
        let interval_desc = task
            .interval_ms
            .map(|value| value.to_string())
            .unwrap_or_else(|| "none".into());
        self.trace_timer_line(format!(
            "[timer] run id={} due_at={} interval_ms={} now_ms={}",
            task.id, task.due_at, interval_desc, self.now_ms
        ));

        self.running_timer_id = Some(task.id);
        self.running_timer_canceled = false;
        let mut event = EventState::new("timeout", self.dom.root, self.now_ms);
        self.run_in_task_context(|this| {
            this.execute_timer_task_callback(
                &task.callback,
                &task.callback_args,
                &mut event,
                &mut task.env,
            )
            .map(|_| ())
        })?;
        let canceled = self.running_timer_canceled;
        self.running_timer_id = None;
        self.running_timer_canceled = false;

        if let Some(interval_ms) = task.interval_ms {
            if !canceled {
                let delay_ms = interval_ms.max(0);
                let due_at = task.due_at.saturating_add(delay_ms);
                let order = self.next_task_order;
                self.next_task_order += 1;
                self.task_queue.push(ScheduledTask {
                    id: task.id,
                    due_at,
                    order,
                    interval_ms: Some(delay_ms),
                    callback: task.callback,
                    callback_args: task.callback_args,
                    env: task.env,
                });
                self.trace_timer_line(format!(
                    "[timer] requeue id={} due_at={} interval_ms={}",
                    task.id, due_at, delay_ms
                ));
            }
        }

        Ok(())
    }

    pub fn assert_text(&self, selector: &str, expected: &str) -> Result<()> {
        let target = self.select_one(selector)?;
        let actual = self.dom.text_content(target);
        if actual != expected {
            return Err(Error::AssertionFailed {
                selector: selector.to_string(),
                expected: expected.to_string(),
                actual,
                dom_snippet: self.node_snippet(target),
            });
        }
        Ok(())
    }

    pub fn assert_value(&self, selector: &str, expected: &str) -> Result<()> {
        let target = self.select_one(selector)?;
        let actual = self.dom.value(target)?;
        if actual != expected {
            return Err(Error::AssertionFailed {
                selector: selector.to_string(),
                expected: expected.to_string(),
                actual,
                dom_snippet: self.node_snippet(target),
            });
        }
        Ok(())
    }

    pub fn assert_checked(&self, selector: &str, expected: bool) -> Result<()> {
        let target = self.select_one(selector)?;
        let actual = self.dom.checked(target)?;
        if actual != expected {
            return Err(Error::AssertionFailed {
                selector: selector.to_string(),
                expected: expected.to_string(),
                actual: actual.to_string(),
                dom_snippet: self.node_snippet(target),
            });
        }
        Ok(())
    }

    pub fn assert_exists(&self, selector: &str) -> Result<()> {
        let _ = self.select_one(selector)?;
        Ok(())
    }

    pub fn dump_dom(&self, selector: &str) -> Result<String> {
        let target = self.select_one(selector)?;
        Ok(self.dom.dump_node(target))
    }

    fn select_one(&self, selector: &str) -> Result<NodeId> {
        self.dom
            .query_selector(selector)?
            .ok_or_else(|| Error::SelectorNotFound(selector.to_string()))
    }

    fn node_snippet(&self, node_id: NodeId) -> String {
        truncate_chars(&self.dom.dump_node(node_id), 200)
    }

    fn resolve_form_for_submit(&self, target: NodeId) -> Option<NodeId> {
        if self
            .dom
            .tag_name(target)
            .map(|t| t.eq_ignore_ascii_case("form"))
            .unwrap_or(false)
        {
            return Some(target);
        }
        self.dom.find_ancestor_by_tag(target, "form")
    }

    fn form_elements(&self, form: NodeId) -> Result<Vec<NodeId>> {
        let tag = self
            .dom
            .tag_name(form)
            .ok_or_else(|| Error::ScriptRuntime("elements target is not an element".into()))?;
        if !tag.eq_ignore_ascii_case("form") {
            return Err(Error::ScriptRuntime(format!(
                "{}.elements target is not a form",
                self.event_node_label(form)
            )));
        }

        let mut out = Vec::new();
        self.collect_form_controls(form, &mut out);
        Ok(out)
    }

    fn form_data_entries(&self, form: NodeId) -> Result<Vec<(String, String)>> {
        let mut out = Vec::new();
        for control in self.form_elements(form)? {
            if !self.is_successful_form_data_control(control)? {
                continue;
            }
            let name = self.dom.attr(control, "name").unwrap_or_default();
            let value = self.form_data_control_value(control)?;
            out.push((name, value));
        }
        Ok(out)
    }

    fn is_successful_form_data_control(&self, control: NodeId) -> Result<bool> {
        if self.dom.disabled(control) {
            return Ok(false);
        }
        let name = self.dom.attr(control, "name").unwrap_or_default();
        if name.is_empty() {
            return Ok(false);
        }

        let tag = self
            .dom
            .tag_name(control)
            .ok_or_else(|| Error::ScriptRuntime("FormData target is not an element".into()))?;

        if tag.eq_ignore_ascii_case("button") {
            return Ok(false);
        }

        if tag.eq_ignore_ascii_case("input") {
            let kind = self
                .dom
                .attr(control, "type")
                .unwrap_or_default()
                .to_ascii_lowercase();
            if matches!(
                kind.as_str(),
                "button" | "submit" | "reset" | "file" | "image"
            ) {
                return Ok(false);
            }
            if kind == "checkbox" || kind == "radio" {
                return self.dom.checked(control);
            }
        }

        Ok(true)
    }

    fn form_data_control_value(&self, control: NodeId) -> Result<String> {
        let mut value = self.dom.value(control)?;
        if value.is_empty()
            && (is_checkbox_input(&self.dom, control) || is_radio_input(&self.dom, control))
        {
            value = "on".into();
        }
        Ok(value)
    }

    fn form_is_valid_for_submit(&self, form: NodeId) -> Result<bool> {
        let controls = self.form_elements(form)?;
        for control in &controls {
            if !self.required_control_satisfied(*control, &controls)? {
                return Ok(false);
            }
        }
        Ok(true)
    }

    fn required_control_satisfied(&self, control: NodeId, controls: &[NodeId]) -> Result<bool> {
        if self.dom.disabled(control) || !self.dom.required(control) {
            return Ok(true);
        }

        let tag = self
            .dom
            .tag_name(control)
            .ok_or_else(|| Error::ScriptRuntime("required target is not an element".into()))?;

        if tag.eq_ignore_ascii_case("input") {
            let kind = self
                .dom
                .attr(control, "type")
                .unwrap_or_default()
                .to_ascii_lowercase();
            if kind == "checkbox" {
                return self.dom.checked(control);
            }
            if kind == "radio" {
                if self.dom.checked(control)? {
                    return Ok(true);
                }
                let name = self.dom.attr(control, "name").unwrap_or_default();
                if name.is_empty() {
                    return Ok(false);
                }
                for candidate in controls {
                    if *candidate == control {
                        continue;
                    }
                    if !is_radio_input(&self.dom, *candidate) {
                        continue;
                    }
                    if self.dom.attr(*candidate, "name").unwrap_or_default() != name {
                        continue;
                    }
                    if self.dom.checked(*candidate)? {
                        return Ok(true);
                    }
                }
                return Ok(false);
            }
            return Ok(!self.dom.value(control)?.is_empty());
        }

        if tag.eq_ignore_ascii_case("select") || tag.eq_ignore_ascii_case("textarea") {
            return Ok(!self.dom.value(control)?.is_empty());
        }

        Ok(true)
    }

    fn eval_form_data_source(
        &mut self,
        source: &FormDataSource,
        env: &HashMap<String, Value>,
    ) -> Result<Vec<(String, String)>> {
        match source {
            FormDataSource::NewForm(form) => {
                let form_node = self.resolve_dom_query_required_runtime(form, env)?;
                self.form_data_entries(form_node)
            }
            FormDataSource::Var(name) => match env.get(name) {
                Some(Value::FormData(entries)) => Ok(entries.clone()),
                Some(_) => Err(Error::ScriptRuntime(format!(
                    "variable '{}' is not a FormData instance",
                    name
                ))),
                None => Err(Error::ScriptRuntime(format!(
                    "unknown FormData variable: {}",
                    name
                ))),
            },
        }
    }

    fn collect_form_controls(&self, node: NodeId, out: &mut Vec<NodeId>) {
        for child in &self.dom.nodes[node.0].children {
            if is_form_control(&self.dom, *child) {
                out.push(*child);
            }
            self.collect_form_controls(*child, out);
        }
    }

    fn dispatch_event(&mut self, target: NodeId, event_type: &str) -> Result<EventState> {
        let mut env = self.script_env.clone();
        let event = self.dispatch_event_with_env(target, event_type, &mut env, true)?;
        self.script_env = env;
        Ok(event)
    }

    fn dispatch_event_with_env(
        &mut self,
        target: NodeId,
        event_type: &str,
        env: &mut HashMap<String, Value>,
        trusted: bool,
    ) -> Result<EventState> {
        let event = if trusted {
            EventState::new(event_type, target, self.now_ms)
        } else {
            EventState::new_untrusted(event_type, target, self.now_ms)
        };
        self.dispatch_prepared_event_with_env(event, env)
    }

    fn dispatch_event_with_options(
        &mut self,
        target: NodeId,
        event_type: &str,
        env: &mut HashMap<String, Value>,
        trusted: bool,
        bubbles: bool,
        cancelable: bool,
        state: Option<Value>,
        old_state: Option<&str>,
        new_state: Option<&str>,
    ) -> Result<EventState> {
        let mut event = if trusted {
            EventState::new(event_type, target, self.now_ms)
        } else {
            EventState::new_untrusted(event_type, target, self.now_ms)
        };
        event.bubbles = bubbles;
        event.cancelable = cancelable;
        event.state = state;
        event.old_state = old_state.map(str::to_string);
        event.new_state = new_state.map(str::to_string);
        self.dispatch_prepared_event_with_env(event, env)
    }

    fn dispatch_prepared_event_with_env(
        &mut self,
        mut event: EventState,
        env: &mut HashMap<String, Value>,
    ) -> Result<EventState> {
        let target = event.target;
        self.run_in_task_context(|this| {
            let mut path = Vec::new();
            let mut cursor = Some(target);
            while let Some(node) = cursor {
                path.push(node);
                cursor = this.dom.parent(node);
            }
            path.reverse();

            if path.is_empty() {
                this.trace_event_done(&event, "empty_path");
                return Ok(());
            }

            // Capture phase.
            if path.len() >= 2 {
                for node in &path[..path.len() - 1] {
                    event.event_phase = 1;
                    event.current_target = *node;
                    this.invoke_listeners(*node, &mut event, env, true)?;
                    if event.propagation_stopped {
                        this.trace_event_done(&event, "propagation_stopped");
                        return Ok(());
                    }
                }
            }

            // Target phase: capture listeners first.
            event.event_phase = 2;
            event.current_target = target;
            this.invoke_listeners(target, &mut event, env, true)?;
            if event.propagation_stopped {
                this.trace_event_done(&event, "propagation_stopped");
                return Ok(());
            }

            // Target phase: bubble listeners.
            event.event_phase = 2;
            this.invoke_listeners(target, &mut event, env, false)?;
            if event.propagation_stopped {
                this.trace_event_done(&event, "propagation_stopped");
                return Ok(());
            }

            // Bubble phase.
            if path.len() >= 2 {
                for node in path[..path.len() - 1].iter().rev() {
                    event.event_phase = 3;
                    event.current_target = *node;
                    this.invoke_listeners(*node, &mut event, env, false)?;
                    if event.propagation_stopped {
                        this.trace_event_done(&event, "propagation_stopped");
                        return Ok(());
                    }
                }
            }

            this.trace_event_done(&event, "completed");
            Ok(())
        })?;
        Ok(event)
    }

    fn focus_node(&mut self, node: NodeId) -> Result<()> {
        let mut env = self.script_env.clone();
        self.focus_node_with_env(node, &mut env)?;
        self.script_env = env;
        Ok(())
    }

    fn focus_node_with_env(
        &mut self,
        node: NodeId,
        env: &mut HashMap<String, Value>,
    ) -> Result<()> {
        if self.dom.disabled(node) {
            return Ok(());
        }

        if self.active_element == Some(node) {
            return Ok(());
        }

        if let Some(current) = self.active_element {
            self.blur_node_with_env(current, env)?;
        }

        self.active_element = Some(node);
        self.dom.set_active_element(Some(node));
        self.dispatch_event_with_env(node, "focusin", env, true)?;
        self.dispatch_event_with_env(node, "focus", env, true)?;
        Ok(())
    }

    fn blur_node(&mut self, node: NodeId) -> Result<()> {
        let mut env = self.script_env.clone();
        self.blur_node_with_env(node, &mut env)?;
        self.script_env = env;
        Ok(())
    }

    fn blur_node_with_env(&mut self, node: NodeId, env: &mut HashMap<String, Value>) -> Result<()> {
        if self.active_element != Some(node) {
            return Ok(());
        }

        self.dispatch_event_with_env(node, "focusout", env, true)?;
        self.dispatch_event_with_env(node, "blur", env, true)?;
        self.active_element = None;
        self.dom.set_active_element(None);
        Ok(())
    }

    fn scroll_into_view_node_with_env(
        &mut self,
        _node: NodeId,
        _env: &mut HashMap<String, Value>,
    ) -> Result<()> {
        Ok(())
    }

    fn ensure_dialog_target(&self, node: NodeId, operation: &str) -> Result<()> {
        let tag = self
            .dom
            .tag_name(node)
            .ok_or_else(|| Error::ScriptRuntime(format!("{operation} target is not an element")))?;
        if tag.eq_ignore_ascii_case("dialog") {
            return Ok(());
        }
        Err(Error::ScriptRuntime(format!(
            "{operation} target is not a <dialog> element"
        )))
    }

    fn dialog_return_value(&self, dialog: NodeId) -> Result<String> {
        self.ensure_dialog_target(dialog, "returnValue")?;
        Ok(self
            .dialog_return_values
            .get(&dialog)
            .cloned()
            .unwrap_or_default())
    }

    fn set_dialog_return_value(&mut self, dialog: NodeId, value: String) -> Result<()> {
        self.ensure_dialog_target(dialog, "returnValue")?;
        self.dialog_return_values.insert(dialog, value);
        Ok(())
    }

    fn show_dialog_with_env(
        &mut self,
        dialog: NodeId,
        _modal: bool,
        env: &mut HashMap<String, Value>,
    ) -> Result<()> {
        self.ensure_dialog_target(dialog, "show/showModal")?;
        let _ = self.transition_dialog_open_state_with_env(dialog, true, false, env)?;
        Ok(())
    }

    fn close_dialog_with_env(
        &mut self,
        dialog: NodeId,
        return_value: Option<Value>,
        env: &mut HashMap<String, Value>,
    ) -> Result<()> {
        self.ensure_dialog_target(dialog, "close()")?;
        if let Some(return_value) = return_value {
            self.set_dialog_return_value(dialog, return_value.as_string())?;
        }
        let _ = self.transition_dialog_open_state_with_env(dialog, false, true, env)?;
        Ok(())
    }

    fn request_close_dialog_with_env(
        &mut self,
        dialog: NodeId,
        return_value: Option<Value>,
        env: &mut HashMap<String, Value>,
    ) -> Result<()> {
        self.ensure_dialog_target(dialog, "requestClose()")?;
        if let Some(return_value) = return_value {
            self.set_dialog_return_value(dialog, return_value.as_string())?;
        }
        if !self.dom.has_attr(dialog, "open")? {
            return Ok(());
        }
        let cancel_event = self.dispatch_event_with_options(
            dialog, "cancel", env, true, false, true, None, None, None,
        )?;
        if cancel_event.default_prevented {
            return Ok(());
        }
        let _ = self.transition_dialog_open_state_with_env(dialog, false, true, env)?;
        Ok(())
    }

    fn transition_dialog_open_state_with_env(
        &mut self,
        dialog: NodeId,
        open: bool,
        fire_close_event: bool,
        env: &mut HashMap<String, Value>,
    ) -> Result<bool> {
        let was_open = self.dom.has_attr(dialog, "open")?;
        if was_open == open {
            return Ok(false);
        }

        let (old_state, new_state) = if open {
            ("closed", "open")
        } else {
            ("open", "closed")
        };
        let beforetoggle = self.dispatch_event_with_options(
            dialog,
            "beforetoggle",
            env,
            true,
            false,
            true,
            None,
            Some(old_state),
            Some(new_state),
        )?;
        if beforetoggle.default_prevented {
            return Ok(false);
        }

        if open {
            self.dom.set_attr(dialog, "open", "true")?;
        } else {
            self.dom.remove_attr(dialog, "open")?;
        }

        let _ = self.dispatch_event_with_options(
            dialog,
            "toggle",
            env,
            true,
            false,
            false,
            None,
            Some(old_state),
            Some(new_state),
        )?;

        if !open && fire_close_event {
            let _ = self.dispatch_event_with_options(
                dialog, "close", env, true, false, false, None, None, None,
            )?;
        }

        Ok(true)
    }

    fn invoke_listeners(
        &mut self,
        node_id: NodeId,
        event: &mut EventState,
        env: &mut HashMap<String, Value>,
        capture: bool,
    ) -> Result<()> {
        let listeners = self.listeners.get(node_id, &event.event_type, capture);
        for listener in listeners {
            if self.trace {
                let phase = if capture { "capture" } else { "bubble" };
                let target_label = self.trace_node_label(event.target);
                let current_label = self.trace_node_label(event.current_target);
                self.trace_event_line(format!(
                    "[event] {} target={} current={} phase={} default_prevented={}",
                    event.event_type, target_label, current_label, phase, event.default_prevented
                ));
            }
            self.execute_handler(&listener.handler, event, env)?;
            if event.immediate_propagation_stopped {
                break;
            }
        }
        Ok(())
    }

    fn trace_event_done(&mut self, event: &EventState, outcome: &str) {
        let target_label = self.trace_node_label(event.target);
        let current_label = self.trace_node_label(event.current_target);
        self.trace_event_line(format!(
            "[event] done {} target={} current={} outcome={} default_prevented={} propagation_stopped={} immediate_stopped={}",
            event.event_type,
            target_label,
            current_label,
            outcome,
            event.default_prevented,
            event.propagation_stopped,
            event.immediate_propagation_stopped
        ));
    }

    fn trace_event_line(&mut self, line: String) {
        if self.trace && self.trace_events {
            self.trace_line(line);
        }
    }

    fn trace_timer_line(&mut self, line: String) {
        if self.trace && self.trace_timers {
            self.trace_line(line);
        }
    }

    fn trace_line(&mut self, line: String) {
        if self.trace {
            if self.trace_to_stderr {
                eprintln!("{line}");
            }
            if self.trace_logs.len() >= self.trace_log_limit {
                self.trace_logs.remove(0);
            }
            self.trace_logs.push(line);
        }
    }

    fn queue_microtask(&mut self, handler: ScriptHandler, env: &HashMap<String, Value>) {
        self.microtask_queue.push_back(ScheduledMicrotask::Script {
            handler,
            env: env.clone(),
        });
    }

    fn queue_promise_reaction_microtask(
        &mut self,
        reaction: PromiseReactionKind,
        settled: PromiseSettledValue,
    ) {
        self.microtask_queue
            .push_back(ScheduledMicrotask::Promise { reaction, settled });
    }

    fn run_microtask_queue(&mut self) -> Result<usize> {
        let mut steps = 0usize;
        self.task_depth += 1;
        let result = loop {
            let Some(task) = self.microtask_queue.pop_front() else {
                break Ok(());
            };
            steps += 1;
            if steps > self.timer_step_limit {
                break Err(self.timer_step_limit_error(
                    self.timer_step_limit,
                    steps,
                    Some(self.now_ms),
                ));
            }

            match task {
                ScheduledMicrotask::Script { handler, mut env } => {
                    let mut event = EventState::new("microtask", self.dom.root, self.now_ms);
                    let event_param = handler
                        .first_event_param()
                        .map(|event_param| event_param.to_string());
                    self.bind_handler_params(&handler, &[], &mut env, &event_param, &event)?;
                    let run =
                        self.execute_stmts(&handler.stmts, &event_param, &mut event, &mut env);
                    let run = run.map(|_| ());
                    if let Err(err) = run {
                        break Err(err);
                    }
                }
                ScheduledMicrotask::Promise { reaction, settled } => {
                    self.run_promise_reaction_task(reaction, settled)?;
                }
            }
        };
        self.task_depth -= 1;
        result?;
        Ok(steps)
    }

    fn run_in_task_context<T>(&mut self, mut run: impl FnMut(&mut Self) -> Result<T>) -> Result<T> {
        self.task_depth += 1;
        let result = run(self);
        self.task_depth -= 1;
        let should_flush_microtasks = self.task_depth == 0;
        match result {
            Ok(value) => {
                if should_flush_microtasks {
                    self.run_microtask_queue()?;
                }
                Ok(value)
            }
            Err(err) => Err(err),
        }
    }

    fn execute_handler(
        &mut self,
        handler: &ScriptHandler,
        event: &mut EventState,
        env: &mut HashMap<String, Value>,
    ) -> Result<()> {
        let event_param = handler
            .first_event_param()
            .map(|event_param| event_param.to_string());
        let event_args = if event_param.is_some() {
            vec![Self::new_object_value(Vec::new())]
        } else {
            Vec::new()
        };
        self.bind_handler_params(handler, &event_args, env, &event_param, event)?;
        let flow = self.execute_stmts(&handler.stmts, &event_param, event, env)?;
        env.remove(INTERNAL_RETURN_SLOT);
        match flow {
            ExecFlow::Continue => Ok(()),
            ExecFlow::Break => Err(Error::ScriptRuntime(
                "break statement outside of loop".into(),
            )),
            ExecFlow::ContinueLoop => Err(Error::ScriptRuntime(
                "continue statement outside of loop".into(),
            )),
            ExecFlow::Return => Ok(()),
        }
    }

    fn execute_timer_task_callback(
        &mut self,
        callback: &TimerCallback,
        callback_args: &[Value],
        event: &mut EventState,
        env: &mut HashMap<String, Value>,
    ) -> Result<()> {
        let handler = match callback {
            TimerCallback::Inline(handler) => handler.clone(),
            TimerCallback::Reference(name) => {
                let value = env
                    .get(name)
                    .cloned()
                    .ok_or_else(|| Error::ScriptRuntime(format!("unknown variable: {name}")))?;
                let Value::Function(function) = value else {
                    return Err(Error::ScriptRuntime(format!(
                        "timer callback '{name}' is not a function"
                    )));
                };
                function.handler.clone()
            }
        };
        let event_param = handler
            .first_event_param()
            .map(|event_param| event_param.to_string());
        self.bind_handler_params(&handler, callback_args, env, &event_param, event)?;
        let flow = self.execute_stmts(&handler.stmts, &event_param, event, env)?;
        env.remove(INTERNAL_RETURN_SLOT);
        match flow {
            ExecFlow::Continue => Ok(()),
            ExecFlow::Break => Err(Error::ScriptRuntime(
                "break statement outside of loop".into(),
            )),
            ExecFlow::ContinueLoop => Err(Error::ScriptRuntime(
                "continue statement outside of loop".into(),
            )),
            ExecFlow::Return => Ok(()),
        }
    }

    fn make_function_value(
        &self,
        handler: ScriptHandler,
        env: &HashMap<String, Value>,
        global_scope: bool,
        is_async: bool,
    ) -> Value {
        let captured_env = if global_scope {
            self.script_env.clone()
        } else {
            env.clone()
        };
        Value::Function(Rc::new(FunctionValue {
            handler,
            captured_env,
            global_scope,
            is_async,
        }))
    }

    fn is_callable_value(&self, value: &Value) -> bool {
        matches!(
            value,
            Value::Function(_) | Value::PromiseCapability(_) | Value::StringConstructor
        ) || Self::callable_kind_from_value(value).is_some()
    }

    fn execute_callable_value(
        &mut self,
        callable: &Value,
        args: &[Value],
        event: &EventState,
    ) -> Result<Value> {
        match callable {
            Value::Function(function) => self.execute_function_call(function.as_ref(), args, event),
            Value::PromiseCapability(capability) => {
                self.invoke_promise_capability(capability, args)
            }
            Value::StringConstructor => {
                let value = args.first().cloned().unwrap_or(Value::Undefined);
                Ok(Value::String(value.as_string()))
            }
            Value::Object(_) => {
                let Some(kind) = Self::callable_kind_from_value(callable) else {
                    return Err(Error::ScriptRuntime("callback is not a function".into()));
                };
                match kind {
                    "intl_collator_compare" => {
                        let (locale, case_first, sensitivity) =
                            self.resolve_intl_collator_options(callable)?;
                        let left = args
                            .first()
                            .cloned()
                            .unwrap_or(Value::Undefined)
                            .as_string();
                        let right = args.get(1).cloned().unwrap_or(Value::Undefined).as_string();
                        Ok(Value::Number(Self::intl_collator_compare_strings(
                            &left,
                            &right,
                            &locale,
                            &case_first,
                            &sensitivity,
                        )))
                    }
                    "intl_date_time_format" => {
                        let (locale, options) = self.resolve_intl_date_time_options(callable)?;
                        let timestamp_ms = args
                            .first()
                            .map(|value| self.coerce_date_timestamp_ms(value))
                            .unwrap_or(self.now_ms);
                        Ok(Value::String(self.intl_format_date_time(
                            timestamp_ms,
                            &locale,
                            &options,
                        )))
                    }
                    "intl_duration_format" => {
                        let (locale, options) = self.resolve_intl_duration_options(callable)?;
                        let value = args.first().cloned().unwrap_or(Value::Undefined);
                        Ok(Value::String(
                            self.intl_format_duration(&locale, &options, &value)?,
                        ))
                    }
                    "intl_list_format" => {
                        let (locale, options) = self.resolve_intl_list_options(callable)?;
                        let value = args.first().cloned().unwrap_or(Value::Undefined);
                        Ok(Value::String(
                            self.intl_format_list(&locale, &options, &value)?,
                        ))
                    }
                    "intl_number_format" => {
                        let (_, locale) = self.resolve_intl_formatter(callable)?;
                        let value = args.first().cloned().unwrap_or(Value::Undefined);
                        Ok(Value::String(Self::intl_format_number_for_locale(
                            Self::coerce_number_for_global(&value),
                            &locale,
                        )))
                    }
                    "intl_segmenter_segments_iterator" => {
                        let Value::Object(entries) = callable else {
                            return Err(Error::ScriptRuntime("callback is not a function".into()));
                        };
                        let entries = entries.borrow();
                        let segments = Self::object_get_entry(&entries, INTERNAL_INTL_SEGMENTS_KEY)
                            .ok_or_else(|| {
                                Error::ScriptRuntime(
                                    "Intl.Segmenter iterator has invalid internal state".into(),
                                )
                            })?;
                        Ok(self.new_intl_segmenter_iterator_value(segments))
                    }
                    "intl_segmenter_iterator_next" => {
                        let Value::Object(entries) = callable else {
                            return Err(Error::ScriptRuntime("callback is not a function".into()));
                        };
                        let mut entries = entries.borrow_mut();
                        let segments = Self::object_get_entry(&entries, INTERNAL_INTL_SEGMENTS_KEY)
                            .ok_or_else(|| {
                                Error::ScriptRuntime(
                                    "Intl.Segmenter iterator has invalid internal state".into(),
                                )
                            })?;
                        let Value::Array(values) = segments else {
                            return Err(Error::ScriptRuntime(
                                "Intl.Segmenter iterator has invalid internal state".into(),
                            ));
                        };
                        let len = values.borrow().len();
                        let index =
                            match Self::object_get_entry(&entries, INTERNAL_INTL_SEGMENT_INDEX_KEY)
                            {
                                Some(Value::Number(value)) if value >= 0 => value as usize,
                                _ => 0,
                            };
                        if index >= len {
                            return Ok(Self::new_object_value(vec![
                                ("value".to_string(), Value::Undefined),
                                ("done".to_string(), Value::Bool(true)),
                            ]));
                        }
                        let value = values
                            .borrow()
                            .get(index)
                            .cloned()
                            .unwrap_or(Value::Undefined);
                        Self::object_set_entry(
                            &mut entries,
                            INTERNAL_INTL_SEGMENT_INDEX_KEY.to_string(),
                            Value::Number((index + 1) as i64),
                        );
                        Ok(Self::new_object_value(vec![
                            ("value".to_string(), value),
                            ("done".to_string(), Value::Bool(false)),
                        ]))
                    }
                    _ => Err(Error::ScriptRuntime("callback is not a function".into())),
                }
            }
            _ => Err(Error::ScriptRuntime("callback is not a function".into())),
        }
    }

    fn invoke_promise_capability(
        &mut self,
        capability: &PromiseCapabilityFunction,
        args: &[Value],
    ) -> Result<Value> {
        let mut already_called = capability.already_called.borrow_mut();
        if *already_called {
            return Ok(Value::Undefined);
        }
        *already_called = true;
        drop(already_called);

        let value = args.first().cloned().unwrap_or(Value::Undefined);
        if capability.reject {
            self.promise_reject(&capability.promise, value);
            Ok(Value::Undefined)
        } else {
            self.promise_resolve(&capability.promise, value)?;
            Ok(Value::Undefined)
        }
    }

    fn bind_handler_params(
        &mut self,
        handler: &ScriptHandler,
        args: &[Value],
        env: &mut HashMap<String, Value>,
        event_param: &Option<String>,
        event: &EventState,
    ) -> Result<()> {
        for (index, param) in handler.params.iter().enumerate() {
            let provided = args.get(index).cloned().unwrap_or(Value::Undefined);
            let value = if matches!(provided, Value::Undefined) {
                if let Some(default_expr) = &param.default {
                    self.eval_expr(default_expr, env, event_param, event)?
                } else {
                    Value::Undefined
                }
            } else {
                provided
            };
            env.insert(param.name.clone(), value);
        }
        Ok(())
    }

    fn execute_function_call(
        &mut self,
        function: &FunctionValue,
        args: &[Value],
        event: &EventState,
    ) -> Result<Value> {
        let run = |this: &mut Self| -> Result<Value> {
            let mut call_env = if function.global_scope {
                this.script_env.clone()
            } else {
                function.captured_env.clone()
            };
            call_env.remove(INTERNAL_RETURN_SLOT);
            let mut call_event = event.clone();
            let event_param = None;
            this.bind_handler_params(
                &function.handler,
                args,
                &mut call_env,
                &event_param,
                &call_event,
            )?;
            let flow = this.execute_stmts(
                &function.handler.stmts,
                &event_param,
                &mut call_event,
                &mut call_env,
            )?;
            match flow {
                ExecFlow::Continue => Ok(Value::Undefined),
                ExecFlow::Break => Err(Error::ScriptRuntime(
                    "break statement outside of loop".into(),
                )),
                ExecFlow::ContinueLoop => Err(Error::ScriptRuntime(
                    "continue statement outside of loop".into(),
                )),
                ExecFlow::Return => Ok(call_env
                    .remove(INTERNAL_RETURN_SLOT)
                    .unwrap_or(Value::Undefined)),
            }
        };

        if function.is_async {
            let promise = self.new_pending_promise();
            match run(self) {
                Ok(value) => {
                    if let Err(err) = self.promise_resolve(&promise, value) {
                        self.promise_reject(&promise, Self::promise_error_reason(err));
                    }
                }
                Err(err) => self.promise_reject(&promise, Self::promise_error_reason(err)),
            }
            Ok(Value::Promise(promise))
        } else {
            run(self)
        }
    }

    fn error_to_catch_value(err: Error) -> std::result::Result<Value, Error> {
        match err {
            Error::ScriptThrown(value) => Ok(value.into_value()),
            Error::ScriptRuntime(message) => Ok(Value::String(message)),
            other => Err(other),
        }
    }

    fn bind_catch_binding(
        &self,
        binding: &CatchBinding,
        caught: &Value,
        env: &mut HashMap<String, Value>,
    ) -> Result<Vec<(String, Option<Value>)>> {
        let mut previous = Vec::new();
        let mut seen = HashSet::new();
        let mut remember = |name: &str, env: &HashMap<String, Value>| {
            if seen.insert(name.to_string()) {
                previous.push((name.to_string(), env.get(name).cloned()));
            }
        };

        match binding {
            CatchBinding::Identifier(name) => {
                remember(name, env);
                env.insert(name.clone(), caught.clone());
            }
            CatchBinding::ArrayPattern(pattern) => {
                let values = self.array_like_values_from_value(caught)?;
                for (index, name) in pattern.iter().enumerate() {
                    let Some(name) = name else {
                        continue;
                    };
                    remember(name, env);
                    let value = values.get(index).cloned().unwrap_or(Value::Undefined);
                    env.insert(name.clone(), value);
                }
            }
            CatchBinding::ObjectPattern(pattern) => {
                let Value::Object(entries) = caught else {
                    return Err(Error::ScriptRuntime(
                        "catch object binding requires an object value".into(),
                    ));
                };
                let entries = entries.borrow();
                for (source_key, target_name) in pattern {
                    remember(target_name, env);
                    let value =
                        Self::object_get_entry(&entries, source_key).unwrap_or(Value::Undefined);
                    env.insert(target_name.clone(), value);
                }
            }
        }

        Ok(previous)
    }

    fn restore_catch_binding(
        &self,
        previous: Vec<(String, Option<Value>)>,
        env: &mut HashMap<String, Value>,
    ) {
        for (name, value) in previous {
            if let Some(value) = value {
                env.insert(name, value);
            } else {
                env.remove(&name);
            }
        }
    }

    fn execute_catch_block(
        &mut self,
        catch_binding: &Option<CatchBinding>,
        catch_stmts: &[Stmt],
        caught: Value,
        event_param: &Option<String>,
        event: &mut EventState,
        env: &mut HashMap<String, Value>,
    ) -> Result<ExecFlow> {
        let previous = if let Some(binding) = catch_binding {
            self.bind_catch_binding(binding, &caught, env)?
        } else {
            Vec::new()
        };
        let result = self.execute_stmts(catch_stmts, event_param, event, env);
        self.restore_catch_binding(previous, env);
        result
    }

    fn parse_function_constructor_param_names(spec: &str) -> Result<Vec<String>> {
        let mut params = Vec::new();
        for raw in spec.split(',') {
            let raw = raw.trim();
            if raw.is_empty() {
                return Err(Error::ScriptRuntime(
                    "new Function parameter name cannot be empty".into(),
                ));
            }
            if !is_ident(raw) {
                return Err(Error::ScriptRuntime(format!(
                    "new Function parameter name is invalid: {raw}"
                )));
            }
            params.push(raw.to_string());
        }
        Ok(params)
    }

    fn execute_stmts(
        &mut self,
        stmts: &[Stmt],
        event_param: &Option<String>,
        event: &mut EventState,
        env: &mut HashMap<String, Value>,
    ) -> Result<ExecFlow> {
        for stmt in stmts {
            match stmt {
                Stmt::VarDecl { name, expr } => {
                    let value = self.eval_expr(expr, env, event_param, event)?;
                    env.insert(name.clone(), value.clone());
                    self.bind_timer_id_to_task_env(name, expr, &value);
                }
                Stmt::FunctionDecl {
                    name,
                    handler,
                    is_async,
                } => {
                    let function = self.make_function_value(handler.clone(), env, false, *is_async);
                    env.insert(name.clone(), function);
                }
                Stmt::VarAssign { name, op, expr } => {
                    let previous = env
                        .get(name)
                        .cloned()
                        .ok_or_else(|| Error::ScriptRuntime(format!("unknown variable: {name}")))?;

                    let next = match op {
                        VarAssignOp::Assign => self.eval_expr(expr, env, event_param, event)?,
                        VarAssignOp::Add => {
                            let value = self.eval_expr(expr, env, event_param, event)?;
                            self.add_values(&previous, &value)?
                        }
                        VarAssignOp::Sub => {
                            let value = self.eval_expr(expr, env, event_param, event)?;
                            self.eval_binary(&BinaryOp::Sub, &previous, &value)?
                        }
                        VarAssignOp::Mul => {
                            let value = self.eval_expr(expr, env, event_param, event)?;
                            self.eval_binary(&BinaryOp::Mul, &previous, &value)?
                        }
                        VarAssignOp::Pow => {
                            let value = self.eval_expr(expr, env, event_param, event)?;
                            self.eval_binary(&BinaryOp::Pow, &previous, &value)?
                        }
                        VarAssignOp::BitOr => {
                            let value = self.eval_expr(expr, env, event_param, event)?;
                            self.eval_binary(&BinaryOp::BitOr, &previous, &value)?
                        }
                        VarAssignOp::BitXor => {
                            let value = self.eval_expr(expr, env, event_param, event)?;
                            self.eval_binary(&BinaryOp::BitXor, &previous, &value)?
                        }
                        VarAssignOp::BitAnd => {
                            let value = self.eval_expr(expr, env, event_param, event)?;
                            self.eval_binary(&BinaryOp::BitAnd, &previous, &value)?
                        }
                        VarAssignOp::ShiftLeft => {
                            let value = self.eval_expr(expr, env, event_param, event)?;
                            self.eval_binary(&BinaryOp::ShiftLeft, &previous, &value)?
                        }
                        VarAssignOp::ShiftRight => {
                            let value = self.eval_expr(expr, env, event_param, event)?;
                            self.eval_binary(&BinaryOp::ShiftRight, &previous, &value)?
                        }
                        VarAssignOp::UnsignedShiftRight => {
                            let value = self.eval_expr(expr, env, event_param, event)?;
                            self.eval_binary(&BinaryOp::UnsignedShiftRight, &previous, &value)?
                        }
                        VarAssignOp::Div => {
                            let value = self.eval_expr(expr, env, event_param, event)?;
                            self.eval_binary(&BinaryOp::Div, &previous, &value)?
                        }
                        VarAssignOp::Mod => {
                            let value = self.eval_expr(expr, env, event_param, event)?;
                            self.eval_binary(&BinaryOp::Mod, &previous, &value)?
                        }
                        VarAssignOp::LogicalAnd => {
                            if previous.truthy() {
                                self.eval_expr(expr, env, event_param, event)?
                            } else {
                                previous.clone()
                            }
                        }
                        VarAssignOp::LogicalOr => {
                            if previous.truthy() {
                                previous.clone()
                            } else {
                                self.eval_expr(expr, env, event_param, event)?
                            }
                        }
                        VarAssignOp::Nullish => {
                            if matches!(&previous, Value::Null | Value::Undefined) {
                                self.eval_expr(expr, env, event_param, event)?
                            } else {
                                previous.clone()
                            }
                        }
                    };
                    env.insert(name.clone(), next.clone());
                    self.bind_timer_id_to_task_env(name, expr, &next);
                }
                Stmt::VarUpdate { name, delta } => {
                    let previous = env
                        .get(name)
                        .cloned()
                        .ok_or_else(|| Error::ScriptRuntime(format!("unknown variable: {name}")))?;
                    let next = match previous {
                        Value::Number(value) => {
                            if let Some(sum) = value.checked_add(i64::from(*delta)) {
                                Value::Number(sum)
                            } else {
                                Value::Float((value as f64) + f64::from(*delta))
                            }
                        }
                        Value::Float(value) => Value::Float(value + f64::from(*delta)),
                        Value::BigInt(value) => Value::BigInt(value + JsBigInt::from(*delta)),
                        _ => {
                            return Err(Error::ScriptRuntime(format!(
                                "cannot apply update operator to '{}'",
                                name
                            )));
                        }
                    };
                    env.insert(name.clone(), next);
                }
                Stmt::ArrayDestructureAssign { targets, expr } => {
                    let value = self.eval_expr(expr, env, event_param, event)?;
                    let values = self.array_like_values_from_value(&value)?;
                    for (index, target_name) in targets.iter().enumerate() {
                        let Some(target_name) = target_name else {
                            continue;
                        };
                        if !env.contains_key(target_name) {
                            return Err(Error::ScriptRuntime(format!(
                                "unknown variable: {}",
                                target_name
                            )));
                        }
                        let next = values.get(index).cloned().unwrap_or(Value::Undefined);
                        env.insert(target_name.clone(), next);
                    }
                }
                Stmt::ObjectDestructureAssign { bindings, expr } => {
                    let value = self.eval_expr(expr, env, event_param, event)?;
                    let Value::Object(entries) = value else {
                        return Err(Error::ScriptRuntime(
                            "object destructuring source must be an object".into(),
                        ));
                    };
                    let entries = entries.borrow();
                    for (source_key, target_name) in bindings {
                        if !env.contains_key(target_name) {
                            return Err(Error::ScriptRuntime(format!(
                                "unknown variable: {}",
                                target_name
                            )));
                        }
                        let next = Self::object_get_entry(&entries, source_key)
                            .unwrap_or(Value::Undefined);
                        env.insert(target_name.clone(), next);
                    }
                }
                Stmt::ObjectAssign { target, key, expr } => {
                    let value = self.eval_expr(expr, env, event_param, event)?;
                    let key = self.eval_expr(key, env, event_param, event)?;
                    match env.get(target) {
                        Some(Value::Object(object)) => {
                            let key = self.property_key_to_storage_key(&key);
                            let (is_location, is_history, is_window, is_navigator) = {
                                let entries = object.borrow();
                                (
                                    Self::is_location_object(&entries),
                                    Self::is_history_object(&entries),
                                    Self::is_window_object(&entries),
                                    Self::is_navigator_object(&entries),
                                )
                            };
                            if is_location {
                                self.set_location_property(&key, value)?;
                                continue;
                            }
                            if is_history {
                                self.set_history_property(&key, value)?;
                                continue;
                            }
                            if is_window {
                                self.set_window_property(&key, value)?;
                                continue;
                            }
                            if is_navigator {
                                self.set_navigator_property(object, &key, value)?;
                                continue;
                            }
                            Self::object_set_entry(&mut object.borrow_mut(), key, value);
                        }
                        Some(Value::Array(values)) => {
                            let Some(index) = self.value_as_index(&key) else {
                                continue;
                            };
                            let mut values = values.borrow_mut();
                            if index >= values.len() {
                                values.resize(index + 1, Value::Undefined);
                            }
                            values[index] = value;
                        }
                        Some(Value::TypedArray(values)) => {
                            let Some(index) = self.value_as_index(&key) else {
                                continue;
                            };
                            self.typed_array_set_index(values, index, value)?;
                        }
                        Some(Value::Map(map)) => {
                            let key = self.property_key_to_storage_key(&key);
                            Self::object_set_entry(&mut map.borrow_mut().properties, key, value);
                        }
                        Some(Value::Set(set)) => {
                            let key = self.property_key_to_storage_key(&key);
                            Self::object_set_entry(&mut set.borrow_mut().properties, key, value);
                        }
                        Some(Value::RegExp(regex)) => {
                            let key = self.property_key_to_storage_key(&key);
                            if key == "lastIndex" {
                                let mut regex = regex.borrow_mut();
                                let next = Self::value_to_i64(&value);
                                regex.last_index = if next <= 0 { 0 } else { next as usize };
                            } else {
                                Self::object_set_entry(
                                    &mut regex.borrow_mut().properties,
                                    key,
                                    value,
                                );
                            }
                        }
                        Some(_) => {
                            return Err(Error::ScriptRuntime(format!(
                                "variable '{}' is not an object",
                                target
                            )));
                        }
                        None => {
                            return Err(Error::ScriptRuntime(format!(
                                "unknown variable: {}",
                                target
                            )));
                        }
                    }
                }
                Stmt::FormDataAppend {
                    target_var,
                    name,
                    value,
                } => {
                    let name = self.eval_expr(name, env, event_param, event)?;
                    let value = self.eval_expr(value, env, event_param, event)?;
                    let entries = env.get_mut(target_var).ok_or_else(|| {
                        Error::ScriptRuntime(format!("unknown FormData variable: {}", target_var))
                    })?;
                    let Value::FormData(entries) = entries else {
                        return Err(Error::ScriptRuntime(format!(
                            "variable '{}' is not a FormData instance",
                            target_var
                        )));
                    };
                    entries.push((name.as_string(), value.as_string()));
                }
                Stmt::DomAssign { target, prop, expr } => {
                    let value = self.eval_expr(expr, env, event_param, event)?;
                    if let DomQuery::Var(name) = target {
                        if let Some(Value::Object(entries)) = env.get(name) {
                            if let Some(key) = Self::object_key_from_dom_prop(prop) {
                                Self::object_set_entry(
                                    &mut entries.borrow_mut(),
                                    key.to_string(),
                                    value,
                                );
                                continue;
                            }
                        }
                    }
                    let node = self.resolve_dom_query_required_runtime(target, env)?;
                    match prop {
                        DomProp::TextContent => {
                            self.dom.set_text_content(node, &value.as_string())?
                        }
                        DomProp::InnerHtml => self.dom.set_inner_html(node, &value.as_string())?,
                        DomProp::Value => self.dom.set_value(node, &value.as_string())?,
                        DomProp::Checked => self.dom.set_checked(node, value.truthy())?,
                        DomProp::Open => {
                            if value.truthy() {
                                self.dom.set_attr(node, "open", "true")?;
                            } else {
                                self.dom.remove_attr(node, "open")?;
                            }
                        }
                        DomProp::ReturnValue => {
                            self.set_dialog_return_value(node, value.as_string())?;
                        }
                        DomProp::ClosedBy => {
                            self.dom.set_attr(node, "closedby", &value.as_string())?
                        }
                        DomProp::Readonly => {
                            if value.truthy() {
                                self.dom.set_attr(node, "readonly", "true")?;
                            } else {
                                self.dom.remove_attr(node, "readonly")?;
                            }
                        }
                        DomProp::Required => {
                            if value.truthy() {
                                self.dom.set_attr(node, "required", "true")?;
                            } else {
                                self.dom.remove_attr(node, "required")?;
                            }
                        }
                        DomProp::Disabled => {
                            if value.truthy() {
                                self.dom.set_attr(node, "disabled", "true")?;
                            } else {
                                self.dom.remove_attr(node, "disabled")?;
                            }
                        }
                        DomProp::ClassName => {
                            self.dom.set_attr(node, "class", &value.as_string())?
                        }
                        DomProp::Id => self.dom.set_attr(node, "id", &value.as_string())?,
                        DomProp::Name => self.dom.set_attr(node, "name", &value.as_string())?,
                        DomProp::Title => self.dom.set_document_title(&value.as_string())?,
                        DomProp::Location | DomProp::LocationHref => self.navigate_location(
                            &value.as_string(),
                            LocationNavigationKind::HrefSet,
                        )?,
                        DomProp::LocationProtocol => {
                            self.set_location_property("protocol", value.clone())?
                        }
                        DomProp::LocationHost => {
                            self.set_location_property("host", value.clone())?
                        }
                        DomProp::LocationHostname => {
                            self.set_location_property("hostname", value.clone())?
                        }
                        DomProp::LocationPort => {
                            self.set_location_property("port", value.clone())?
                        }
                        DomProp::LocationPathname => {
                            self.set_location_property("pathname", value.clone())?
                        }
                        DomProp::LocationSearch => {
                            self.set_location_property("search", value.clone())?
                        }
                        DomProp::LocationHash => {
                            self.set_location_property("hash", value.clone())?
                        }
                        DomProp::HistoryScrollRestoration => {
                            self.set_history_property("scrollRestoration", value.clone())?
                        }
                        DomProp::OffsetWidth
                        | DomProp::OffsetHeight
                        | DomProp::OffsetLeft
                        | DomProp::OffsetTop
                        | DomProp::ScrollWidth
                        | DomProp::ScrollHeight
                        | DomProp::ScrollLeft
                        | DomProp::ScrollTop
                        | DomProp::ActiveElement
                        | DomProp::CharacterSet
                        | DomProp::CompatMode
                        | DomProp::ContentType
                        | DomProp::ReadyState
                        | DomProp::Referrer
                        | DomProp::Url
                        | DomProp::DocumentUri
                        | DomProp::LocationOrigin
                        | DomProp::LocationAncestorOrigins
                        | DomProp::History
                        | DomProp::HistoryLength
                        | DomProp::HistoryState
                        | DomProp::DefaultView
                        | DomProp::Hidden
                        | DomProp::VisibilityState
                        | DomProp::Forms
                        | DomProp::Images
                        | DomProp::Links
                        | DomProp::Scripts
                        | DomProp::Children
                        | DomProp::ChildElementCount
                        | DomProp::FirstElementChild
                        | DomProp::LastElementChild
                        | DomProp::CurrentScript
                        | DomProp::FormsLength
                        | DomProp::ImagesLength
                        | DomProp::LinksLength
                        | DomProp::ScriptsLength
                        | DomProp::ChildrenLength => {
                            let call = self.describe_dom_prop(prop);
                            return Err(Error::ScriptRuntime(format!("{call} is read-only")));
                        }
                        DomProp::Dataset(key) => {
                            self.dom.dataset_set(node, key, &value.as_string())?
                        }
                        DomProp::Style(prop) => {
                            self.dom.style_set(node, prop, &value.as_string())?
                        }
                    }
                }
                Stmt::ClassListCall {
                    target,
                    method,
                    class_names,
                    force,
                } => {
                    let node = self.resolve_dom_query_required_runtime(target, env)?;
                    match method {
                        ClassListMethod::Add => {
                            for class_name in class_names {
                                self.dom.class_add(node, class_name)?;
                            }
                        }
                        ClassListMethod::Remove => {
                            for class_name in class_names {
                                self.dom.class_remove(node, class_name)?;
                            }
                        }
                        ClassListMethod::Toggle => {
                            let class_name = class_names.first().ok_or_else(|| {
                                Error::ScriptRuntime("toggle requires a class name".into())
                            })?;
                            if let Some(force_expr) = force {
                                let force_value = self
                                    .eval_expr(force_expr, env, event_param, event)?
                                    .truthy();
                                if force_value {
                                    self.dom.class_add(node, class_name)?;
                                } else {
                                    self.dom.class_remove(node, class_name)?;
                                }
                            } else {
                                let _ = self.dom.class_toggle(node, class_name)?;
                            }
                        }
                    }
                }
                Stmt::ClassListForEach {
                    target,
                    item_var,
                    index_var,
                    body,
                } => {
                    let node = self.resolve_dom_query_required_runtime(target, env)?;
                    let classes = class_tokens(self.dom.attr(node, "class").as_deref());
                    let prev_item = env.get(item_var).cloned();
                    let prev_index = index_var.as_ref().and_then(|v| env.get(v).cloned());

                    for (idx, class_name) in classes.iter().enumerate() {
                        env.insert(item_var.clone(), Value::String(class_name.clone()));
                        if let Some(index_var) = index_var {
                            env.insert(index_var.clone(), Value::Number(idx as i64));
                        }
                        match self.execute_stmts(body, event_param, event, env)? {
                            ExecFlow::Continue => {}
                            ExecFlow::Break => break,
                            ExecFlow::ContinueLoop => continue,
                            ExecFlow::Return => return Ok(ExecFlow::Return),
                        }
                    }

                    if let Some(prev) = prev_item {
                        env.insert(item_var.clone(), prev);
                    } else {
                        env.remove(item_var);
                    }
                    if let Some(index_var) = index_var {
                        if let Some(prev) = prev_index {
                            env.insert(index_var.clone(), prev);
                        } else {
                            env.remove(index_var);
                        }
                    }
                }
                Stmt::DomSetAttribute {
                    target,
                    name,
                    value,
                } => {
                    let node = self.resolve_dom_query_required_runtime(target, env)?;
                    let value = self.eval_expr(value, env, event_param, event)?;
                    self.dom.set_attr(node, name, &value.as_string())?;
                }
                Stmt::DomRemoveAttribute { target, name } => {
                    let node = self.resolve_dom_query_required_runtime(target, env)?;
                    self.dom.remove_attr(node, name)?;
                }
                Stmt::NodeTreeMutation {
                    target,
                    method,
                    child,
                    reference,
                } => {
                    let target_node = self.resolve_dom_query_required_runtime(target, env)?;
                    let child = self.eval_expr(child, env, event_param, event)?;
                    let Value::Node(child) = child else {
                        return Err(Error::ScriptRuntime(
                            "before/after/replaceWith/append/appendChild/prepend/removeChild/insertBefore argument must be an element reference".into(),
                        ));
                    };
                    match method {
                        NodeTreeMethod::After => self.dom.insert_after(target_node, child)?,
                        NodeTreeMethod::Append => self.dom.append_child(target_node, child)?,
                        NodeTreeMethod::AppendChild => self.dom.append_child(target_node, child)?,
                        NodeTreeMethod::Before => {
                            let Some(parent) = self.dom.parent(target_node) else {
                                continue;
                            };
                            self.dom.insert_before(parent, child, target_node)?;
                        }
                        NodeTreeMethod::ReplaceWith => {
                            self.dom.replace_with(target_node, child)?;
                        }
                        NodeTreeMethod::Prepend => self.dom.prepend_child(target_node, child)?,
                        NodeTreeMethod::RemoveChild => self.dom.remove_child(target_node, child)?,
                        NodeTreeMethod::InsertBefore => {
                            let Some(reference) = reference else {
                                return Err(Error::ScriptRuntime(
                                    "insertBefore requires reference node".into(),
                                ));
                            };
                            let reference = self.eval_expr(reference, env, event_param, event)?;
                            let Value::Node(reference) = reference else {
                                return Err(Error::ScriptRuntime(
                                    "insertBefore reference must be an element reference".into(),
                                ));
                            };
                            self.dom.insert_before(target_node, child, reference)?;
                        }
                    }
                }
                Stmt::InsertAdjacentElement {
                    target,
                    position,
                    node,
                } => {
                    let target_node = self.resolve_dom_query_required_runtime(target, env)?;
                    let node = self.eval_expr(node, env, event_param, event)?;
                    let Value::Node(node) = node else {
                        return Err(Error::ScriptRuntime(
                            "insertAdjacentElement second argument must be an element reference"
                                .into(),
                        ));
                    };
                    self.dom
                        .insert_adjacent_node(target_node, *position, node)?;
                }
                Stmt::InsertAdjacentText {
                    target,
                    position,
                    text,
                } => {
                    let target_node = self.resolve_dom_query_required_runtime(target, env)?;
                    let text = self.eval_expr(text, env, event_param, event)?;
                    if matches!(
                        position,
                        InsertAdjacentPosition::BeforeBegin | InsertAdjacentPosition::AfterEnd
                    ) && self.dom.parent(target_node).is_none()
                    {
                        continue;
                    }
                    let text_node = self.dom.create_detached_text(text.as_string());
                    self.dom
                        .insert_adjacent_node(target_node, *position, text_node)?;
                }
                Stmt::InsertAdjacentHTML {
                    target,
                    position,
                    html,
                } => {
                    let target_node = self.resolve_dom_query_required_runtime(target, env)?;
                    let position = self.eval_expr(position, env, event_param, event)?;
                    let position = resolve_insert_adjacent_position(&position.as_string())?;
                    let html = self.eval_expr(html, env, event_param, event)?;
                    self.dom
                        .insert_adjacent_html(target_node, position, &html.as_string())?;
                }
                Stmt::SetTimeout { handler, delay_ms } => {
                    let delay = self.eval_expr(delay_ms, env, event_param, event)?;
                    let delay = Self::value_to_i64(&delay);
                    let callback_args = handler
                        .args
                        .iter()
                        .map(|arg| self.eval_expr(arg, env, event_param, event))
                        .collect::<Result<Vec<_>>>()?;
                    let _ =
                        self.schedule_timeout(handler.callback.clone(), delay, callback_args, env);
                }
                Stmt::SetInterval { handler, delay_ms } => {
                    let interval = self.eval_expr(delay_ms, env, event_param, event)?;
                    let interval = Self::value_to_i64(&interval);
                    let callback_args = handler
                        .args
                        .iter()
                        .map(|arg| self.eval_expr(arg, env, event_param, event))
                        .collect::<Result<Vec<_>>>()?;
                    let _ = self.schedule_interval(
                        handler.callback.clone(),
                        interval,
                        callback_args,
                        env,
                    );
                }
                Stmt::QueueMicrotask { handler } => {
                    self.queue_microtask(handler.clone(), env);
                }
                Stmt::ClearTimeout { timer_id } => {
                    let timer_id = self.eval_expr(timer_id, env, event_param, event)?;
                    let timer_id = Self::value_to_i64(&timer_id);
                    self.clear_timeout(timer_id);
                }
                Stmt::NodeRemove { target } => {
                    let node = self.resolve_dom_query_required_runtime(target, env)?;
                    if let Some(active) = self.active_element {
                        if active == node || self.dom.is_descendant_of(active, node) {
                            self.active_element = None;
                            self.dom.set_active_element(None);
                        }
                    }
                    if let Some(active_pseudo) = self.dom.active_pseudo_element() {
                        if active_pseudo == node || self.dom.is_descendant_of(active_pseudo, node) {
                            self.dom.set_active_pseudo_element(None);
                        }
                    }
                    self.dom.remove_node(node)?;
                }
                Stmt::ForEach {
                    target,
                    selector,
                    item_var,
                    index_var,
                    body,
                } => {
                    let items = if let Some(target) = target {
                        match self.resolve_dom_query_runtime(target, env)? {
                            Some(target_node) => {
                                self.dom.query_selector_all_from(&target_node, selector)?
                            }
                            None => Vec::new(),
                        }
                    } else {
                        self.dom.query_selector_all(selector)?
                    };
                    let prev_item = env.get(item_var).cloned();
                    let prev_index = index_var.as_ref().and_then(|v| env.get(v).cloned());

                    for (idx, node) in items.iter().enumerate() {
                        env.insert(item_var.clone(), Value::Node(*node));
                        if let Some(index_var) = index_var {
                            env.insert(index_var.clone(), Value::Number(idx as i64));
                        }
                        match self.execute_stmts(body, event_param, event, env)? {
                            ExecFlow::Continue => {}
                            ExecFlow::Break => break,
                            ExecFlow::ContinueLoop => continue,
                            ExecFlow::Return => return Ok(ExecFlow::Return),
                        }
                    }

                    if let Some(prev) = prev_item {
                        env.insert(item_var.clone(), prev);
                    } else {
                        env.remove(item_var);
                    }
                    if let Some(index_var) = index_var {
                        if let Some(prev) = prev_index {
                            env.insert(index_var.clone(), prev);
                        } else {
                            env.remove(index_var);
                        }
                    }
                }
                Stmt::ArrayForEach { target, callback } => {
                    let target_value = env.get(target).cloned();
                    match target_value {
                        Some(Value::Array(values)) => {
                            let input = values.borrow().clone();
                            for (idx, item) in input.into_iter().enumerate() {
                                self.execute_array_callback_in_env(
                                    callback,
                                    &[
                                        item,
                                        Value::Number(idx as i64),
                                        Value::Array(values.clone()),
                                    ],
                                    env,
                                    event,
                                )?;
                            }
                        }
                        Some(Value::Map(map)) => {
                            let snapshot = map.borrow().entries.clone();
                            for (key, value) in snapshot {
                                self.execute_array_callback_in_env(
                                    callback,
                                    &[value, key, Value::Map(map.clone())],
                                    env,
                                    event,
                                )?;
                            }
                        }
                        Some(Value::Set(set)) => {
                            let snapshot = set.borrow().values.clone();
                            for value in snapshot {
                                self.execute_array_callback_in_env(
                                    callback,
                                    &[value.clone(), value, Value::Set(set.clone())],
                                    env,
                                    event,
                                )?;
                            }
                        }
                        Some(_) => {
                            return Err(Error::ScriptRuntime(format!(
                                "variable '{}' is not an array",
                                target
                            )));
                        }
                        None => {
                            return Err(Error::ScriptRuntime(format!(
                                "unknown variable: {}",
                                target
                            )));
                        }
                    }
                }
                Stmt::For {
                    init,
                    cond,
                    post,
                    body,
                } => {
                    if let Some(init) = init.as_deref() {
                        match self.execute_stmts(
                            std::slice::from_ref(init),
                            event_param,
                            event,
                            env,
                        )? {
                            ExecFlow::Continue => {}
                            ExecFlow::Return => return Ok(ExecFlow::Return),
                            ExecFlow::Break => {
                                return Err(Error::ScriptRuntime(
                                    "break statement outside of loop".into(),
                                ));
                            }
                            ExecFlow::ContinueLoop => {
                                return Err(Error::ScriptRuntime(
                                    "continue statement outside of loop".into(),
                                ));
                            }
                        }
                    }

                    loop {
                        let should_run = if let Some(cond) = cond {
                            self.eval_expr(cond, env, event_param, event)?.truthy()
                        } else {
                            true
                        };
                        if !should_run {
                            break;
                        }

                        match self.execute_stmts(body, event_param, event, env)? {
                            ExecFlow::Continue => {}
                            ExecFlow::ContinueLoop => {
                                if let Some(post) = post.as_deref() {
                                    match self.execute_stmts(
                                        std::slice::from_ref(post),
                                        event_param,
                                        event,
                                        env,
                                    )? {
                                        ExecFlow::Continue => {}
                                        ExecFlow::Return => return Ok(ExecFlow::Return),
                                        ExecFlow::Break | ExecFlow::ContinueLoop => {
                                            return Err(Error::ScriptRuntime(
                                                "invalid loop control in post expression".into(),
                                            ));
                                        }
                                    }
                                }
                                continue;
                            }
                            ExecFlow::Break => break,
                            ExecFlow::Return => return Ok(ExecFlow::Return),
                        }
                        if let Some(post) = post.as_deref() {
                            match self.execute_stmts(
                                std::slice::from_ref(post),
                                event_param,
                                event,
                                env,
                            )? {
                                ExecFlow::Continue => {}
                                ExecFlow::Return => return Ok(ExecFlow::Return),
                                ExecFlow::Break | ExecFlow::ContinueLoop => {
                                    return Err(Error::ScriptRuntime(
                                        "invalid loop control in post expression".into(),
                                    ));
                                }
                            }
                        }
                    }
                }
                Stmt::ForIn {
                    item_var,
                    iterable,
                    body,
                } => {
                    let iterable = self.eval_expr(iterable, env, event_param, event)?;
                    let items = match iterable {
                        Value::NodeList(nodes) => (0..nodes.len()).collect::<Vec<_>>(),
                        Value::Array(values) => {
                            let values = values.borrow();
                            (0..values.len()).collect::<Vec<_>>()
                        }
                        Value::Null | Value::Undefined => Vec::new(),
                        _ => {
                            return Err(Error::ScriptRuntime(
                                "for...in iterable must be a NodeList or Array".into(),
                            ));
                        }
                    };

                    let prev_item = env.get(item_var).cloned();
                    for idx in items {
                        env.insert(item_var.clone(), Value::Number(idx as i64));
                        match self.execute_stmts(body, event_param, event, env)? {
                            ExecFlow::Continue => {}
                            ExecFlow::ContinueLoop => continue,
                            ExecFlow::Break => break,
                            ExecFlow::Return => return Ok(ExecFlow::Return),
                        }
                    }
                    if let Some(prev) = prev_item {
                        env.insert(item_var.clone(), prev);
                    } else {
                        env.remove(item_var);
                    }
                }
                Stmt::ForOf {
                    item_var,
                    iterable,
                    body,
                } => {
                    let iterable = self.eval_expr(iterable, env, event_param, event)?;
                    let nodes = match iterable {
                        Value::NodeList(nodes) => {
                            nodes.into_iter().map(Value::Node).collect::<Vec<_>>()
                        }
                        Value::Array(values) => values.borrow().clone(),
                        Value::Map(map) => self.map_entries_array(&map),
                        Value::Set(set) => set.borrow().values.clone(),
                        Value::Null | Value::Undefined => Vec::new(),
                        _ => {
                            return Err(Error::ScriptRuntime(
                                "for...of iterable must be a NodeList, Array, Map, or Set".into(),
                            ));
                        }
                    };

                    let prev_item = env.get(item_var).cloned();
                    for item in nodes {
                        env.insert(item_var.clone(), item);
                        match self.execute_stmts(body, event_param, event, env)? {
                            ExecFlow::Continue => {}
                            ExecFlow::ContinueLoop => continue,
                            ExecFlow::Break => break,
                            ExecFlow::Return => return Ok(ExecFlow::Return),
                        }
                    }
                    if let Some(prev) = prev_item {
                        env.insert(item_var.clone(), prev);
                    } else {
                        env.remove(item_var);
                    }
                }
                Stmt::While { cond, body } => {
                    while self.eval_expr(cond, env, event_param, event)?.truthy() {
                        match self.execute_stmts(body, event_param, event, env)? {
                            ExecFlow::Continue => {}
                            ExecFlow::ContinueLoop => continue,
                            ExecFlow::Break => break,
                            ExecFlow::Return => return Ok(ExecFlow::Return),
                        }
                    }
                }
                Stmt::DoWhile { cond, body } => loop {
                    match self.execute_stmts(body, event_param, event, env)? {
                        ExecFlow::Continue => {}
                        ExecFlow::ContinueLoop => {}
                        ExecFlow::Break => break,
                        ExecFlow::Return => return Ok(ExecFlow::Return),
                    }
                    if !self.eval_expr(cond, env, event_param, event)?.truthy() {
                        break;
                    }
                },
                Stmt::If {
                    cond,
                    then_stmts,
                    else_stmts,
                } => {
                    let cond = self.eval_expr(cond, env, event_param, event)?;
                    if cond.truthy() {
                        match self.execute_stmts(then_stmts, event_param, event, env)? {
                            ExecFlow::Continue => {}
                            flow => return Ok(flow),
                        }
                    } else {
                        match self.execute_stmts(else_stmts, event_param, event, env)? {
                            ExecFlow::Continue => {}
                            flow => return Ok(flow),
                        }
                    }
                }
                Stmt::Try {
                    try_stmts,
                    catch_binding,
                    catch_stmts,
                    finally_stmts,
                } => {
                    let mut completion = self.execute_stmts(try_stmts, event_param, event, env);

                    if let Err(err) = completion {
                        if let Some(catch_stmts) = catch_stmts {
                            let caught = Self::error_to_catch_value(err)?;
                            completion = self.execute_catch_block(
                                catch_binding,
                                catch_stmts,
                                caught,
                                event_param,
                                event,
                                env,
                            );
                        } else {
                            completion = Err(err);
                        }
                    }

                    if let Some(finally_stmts) = finally_stmts {
                        match self.execute_stmts(finally_stmts, event_param, event, env) {
                            Ok(ExecFlow::Continue) => {}
                            Ok(flow) => return Ok(flow),
                            Err(err) => return Err(err),
                        }
                    }

                    match completion {
                        Ok(ExecFlow::Continue) => {}
                        Ok(flow) => return Ok(flow),
                        Err(err) => return Err(err),
                    }
                }
                Stmt::Throw { value } => {
                    let thrown = self.eval_expr(value, env, event_param, event)?;
                    return Err(Error::ScriptThrown(ThrownValue::new(thrown)));
                }
                Stmt::Return { value } => {
                    let return_value = if let Some(value) = value {
                        self.eval_expr(value, env, event_param, event)?
                    } else {
                        Value::Undefined
                    };
                    env.insert(INTERNAL_RETURN_SLOT.to_string(), return_value);
                    return Ok(ExecFlow::Return);
                }
                Stmt::Break => {
                    return Ok(ExecFlow::Break);
                }
                Stmt::Continue => {
                    return Ok(ExecFlow::ContinueLoop);
                }
                Stmt::EventCall { event_var, method } => {
                    if let Some(param) = event_param {
                        if param == event_var {
                            match method {
                                EventMethod::PreventDefault => {
                                    event.default_prevented = true;
                                }
                                EventMethod::StopPropagation => {
                                    event.propagation_stopped = true;
                                }
                                EventMethod::StopImmediatePropagation => {
                                    event.immediate_propagation_stopped = true;
                                    event.propagation_stopped = true;
                                }
                            }
                        }
                    }
                }
                Stmt::ListenerMutation {
                    target,
                    op,
                    event_type,
                    capture,
                    handler,
                } => {
                    let node = self.resolve_dom_query_required_runtime(target, env)?;
                    match op {
                        ListenerRegistrationOp::Add => {
                            self.listeners.add(
                                node,
                                event_type.clone(),
                                Listener {
                                    capture: *capture,
                                    handler: handler.clone(),
                                },
                            );
                        }
                        ListenerRegistrationOp::Remove => {
                            let _ = self.listeners.remove(node, event_type, *capture, handler);
                        }
                    }
                }
                Stmt::DomMethodCall {
                    target,
                    method,
                    arg,
                } => {
                    let node = self.resolve_dom_query_required_runtime(target, env)?;
                    let arg_value = arg
                        .as_ref()
                        .map(|expr| self.eval_expr(expr, env, event_param, event))
                        .transpose()?;
                    match method {
                        DomMethod::Focus => self.focus_node_with_env(node, env)?,
                        DomMethod::Blur => self.blur_node_with_env(node, env)?,
                        DomMethod::Click => self.click_node_with_env(node, env)?,
                        DomMethod::Submit => self.submit_form_with_env(node, env)?,
                        DomMethod::Reset => self.reset_form_with_env(node, env)?,
                        DomMethod::ScrollIntoView => {
                            self.scroll_into_view_node_with_env(node, env)?
                        }
                        DomMethod::Show => self.show_dialog_with_env(node, false, env)?,
                        DomMethod::ShowModal => self.show_dialog_with_env(node, true, env)?,
                        DomMethod::Close => self.close_dialog_with_env(node, arg_value, env)?,
                        DomMethod::RequestClose => {
                            self.request_close_dialog_with_env(node, arg_value, env)?
                        }
                    }
                }
                Stmt::DispatchEvent { target, event_type } => {
                    let node = self.resolve_dom_query_required_runtime(target, env)?;
                    let event_name = self
                        .eval_expr(event_type, env, event_param, event)?
                        .as_string();
                    if event_name.is_empty() {
                        return Err(Error::ScriptRuntime(
                            "dispatchEvent requires non-empty event type".into(),
                        ));
                    }
                    let _ = self.dispatch_event_with_env(node, &event_name, env, false)?;
                }
                Stmt::Expr(expr) => {
                    let _ = self.eval_expr(expr, env, event_param, event)?;
                }
            }
        }

        Ok(ExecFlow::Continue)
    }

    fn bind_timer_id_to_task_env(&mut self, name: &str, expr: &Expr, value: &Value) {
        if !matches!(
            expr,
            Expr::SetTimeout { .. } | Expr::SetInterval { .. } | Expr::RequestAnimationFrame { .. }
        ) {
            return;
        }
        let Value::Number(timer_id) = value else {
            return;
        };
        for task in self
            .task_queue
            .iter_mut()
            .filter(|task| task.id == *timer_id)
        {
            task.env.insert(name.to_string(), value.clone());
        }
    }

    fn eval_expr(
        &mut self,
        expr: &Expr,
        env: &HashMap<String, Value>,
        event_param: &Option<String>,
        event: &EventState,
    ) -> Result<Value> {
        match expr {
            Expr::String(value) => Ok(Value::String(value.clone())),
            Expr::Bool(value) => Ok(Value::Bool(*value)),
            Expr::Null => Ok(Value::Null),
            Expr::Undefined => Ok(Value::Undefined),
            Expr::Number(value) => Ok(Value::Number(*value)),
            Expr::Float(value) => Ok(Value::Float(*value)),
            Expr::BigInt(value) => Ok(Value::BigInt(value.clone())),
            Expr::DateNow => Ok(Value::Number(self.now_ms)),
            Expr::PerformanceNow => Ok(Value::Float(self.now_ms as f64)),
            Expr::DateNew { value } => {
                let timestamp_ms = if let Some(value) = value {
                    let value = self.eval_expr(value, env, event_param, event)?;
                    self.coerce_date_timestamp_ms(&value)
                } else {
                    self.now_ms
                };
                Ok(Self::new_date_value(timestamp_ms))
            }
            Expr::DateParse(value) => {
                let value = self.eval_expr(value, env, event_param, event)?.as_string();
                if let Some(timestamp_ms) = Self::parse_date_string_to_epoch_ms(&value) {
                    Ok(Value::Number(timestamp_ms))
                } else {
                    Ok(Value::Float(f64::NAN))
                }
            }
            Expr::DateUtc { args } => {
                let mut values = Vec::with_capacity(args.len());
                for arg in args {
                    let value = self.eval_expr(arg, env, event_param, event)?;
                    values.push(Self::value_to_i64(&value));
                }

                let mut year = values.first().copied().unwrap_or(0);
                if (0..=99).contains(&year) {
                    year += 1900;
                }
                let month = values.get(1).copied().unwrap_or(0);
                let day = values.get(2).copied().unwrap_or(1);
                let hour = values.get(3).copied().unwrap_or(0);
                let minute = values.get(4).copied().unwrap_or(0);
                let second = values.get(5).copied().unwrap_or(0);
                let millisecond = values.get(6).copied().unwrap_or(0);

                Ok(Value::Number(Self::utc_timestamp_ms_from_components(
                    year,
                    month,
                    day,
                    hour,
                    minute,
                    second,
                    millisecond,
                )))
            }
            Expr::DateGetTime(target) => {
                let date = self.resolve_date_from_env(env, target)?;
                Ok(Value::Number(*date.borrow()))
            }
            Expr::DateSetTime { target, value } => {
                let date = self.resolve_date_from_env(env, target)?;
                let value = self.eval_expr(value, env, event_param, event)?;
                let timestamp_ms = Self::value_to_i64(&value);
                *date.borrow_mut() = timestamp_ms;
                Ok(Value::Number(timestamp_ms))
            }
            Expr::DateToIsoString(target) => {
                let date = self.resolve_date_from_env(env, target)?;
                Ok(Value::String(Self::format_iso_8601_utc(*date.borrow())))
            }
            Expr::DateGetFullYear(target) => {
                let date = self.resolve_date_from_env(env, target)?;
                let (year, ..) = Self::date_components_utc(*date.borrow());
                Ok(Value::Number(year))
            }
            Expr::DateGetMonth(target) => {
                let date = self.resolve_date_from_env(env, target)?;
                let (_, month, ..) = Self::date_components_utc(*date.borrow());
                Ok(Value::Number((month as i64) - 1))
            }
            Expr::DateGetDate(target) => {
                let date = self.resolve_date_from_env(env, target)?;
                let (_, _, day, ..) = Self::date_components_utc(*date.borrow());
                Ok(Value::Number(day as i64))
            }
            Expr::DateGetHours(target) => {
                let date = self.resolve_date_from_env(env, target)?;
                let (_, _, _, hour, ..) = Self::date_components_utc(*date.borrow());
                Ok(Value::Number(hour as i64))
            }
            Expr::DateGetMinutes(target) => {
                let date = self.resolve_date_from_env(env, target)?;
                let (_, _, _, _, minute, ..) = Self::date_components_utc(*date.borrow());
                Ok(Value::Number(minute as i64))
            }
            Expr::DateGetSeconds(target) => {
                let date = self.resolve_date_from_env(env, target)?;
                let (_, _, _, _, _, second, _) = Self::date_components_utc(*date.borrow());
                Ok(Value::Number(second as i64))
            }
            Expr::IntlFormatterConstruct {
                kind,
                locales,
                options,
                called_with_new: _called_with_new,
            } => {
                let requested_locales = if let Some(locales) = locales {
                    let value = self.eval_expr(locales, env, event_param, event)?;
                    self.intl_collect_locales(&value)?
                } else {
                    Vec::new()
                };
                let locale = Self::intl_select_locale_for_formatter(*kind, &requested_locales);
                match kind {
                    IntlFormatterKind::Collator => {
                        let options = options
                            .as_ref()
                            .map(|value| self.eval_expr(value, env, event_param, event))
                            .transpose()?;
                        let (case_first, sensitivity) =
                            self.intl_collator_options_from_value(options.as_ref())?;
                        Ok(self.new_intl_collator_value(locale, case_first, sensitivity))
                    }
                    IntlFormatterKind::DateTimeFormat => {
                        let options = options
                            .as_ref()
                            .map(|value| self.eval_expr(value, env, event_param, event))
                            .transpose()?;
                        let options =
                            self.intl_date_time_options_from_value(&locale, options.as_ref())?;
                        Ok(self.new_intl_date_time_formatter_value(locale, options))
                    }
                    IntlFormatterKind::DisplayNames => {
                        let options = options
                            .as_ref()
                            .map(|value| self.eval_expr(value, env, event_param, event))
                            .transpose()?;
                        let options =
                            self.intl_display_names_options_from_value(options.as_ref())?;
                        Ok(self.new_intl_display_names_value(locale, options))
                    }
                    IntlFormatterKind::DurationFormat => {
                        let options = options
                            .as_ref()
                            .map(|value| self.eval_expr(value, env, event_param, event))
                            .transpose()?;
                        let options = self.intl_duration_options_from_value(options.as_ref())?;
                        Ok(self.new_intl_duration_formatter_value(locale, options))
                    }
                    IntlFormatterKind::ListFormat => {
                        let options = options
                            .as_ref()
                            .map(|value| self.eval_expr(value, env, event_param, event))
                            .transpose()?;
                        let options = self.intl_list_options_from_value(options.as_ref())?;
                        Ok(self.new_intl_list_formatter_value(locale, options))
                    }
                    IntlFormatterKind::PluralRules => {
                        let options = options
                            .as_ref()
                            .map(|value| self.eval_expr(value, env, event_param, event))
                            .transpose()?;
                        let options =
                            self.intl_plural_rules_options_from_value(options.as_ref())?;
                        Ok(self.new_intl_plural_rules_value(locale, options))
                    }
                    IntlFormatterKind::RelativeTimeFormat => {
                        let options = options
                            .as_ref()
                            .map(|value| self.eval_expr(value, env, event_param, event))
                            .transpose()?;
                        let options =
                            self.intl_relative_time_options_from_value(options.as_ref())?;
                        Ok(self.new_intl_relative_time_formatter_value(locale, options))
                    }
                    IntlFormatterKind::Segmenter => {
                        let options = options
                            .as_ref()
                            .map(|value| self.eval_expr(value, env, event_param, event))
                            .transpose()?;
                        let options = self.intl_segmenter_options_from_value(options.as_ref())?;
                        Ok(self.new_intl_segmenter_value(locale, options))
                    }
                    _ => Ok(self.new_intl_formatter_value(*kind, locale)),
                }
            }
            Expr::IntlFormat { formatter, value } => {
                let formatter = self.eval_expr(formatter, env, event_param, event)?;
                let (kind, locale) = self.resolve_intl_formatter(&formatter)?;
                let value = if let Some(value) = value {
                    self.eval_expr(value, env, event_param, event)?
                } else {
                    Value::Undefined
                };
                match kind {
                    IntlFormatterKind::NumberFormat => {
                        Ok(Value::String(Self::intl_format_number_for_locale(
                            Self::coerce_number_for_global(&value),
                            &locale,
                        )))
                    }
                    IntlFormatterKind::DateTimeFormat => {
                        let (_, options) = self.resolve_intl_date_time_options(&formatter)?;
                        let timestamp_ms = if matches!(value, Value::Undefined) {
                            self.now_ms
                        } else {
                            self.coerce_date_timestamp_ms(&value)
                        };
                        Ok(Value::String(self.intl_format_date_time(
                            timestamp_ms,
                            &locale,
                            &options,
                        )))
                    }
                    IntlFormatterKind::DisplayNames => Err(Error::ScriptRuntime(
                        "Intl.DisplayNames does not support format()".into(),
                    )),
                    IntlFormatterKind::DurationFormat => {
                        let (_, options) = self.resolve_intl_duration_options(&formatter)?;
                        Ok(Value::String(
                            self.intl_format_duration(&locale, &options, &value)?,
                        ))
                    }
                    IntlFormatterKind::ListFormat => {
                        let (_, options) = self.resolve_intl_list_options(&formatter)?;
                        Ok(Value::String(
                            self.intl_format_list(&locale, &options, &value)?,
                        ))
                    }
                    IntlFormatterKind::PluralRules => Err(Error::ScriptRuntime(
                        "Intl.PluralRules does not support format()".into(),
                    )),
                    IntlFormatterKind::RelativeTimeFormat => Err(Error::ScriptRuntime(
                        "Intl.RelativeTimeFormat.format requires value and unit arguments".into(),
                    )),
                    IntlFormatterKind::Segmenter => Err(Error::ScriptRuntime(
                        "Intl.Segmenter does not support format()".into(),
                    )),
                    IntlFormatterKind::Collator => Err(Error::ScriptRuntime(
                        "Intl.Collator does not support format()".into(),
                    )),
                }
            }
            Expr::IntlFormatGetter { formatter } => {
                let formatter = self.eval_expr(formatter, env, event_param, event)?;
                let (kind, locale) = self.resolve_intl_formatter(&formatter)?;
                match kind {
                    IntlFormatterKind::DateTimeFormat => {
                        let (_, options) = self.resolve_intl_date_time_options(&formatter)?;
                        Ok(self.new_intl_date_time_format_callable(locale, options))
                    }
                    IntlFormatterKind::NumberFormat => {
                        Ok(self.new_intl_number_format_callable(locale))
                    }
                    IntlFormatterKind::DurationFormat => {
                        let (_, options) = self.resolve_intl_duration_options(&formatter)?;
                        Ok(self.new_intl_duration_format_callable(locale, options))
                    }
                    IntlFormatterKind::ListFormat => {
                        let (_, options) = self.resolve_intl_list_options(&formatter)?;
                        Ok(self.new_intl_list_format_callable(locale, options))
                    }
                    IntlFormatterKind::PluralRules => Err(Error::ScriptRuntime(
                        "Intl.PluralRules does not support format getter".into(),
                    )),
                    IntlFormatterKind::RelativeTimeFormat => Err(Error::ScriptRuntime(
                        "Intl.RelativeTimeFormat does not support format getter".into(),
                    )),
                    IntlFormatterKind::Segmenter => Err(Error::ScriptRuntime(
                        "Intl.Segmenter does not support format getter".into(),
                    )),
                    IntlFormatterKind::DisplayNames => Err(Error::ScriptRuntime(
                        "Intl.DisplayNames does not support format getter".into(),
                    )),
                    IntlFormatterKind::Collator => Err(Error::ScriptRuntime(
                        "Intl.Collator does not support format getter".into(),
                    )),
                }
            }
            Expr::IntlCollatorCompare {
                collator,
                left,
                right,
            } => {
                let collator = self.eval_expr(collator, env, event_param, event)?;
                let (locale, case_first, sensitivity) =
                    self.resolve_intl_collator_options(&collator)?;
                let left = self.eval_expr(left, env, event_param, event)?.as_string();
                let right = self.eval_expr(right, env, event_param, event)?.as_string();
                Ok(Value::Number(Self::intl_collator_compare_strings(
                    &left,
                    &right,
                    &locale,
                    &case_first,
                    &sensitivity,
                )))
            }
            Expr::IntlCollatorCompareGetter { collator } => {
                let collator = self.eval_expr(collator, env, event_param, event)?;
                let (locale, case_first, sensitivity) =
                    self.resolve_intl_collator_options(&collator)?;
                Ok(self.new_intl_collator_compare_callable(locale, case_first, sensitivity))
            }
            Expr::IntlDateTimeFormatToParts { formatter, value } => {
                let formatter = self.eval_expr(formatter, env, event_param, event)?;
                let (kind, locale) = self.resolve_intl_formatter(&formatter)?;
                match kind {
                    IntlFormatterKind::DateTimeFormat => {
                        let (_, options) = self.resolve_intl_date_time_options(&formatter)?;
                        let value = if let Some(value) = value {
                            self.eval_expr(value, env, event_param, event)?
                        } else {
                            Value::Undefined
                        };
                        let timestamp_ms = if matches!(value, Value::Undefined) {
                            self.now_ms
                        } else {
                            self.coerce_date_timestamp_ms(&value)
                        };
                        let parts =
                            self.intl_format_date_time_to_parts(timestamp_ms, &locale, &options);
                        Ok(self.intl_date_time_parts_to_value(&parts, None))
                    }
                    IntlFormatterKind::DurationFormat => {
                        let (_, options) = self.resolve_intl_duration_options(&formatter)?;
                        let value = if let Some(value) = value {
                            self.eval_expr(value, env, event_param, event)?
                        } else {
                            Value::Undefined
                        };
                        let parts = self.intl_format_duration_to_parts(&locale, &options, &value)?;
                        Ok(self.intl_date_time_parts_to_value(&parts, None))
                    }
                    IntlFormatterKind::ListFormat => {
                        let (_, options) = self.resolve_intl_list_options(&formatter)?;
                        let value = if let Some(value) = value {
                            self.eval_expr(value, env, event_param, event)?
                        } else {
                            Value::Undefined
                        };
                        let parts = self.intl_format_list_to_parts(&locale, &options, &value)?;
                        Ok(self.intl_date_time_parts_to_value(&parts, None))
                    }
                    _ => Err(Error::ScriptRuntime(
                        "Intl formatter formatToParts requires an Intl.DateTimeFormat, Intl.DurationFormat, or Intl.ListFormat instance"
                            .into(),
                    )),
                }
            }
            Expr::IntlDateTimeFormatRange {
                formatter,
                start,
                end,
            } => {
                let formatter = self.eval_expr(formatter, env, event_param, event)?;
                let (kind, locale) = self.resolve_intl_formatter(&formatter)?;
                if kind != IntlFormatterKind::DateTimeFormat {
                    return Err(Error::ScriptRuntime(
                        "Intl.DateTimeFormat.formatRange requires an Intl.DateTimeFormat instance"
                            .into(),
                    ));
                }
                let (_, options) = self.resolve_intl_date_time_options(&formatter)?;
                let start = self.eval_expr(start, env, event_param, event)?;
                let end = self.eval_expr(end, env, event_param, event)?;
                let start_ms = self.coerce_date_timestamp_ms(&start);
                let end_ms = self.coerce_date_timestamp_ms(&end);
                Ok(Value::String(self.intl_format_date_time_range(
                    start_ms, end_ms, &locale, &options,
                )))
            }
            Expr::IntlDateTimeFormatRangeToParts {
                formatter,
                start,
                end,
            } => {
                let formatter = self.eval_expr(formatter, env, event_param, event)?;
                let (kind, locale) = self.resolve_intl_formatter(&formatter)?;
                if kind != IntlFormatterKind::DateTimeFormat {
                    return Err(Error::ScriptRuntime(
                        "Intl.DateTimeFormat.formatRangeToParts requires an Intl.DateTimeFormat instance"
                            .into(),
                    ));
                }
                let (_, options) = self.resolve_intl_date_time_options(&formatter)?;
                let start = self.eval_expr(start, env, event_param, event)?;
                let end = self.eval_expr(end, env, event_param, event)?;
                let start_ms = self.coerce_date_timestamp_ms(&start);
                let end_ms = self.coerce_date_timestamp_ms(&end);
                let (parts, sources) =
                    self.intl_format_date_time_range_to_parts(start_ms, end_ms, &locale, &options);
                Ok(self.intl_date_time_parts_to_value(&parts, Some(&sources)))
            }
            Expr::IntlDateTimeResolvedOptions { formatter } => {
                let formatter = self.eval_expr(formatter, env, event_param, event)?;
                let (kind, locale) = self.resolve_intl_formatter(&formatter)?;
                match kind {
                    IntlFormatterKind::DateTimeFormat => {
                        let (_, options) = self.resolve_intl_date_time_options(&formatter)?;
                        Ok(self.intl_date_time_resolved_options_value(locale, &options))
                    }
                    IntlFormatterKind::Collator => {
                        let (locale, case_first, sensitivity) =
                            self.resolve_intl_collator_options(&formatter)?;
                        Ok(Self::new_object_value(vec![
                            ("locale".into(), Value::String(locale)),
                            ("usage".into(), Value::String("sort".to_string())),
                            ("sensitivity".into(), Value::String(sensitivity)),
                            ("ignorePunctuation".into(), Value::Bool(false)),
                            ("collation".into(), Value::String("default".to_string())),
                            ("numeric".into(), Value::Bool(false)),
                            ("caseFirst".into(), Value::String(case_first)),
                        ]))
                    }
                    IntlFormatterKind::DisplayNames => {
                        let (_, options) = self.resolve_intl_display_names_options(&formatter)?;
                        Ok(self.intl_display_names_resolved_options_value(locale, &options))
                    }
                    IntlFormatterKind::DurationFormat => {
                        let (_, options) = self.resolve_intl_duration_options(&formatter)?;
                        Ok(self.intl_duration_resolved_options_value(locale, &options))
                    }
                    IntlFormatterKind::ListFormat => {
                        let (_, options) = self.resolve_intl_list_options(&formatter)?;
                        Ok(self.intl_list_resolved_options_value(locale, &options))
                    }
                    IntlFormatterKind::PluralRules => {
                        let (_, options) = self.resolve_intl_plural_rules_options(&formatter)?;
                        Ok(self.intl_plural_rules_resolved_options_value(locale, &options))
                    }
                    IntlFormatterKind::RelativeTimeFormat => {
                        let (_, options) = self.resolve_intl_relative_time_options(&formatter)?;
                        Ok(self.intl_relative_time_resolved_options_value(locale, &options))
                    }
                    IntlFormatterKind::Segmenter => {
                        let (_, options) = self.resolve_intl_segmenter_options(&formatter)?;
                        Ok(self.intl_segmenter_resolved_options_value(locale, &options))
                    }
                    IntlFormatterKind::NumberFormat => Err(Error::ScriptRuntime(
                        "Intl.NumberFormat.resolvedOptions is not implemented".into(),
                    )),
                }
            }
            Expr::IntlDisplayNamesOf {
                display_names,
                code,
            } => {
                let display_names = self.eval_expr(display_names, env, event_param, event)?;
                let code = self.eval_expr(code, env, event_param, event)?.as_string();
                let (locale, options) = self.resolve_intl_display_names_options(&display_names)?;
                self.intl_display_names_of(&locale, &options, &code)
            }
            Expr::IntlPluralRulesSelect {
                plural_rules,
                value,
            } => {
                let plural_rules = self.eval_expr(plural_rules, env, event_param, event)?;
                let value = self.eval_expr(value, env, event_param, event)?;
                let (locale, options) = self.resolve_intl_plural_rules_options(&plural_rules)?;
                Ok(Value::String(
                    self.intl_plural_rules_select(&locale, &options, &value),
                ))
            }
            Expr::IntlPluralRulesSelectRange {
                plural_rules,
                start,
                end,
            } => {
                let plural_rules = self.eval_expr(plural_rules, env, event_param, event)?;
                let start = self.eval_expr(start, env, event_param, event)?;
                let end = self.eval_expr(end, env, event_param, event)?;
                let (locale, options) = self.resolve_intl_plural_rules_options(&plural_rules)?;
                Ok(Value::String(self.intl_plural_rules_select_range(
                    &locale, &options, &start, &end,
                )))
            }
            Expr::IntlRelativeTimeFormat {
                formatter,
                value,
                unit,
            } => {
                let formatter = self.eval_expr(formatter, env, event_param, event)?;
                let value = self.eval_expr(value, env, event_param, event)?;
                let unit = self.eval_expr(unit, env, event_param, event)?;
                let (locale, options) = self.resolve_intl_relative_time_options(&formatter)?;
                Ok(Value::String(self.intl_format_relative_time(
                    &locale, &options, &value, &unit,
                )?))
            }
            Expr::IntlRelativeTimeFormatToParts {
                formatter,
                value,
                unit,
            } => {
                let formatter = self.eval_expr(formatter, env, event_param, event)?;
                let value = self.eval_expr(value, env, event_param, event)?;
                let unit = self.eval_expr(unit, env, event_param, event)?;
                let (locale, options) = self.resolve_intl_relative_time_options(&formatter)?;
                let parts =
                    self.intl_format_relative_time_to_parts(&locale, &options, &value, &unit)?;
                Ok(self.intl_relative_time_parts_to_value(&parts))
            }
            Expr::IntlSegmenterSegment { segmenter, value } => {
                let segmenter = self.eval_expr(segmenter, env, event_param, event)?;
                let value = self.eval_expr(value, env, event_param, event)?;
                let (locale, options) = self.resolve_intl_segmenter_options(&segmenter)?;
                let input = value.as_string();
                let segments = self.intl_segment_input(&locale, &options, &input);
                Ok(self.new_intl_segments_value(segments))
            }
            Expr::IntlStaticMethod { method, args } => match method {
                IntlStaticMethod::CollatorSupportedLocalesOf => {
                    if args.is_empty() || args.len() > 2 {
                        return Err(Error::ScriptRuntime(
                            "Intl.Collator.supportedLocalesOf requires locales and optional options"
                                .into(),
                        ));
                    }
                    let locales = self.eval_expr(&args[0], env, event_param, event)?;
                    let locales = self.intl_collect_locales(&locales)?;
                    let supported =
                        Self::intl_supported_locales(IntlFormatterKind::Collator, locales);
                    Ok(Self::new_array_value(supported))
                }
                IntlStaticMethod::DateTimeFormatSupportedLocalesOf => {
                    if args.is_empty() || args.len() > 2 {
                        return Err(Error::ScriptRuntime(
                            "Intl.DateTimeFormat.supportedLocalesOf requires locales and optional options"
                                .into(),
                        ));
                    }
                    let locales = self.eval_expr(&args[0], env, event_param, event)?;
                    let locales = self.intl_collect_locales(&locales)?;
                    let supported =
                        Self::intl_supported_locales(IntlFormatterKind::DateTimeFormat, locales);
                    Ok(Self::new_array_value(supported))
                }
                IntlStaticMethod::DisplayNamesSupportedLocalesOf => {
                    if args.is_empty() || args.len() > 2 {
                        return Err(Error::ScriptRuntime(
                            "Intl.DisplayNames.supportedLocalesOf requires locales and optional options"
                                .into(),
                        ));
                    }
                    let locales = self.eval_expr(&args[0], env, event_param, event)?;
                    let locales = self.intl_collect_locales(&locales)?;
                    let supported =
                        Self::intl_supported_locales(IntlFormatterKind::DisplayNames, locales);
                    Ok(Self::new_array_value(supported))
                }
                IntlStaticMethod::DurationFormatSupportedLocalesOf => {
                    if args.is_empty() || args.len() > 2 {
                        return Err(Error::ScriptRuntime(
                            "Intl.DurationFormat.supportedLocalesOf requires locales and optional options"
                                .into(),
                        ));
                    }
                    let locales = self.eval_expr(&args[0], env, event_param, event)?;
                    let locales = self.intl_collect_locales(&locales)?;
                    let supported =
                        Self::intl_supported_locales(IntlFormatterKind::DurationFormat, locales);
                    Ok(Self::new_array_value(supported))
                }
                IntlStaticMethod::ListFormatSupportedLocalesOf => {
                    if args.is_empty() || args.len() > 2 {
                        return Err(Error::ScriptRuntime(
                            "Intl.ListFormat.supportedLocalesOf requires locales and optional options"
                                .into(),
                        ));
                    }
                    let locales = self.eval_expr(&args[0], env, event_param, event)?;
                    let locales = self.intl_collect_locales(&locales)?;
                    let supported =
                        Self::intl_supported_locales(IntlFormatterKind::ListFormat, locales);
                    Ok(Self::new_array_value(supported))
                }
                IntlStaticMethod::PluralRulesSupportedLocalesOf => {
                    if args.is_empty() || args.len() > 2 {
                        return Err(Error::ScriptRuntime(
                            "Intl.PluralRules.supportedLocalesOf requires locales and optional options"
                                .into(),
                        ));
                    }
                    let locales = self.eval_expr(&args[0], env, event_param, event)?;
                    let locales = self.intl_collect_locales(&locales)?;
                    let supported =
                        Self::intl_supported_locales(IntlFormatterKind::PluralRules, locales);
                    Ok(Self::new_array_value(supported))
                }
                IntlStaticMethod::RelativeTimeFormatSupportedLocalesOf => {
                    if args.is_empty() || args.len() > 2 {
                        return Err(Error::ScriptRuntime(
                            "Intl.RelativeTimeFormat.supportedLocalesOf requires locales and optional options"
                                .into(),
                        ));
                    }
                    let locales = self.eval_expr(&args[0], env, event_param, event)?;
                    let locales = self.intl_collect_locales(&locales)?;
                    let supported = Self::intl_supported_locales(
                        IntlFormatterKind::RelativeTimeFormat,
                        locales,
                    );
                    Ok(Self::new_array_value(supported))
                }
                IntlStaticMethod::SegmenterSupportedLocalesOf => {
                    if args.is_empty() || args.len() > 2 {
                        return Err(Error::ScriptRuntime(
                            "Intl.Segmenter.supportedLocalesOf requires locales and optional options"
                                .into(),
                        ));
                    }
                    let locales = self.eval_expr(&args[0], env, event_param, event)?;
                    let locales = self.intl_collect_locales(&locales)?;
                    let supported =
                        Self::intl_supported_locales(IntlFormatterKind::Segmenter, locales);
                    Ok(Self::new_array_value(supported))
                }
                IntlStaticMethod::GetCanonicalLocales => {
                    let locales = if let Some(locale_expr) = args.first() {
                        let value = self.eval_expr(locale_expr, env, event_param, event)?;
                        self.intl_collect_locales(&value)?
                    } else {
                        Vec::new()
                    };
                    Ok(Self::new_array_value(
                        locales.into_iter().map(Value::String).collect::<Vec<_>>(),
                    ))
                }
                IntlStaticMethod::SupportedValuesOf => {
                    if args.len() != 1 {
                        return Err(Error::ScriptRuntime(
                            "Intl.supportedValuesOf requires exactly one argument".into(),
                        ));
                    }
                    let key = self
                        .eval_expr(&args[0], env, event_param, event)?
                        .as_string();
                    let values = Self::intl_supported_values_of(&key)?;
                    Ok(Self::new_array_value(
                        values.into_iter().map(Value::String).collect::<Vec<_>>(),
                    ))
                }
            },
            Expr::IntlLocaleConstruct {
                tag,
                options,
                called_with_new: _called_with_new,
            } => {
                let tag = self.eval_expr(tag, env, event_param, event)?;
                let options = options
                    .as_ref()
                    .map(|value| self.eval_expr(value, env, event_param, event))
                    .transpose()?;
                let data = self.intl_locale_data_from_input_value(&tag, options.as_ref())?;
                Ok(self.new_intl_locale_value(data))
            }
            Expr::IntlLocaleMethod { locale, method } => {
                let locale = self.eval_expr(locale, env, event_param, event)?;
                let data = self.resolve_intl_locale_data(&locale)?;
                match method {
                    IntlLocaleMethod::GetCalendars => Ok(Self::new_array_value(
                        self.intl_locale_get_calendars(&data)
                            .into_iter()
                            .map(Value::String)
                            .collect::<Vec<_>>(),
                    )),
                    IntlLocaleMethod::GetCollations => Ok(Self::new_array_value(
                        self.intl_locale_get_collations(&data)
                            .into_iter()
                            .map(Value::String)
                            .collect::<Vec<_>>(),
                    )),
                    IntlLocaleMethod::GetHourCycles => Ok(Self::new_array_value(
                        self.intl_locale_get_hour_cycles(&data)
                            .into_iter()
                            .map(Value::String)
                            .collect::<Vec<_>>(),
                    )),
                    IntlLocaleMethod::GetNumberingSystems => Ok(Self::new_array_value(
                        self.intl_locale_get_numbering_systems(&data)
                            .into_iter()
                            .map(Value::String)
                            .collect::<Vec<_>>(),
                    )),
                    IntlLocaleMethod::GetTextInfo => Ok(self.intl_locale_get_text_info(&data)),
                    IntlLocaleMethod::GetTimeZones => Ok(Self::new_array_value(
                        self.intl_locale_get_time_zones(&data)
                            .into_iter()
                            .map(Value::String)
                            .collect::<Vec<_>>(),
                    )),
                    IntlLocaleMethod::GetWeekInfo => Ok(self.intl_locale_get_week_info(&data)),
                    IntlLocaleMethod::Maximize => {
                        Ok(self.new_intl_locale_value(self.intl_locale_maximize_data(&data)))
                    }
                    IntlLocaleMethod::Minimize => {
                        Ok(self.new_intl_locale_value(self.intl_locale_minimize_data(&data)))
                    }
                    IntlLocaleMethod::ToString => {
                        Ok(Value::String(Self::intl_locale_data_to_string(&data)))
                    }
                }
            }
            Expr::IntlConstruct { .. } => {
                Err(Error::ScriptRuntime("Intl is not a constructor".into()))
            }
            Expr::RegexLiteral { pattern, flags } => {
                Self::new_regex_value(pattern.clone(), flags.clone())
            }
            Expr::RegexNew { pattern, flags } => {
                let pattern = self.eval_expr(pattern, env, event_param, event)?;
                let flags = flags
                    .as_ref()
                    .map(|flags| self.eval_expr(flags, env, event_param, event))
                    .transpose()?;
                Self::new_regex_from_values(&pattern, flags.as_ref())
            }
            Expr::RegExpConstructor => Ok(Value::RegExpConstructor),
            Expr::RegExpStaticMethod { method, args } => {
                self.eval_regexp_static_method(*method, args, env, event_param, event)
            }
            Expr::RegexTest { regex, input } => {
                let regex = self.eval_expr(regex, env, event_param, event)?;
                let input = self.eval_expr(input, env, event_param, event)?.as_string();
                let regex = Self::resolve_regex_from_value(&regex)?;
                Ok(Value::Bool(Self::regex_test(&regex, &input)?))
            }
            Expr::RegexExec { regex, input } => {
                let regex = self.eval_expr(regex, env, event_param, event)?;
                let input = self.eval_expr(input, env, event_param, event)?.as_string();
                let regex = Self::resolve_regex_from_value(&regex)?;
                let Some(captures) = Self::regex_exec(&regex, &input)? else {
                    return Ok(Value::Null);
                };
                Ok(Self::new_array_value(
                    captures.into_iter().map(Value::String).collect::<Vec<_>>(),
                ))
            }
            Expr::RegexToString { regex } => {
                let value = self.eval_expr(regex, env, event_param, event)?;
                if let Ok(regex) = Self::resolve_regex_from_value(&value) {
                    let regex = regex.borrow();
                    Ok(Value::String(format!("/{}/{}", regex.source, regex.flags)))
                } else if let Ok(locale_data) = self.resolve_intl_locale_data(&value) {
                    Ok(Value::String(Self::intl_locale_data_to_string(
                        &locale_data,
                    )))
                } else {
                    Ok(Value::String(value.as_string()))
                }
            }
            Expr::MathConst(constant) => match constant {
                MathConst::E => Ok(Value::Float(std::f64::consts::E)),
                MathConst::Ln10 => Ok(Value::Float(std::f64::consts::LN_10)),
                MathConst::Ln2 => Ok(Value::Float(std::f64::consts::LN_2)),
                MathConst::Log10E => Ok(Value::Float(std::f64::consts::LOG10_E)),
                MathConst::Log2E => Ok(Value::Float(std::f64::consts::LOG2_E)),
                MathConst::Pi => Ok(Value::Float(std::f64::consts::PI)),
                MathConst::Sqrt1_2 => Ok(Value::Float(std::f64::consts::FRAC_1_SQRT_2)),
                MathConst::Sqrt2 => Ok(Value::Float(std::f64::consts::SQRT_2)),
                MathConst::ToStringTag => Ok(Value::String("Math".to_string())),
            },
            Expr::MathMethod { method, args } => {
                self.eval_math_method(*method, args, env, event_param, event)
            }
            Expr::StringConstruct {
                value,
                called_with_new,
            } => {
                let value = value
                    .as_ref()
                    .map(|value| self.eval_expr(value, env, event_param, event))
                    .transpose()?
                    .unwrap_or(Value::Undefined);
                let coerced = value.as_string();
                if *called_with_new {
                    Ok(Self::new_string_wrapper_value(coerced))
                } else {
                    Ok(Value::String(coerced))
                }
            }
            Expr::StringStaticMethod { method, args } => {
                self.eval_string_static_method(*method, args, env, event_param, event)
            }
            Expr::StringConstructor => Ok(Value::StringConstructor),
            Expr::NumberConstruct { value } => {
                let value = value
                    .as_ref()
                    .map(|value| self.eval_expr(value, env, event_param, event))
                    .transpose()?
                    .unwrap_or(Value::Number(0));
                Ok(Self::number_value(
                    Self::coerce_number_for_number_constructor(&value),
                ))
            }
            Expr::NumberConst(constant) => match constant {
                NumberConst::Epsilon => Ok(Value::Float(f64::EPSILON)),
                NumberConst::MaxSafeInteger => Ok(Value::Number(9_007_199_254_740_991)),
                NumberConst::MaxValue => Ok(Value::Float(f64::MAX)),
                NumberConst::MinSafeInteger => Ok(Value::Number(-9_007_199_254_740_991)),
                NumberConst::MinValue => Ok(Value::Float(f64::from_bits(1))),
                NumberConst::NaN => Ok(Value::Float(f64::NAN)),
                NumberConst::NegativeInfinity => Ok(Value::Float(f64::NEG_INFINITY)),
                NumberConst::PositiveInfinity => Ok(Value::Float(f64::INFINITY)),
            },
            Expr::NumberMethod { method, args } => {
                self.eval_number_method(*method, args, env, event_param, event)
            }
            Expr::NumberInstanceMethod {
                value,
                method,
                args,
            } => self.eval_number_instance_method(*method, value, args, env, event_param, event),
            Expr::BigIntConstruct {
                value,
                called_with_new,
            } => {
                if *called_with_new {
                    return Err(Error::ScriptRuntime("BigInt is not a constructor".into()));
                }
                let value = value
                    .as_ref()
                    .map(|value| self.eval_expr(value, env, event_param, event))
                    .transpose()?
                    .unwrap_or(Value::Undefined);
                Ok(Value::BigInt(Self::coerce_bigint_for_constructor(&value)?))
            }
            Expr::BigIntMethod { method, args } => {
                self.eval_bigint_method(*method, args, env, event_param, event)
            }
            Expr::BigIntInstanceMethod {
                value,
                method,
                args,
            } => self.eval_bigint_instance_method(*method, value, args, env, event_param, event),
            Expr::ArrayBufferConstruct {
                byte_length,
                options,
                called_with_new,
            } => self.eval_array_buffer_construct(
                byte_length,
                options,
                *called_with_new,
                env,
                event_param,
                event,
            ),
            Expr::ArrayBufferConstructor => Ok(Value::ArrayBufferConstructor),
            Expr::ArrayBufferIsView(value) => {
                let value = self.eval_expr(value, env, event_param, event)?;
                Ok(Value::Bool(matches!(value, Value::TypedArray(_))))
            }
            Expr::ArrayBufferDetached(target) => {
                let buffer = self.resolve_array_buffer_from_env(env, target)?;
                Ok(Value::Bool(buffer.borrow().detached))
            }
            Expr::ArrayBufferMaxByteLength(target) => {
                let buffer = self.resolve_array_buffer_from_env(env, target)?;
                Ok(Value::Number(buffer.borrow().max_byte_length() as i64))
            }
            Expr::ArrayBufferResizable(target) => {
                let buffer = self.resolve_array_buffer_from_env(env, target)?;
                Ok(Value::Bool(buffer.borrow().resizable()))
            }
            Expr::ArrayBufferResize {
                target,
                new_byte_length,
            } => {
                let new_byte_length = self.eval_expr(new_byte_length, env, event_param, event)?;
                let new_byte_length = Self::value_to_i64(&new_byte_length);
                self.resize_array_buffer_in_env(env, target, new_byte_length)?;
                Ok(Value::Undefined)
            }
            Expr::ArrayBufferSlice { target, start, end } => {
                let buffer = self.resolve_array_buffer_from_env(env, target)?;
                Self::ensure_array_buffer_not_detached(&buffer, "slice")?;
                let source = buffer.borrow();
                let len = source.bytes.len();
                let start = if let Some(start) = start {
                    let start = self.eval_expr(start, env, event_param, event)?;
                    Self::normalize_slice_index(len, Self::value_to_i64(&start))
                } else {
                    0
                };
                let end = if let Some(end) = end {
                    let end = self.eval_expr(end, env, event_param, event)?;
                    Self::normalize_slice_index(len, Self::value_to_i64(&end))
                } else {
                    len
                };
                let end = end.max(start);
                let bytes = source.bytes[start..end].to_vec();
                Ok(Value::ArrayBuffer(Rc::new(RefCell::new(
                    ArrayBufferValue {
                        bytes,
                        max_byte_length: None,
                        detached: false,
                    },
                ))))
            }
            Expr::ArrayBufferTransfer {
                target,
                to_fixed_length,
            } => {
                let buffer = self.resolve_array_buffer_from_env(env, target)?;
                self.transfer_array_buffer(&buffer, *to_fixed_length)
            }
            Expr::TypedArrayConstructorRef(kind) => Ok(Value::TypedArrayConstructor(kind.clone())),
            Expr::TypedArrayConstruct {
                kind,
                args,
                called_with_new,
            } => self.eval_typed_array_construct(
                *kind,
                args,
                *called_with_new,
                env,
                event_param,
                event,
            ),
            Expr::TypedArrayConstructWithCallee {
                callee,
                args,
                called_with_new,
            } => self.eval_typed_array_construct_with_callee(
                callee,
                args,
                *called_with_new,
                env,
                event_param,
                event,
            ),
            Expr::PromiseConstruct {
                executor,
                called_with_new,
            } => self.eval_promise_construct(executor, *called_with_new, env, event_param, event),
            Expr::PromiseConstructor => Ok(Value::PromiseConstructor),
            Expr::PromiseStaticMethod { method, args } => {
                self.eval_promise_static_method(*method, args, env, event_param, event)
            }
            Expr::PromiseMethod {
                target,
                method,
                args,
            } => self.eval_promise_method(target, *method, args, env, event_param, event),
            Expr::MapConstruct {
                iterable,
                called_with_new,
            } => self.eval_map_construct(iterable, *called_with_new, env, event_param, event),
            Expr::MapConstructor => Ok(Value::MapConstructor),
            Expr::MapStaticMethod { method, args } => {
                self.eval_map_static_method(*method, args, env, event_param, event)
            }
            Expr::MapMethod {
                target,
                method,
                args,
            } => self.eval_map_method(target, *method, args, env, event_param, event),
            Expr::SetConstruct {
                iterable,
                called_with_new,
            } => self.eval_set_construct(iterable, *called_with_new, env, event_param, event),
            Expr::SetConstructor => Ok(Value::SetConstructor),
            Expr::SetMethod {
                target,
                method,
                args,
            } => self.eval_set_method(target, *method, args, env, event_param, event),
            Expr::SymbolConstruct {
                description,
                called_with_new,
            } => self.eval_symbol_construct(description, *called_with_new, env, event_param, event),
            Expr::SymbolConstructor => Ok(Value::SymbolConstructor),
            Expr::SymbolStaticMethod { method, args } => {
                self.eval_symbol_static_method(*method, args, env, event_param, event)
            }
            Expr::SymbolStaticProperty(property) => Ok(self.eval_symbol_static_property(*property)),
            Expr::TypedArrayStaticBytesPerElement(kind) => {
                Ok(Value::Number(kind.bytes_per_element() as i64))
            }
            Expr::TypedArrayStaticMethod { kind, method, args } => {
                self.eval_typed_array_static_method(*kind, *method, args, env, event_param, event)
            }
            Expr::TypedArrayByteLength(target) => match env.get(target) {
                Some(Value::TypedArray(array)) => {
                    Ok(Value::Number(array.borrow().observed_byte_length() as i64))
                }
                Some(Value::ArrayBuffer(buffer)) => {
                    Ok(Value::Number(buffer.borrow().byte_length() as i64))
                }
                Some(_) => Err(Error::ScriptRuntime(format!(
                    "variable '{}' is not a TypedArray",
                    target
                ))),
                None => Err(Error::ScriptRuntime(format!(
                    "unknown variable: {}",
                    target
                ))),
            },
            Expr::TypedArrayByteOffset(target) => {
                let array = self.resolve_typed_array_from_env(env, target)?;
                let byte_offset = if array.borrow().observed_length() == 0
                    && array.borrow().byte_offset >= array.borrow().buffer.borrow().byte_length()
                {
                    0
                } else {
                    array.borrow().byte_offset
                };
                Ok(Value::Number(byte_offset as i64))
            }
            Expr::TypedArrayBuffer(target) => {
                let array = self.resolve_typed_array_from_env(env, target)?;
                Ok(Value::ArrayBuffer(array.borrow().buffer.clone()))
            }
            Expr::TypedArrayBytesPerElement(target) => {
                let array = self.resolve_typed_array_from_env(env, target)?;
                Ok(Value::Number(array.borrow().kind.bytes_per_element() as i64))
            }
            Expr::TypedArrayMethod {
                target,
                method,
                args,
            } => self.eval_typed_array_method(target, *method, args, env, event_param, event),
            Expr::EncodeUri(value) => {
                let value = self.eval_expr(value, env, event_param, event)?;
                Ok(Value::String(encode_uri_like(&value.as_string(), false)))
            }
            Expr::EncodeUriComponent(value) => {
                let value = self.eval_expr(value, env, event_param, event)?;
                Ok(Value::String(encode_uri_like(&value.as_string(), true)))
            }
            Expr::DecodeUri(value) => {
                let value = self.eval_expr(value, env, event_param, event)?;
                Ok(Value::String(decode_uri_like(&value.as_string(), false)?))
            }
            Expr::DecodeUriComponent(value) => {
                let value = self.eval_expr(value, env, event_param, event)?;
                Ok(Value::String(decode_uri_like(&value.as_string(), true)?))
            }
            Expr::Escape(value) => {
                let value = self.eval_expr(value, env, event_param, event)?;
                Ok(Value::String(js_escape(&value.as_string())))
            }
            Expr::Unescape(value) => {
                let value = self.eval_expr(value, env, event_param, event)?;
                Ok(Value::String(js_unescape(&value.as_string())))
            }
            Expr::IsNaN(value) => {
                let value = self.eval_expr(value, env, event_param, event)?;
                Ok(Value::Bool(Self::coerce_number_for_global(&value).is_nan()))
            }
            Expr::IsFinite(value) => {
                let value = self.eval_expr(value, env, event_param, event)?;
                Ok(Value::Bool(
                    Self::coerce_number_for_global(&value).is_finite(),
                ))
            }
            Expr::Atob(value) => {
                let value = self.eval_expr(value, env, event_param, event)?;
                Ok(Value::String(decode_base64_to_binary_string(
                    &value.as_string(),
                )?))
            }
            Expr::Btoa(value) => {
                let value = self.eval_expr(value, env, event_param, event)?;
                Ok(Value::String(encode_binary_string_to_base64(
                    &value.as_string(),
                )?))
            }
            Expr::ParseInt { value, radix } => {
                let value = self.eval_expr(value, env, event_param, event)?;
                let radix = radix
                    .as_ref()
                    .map(|expr| self.eval_expr(expr, env, event_param, event))
                    .transpose()?
                    .map(|radix| Self::value_to_i64(&radix));
                Ok(Value::Float(parse_js_parse_int(&value.as_string(), radix)))
            }
            Expr::ParseFloat(value) => {
                let value = self.eval_expr(value, env, event_param, event)?;
                Ok(Value::Float(parse_js_parse_float(&value.as_string())))
            }
            Expr::JsonParse(value) => {
                let value = self.eval_expr(value, env, event_param, event)?.as_string();
                Self::parse_json_text(&value)
            }
            Expr::JsonStringify(value) => {
                let value = self.eval_expr(value, env, event_param, event)?;
                match Self::json_stringify_top_level(&value)? {
                    Some(serialized) => Ok(Value::String(serialized)),
                    None => Ok(Value::Undefined),
                }
            }
            Expr::ObjectConstruct { value } => {
                let value = value
                    .as_ref()
                    .map(|value| self.eval_expr(value, env, event_param, event))
                    .transpose()?
                    .unwrap_or(Value::Undefined);
                match value {
                    Value::Null | Value::Undefined => Ok(Self::new_object_value(Vec::new())),
                    Value::Object(object) => Ok(Value::Object(object)),
                    Value::Array(array) => Ok(Value::Array(array)),
                    Value::Date(date) => Ok(Value::Date(date)),
                    Value::Map(map) => Ok(Value::Map(map)),
                    Value::Set(set) => Ok(Value::Set(set)),
                    Value::ArrayBuffer(buffer) => Ok(Value::ArrayBuffer(buffer)),
                    Value::TypedArray(array) => Ok(Value::TypedArray(array)),
                    Value::Promise(promise) => Ok(Value::Promise(promise)),
                    Value::RegExp(regex) => Ok(Value::RegExp(regex)),
                    Value::Symbol(symbol) => Ok(Self::new_object_value(vec![(
                        INTERNAL_SYMBOL_WRAPPER_KEY.to_string(),
                        Value::Number(symbol.id as i64),
                    )])),
                    primitive => Ok(Self::new_object_value(vec![(
                        "value".into(),
                        Value::String(primitive.as_string()),
                    )])),
                }
            }
            Expr::ObjectLiteral(entries) => {
                let mut object_entries = Vec::with_capacity(entries.len());
                for entry in entries {
                    match entry {
                        ObjectLiteralEntry::Pair(key, value) => {
                            let value = self.eval_expr(value, env, event_param, event)?;
                            let key = match key {
                                ObjectLiteralKey::Static(key) => key.clone(),
                                ObjectLiteralKey::Computed(expr) => {
                                    let key = self.eval_expr(expr, env, event_param, event)?;
                                    self.property_key_to_storage_key(&key)
                                }
                            };
                            Self::object_set_entry(&mut object_entries, key, value);
                        }
                        ObjectLiteralEntry::Spread(expr) => {
                            let spread_value = self.eval_expr(expr, env, event_param, event)?;
                            match spread_value {
                                Value::Null | Value::Undefined => {}
                                Value::Object(entries) => {
                                    for (key, value) in entries.borrow().iter() {
                                        if Self::is_internal_object_key(key) {
                                            continue;
                                        }
                                        Self::object_set_entry(
                                            &mut object_entries,
                                            key.clone(),
                                            value.clone(),
                                        );
                                    }
                                }
                                Value::Array(values) => {
                                    for (index, value) in values.borrow().iter().enumerate() {
                                        Self::object_set_entry(
                                            &mut object_entries,
                                            index.to_string(),
                                            value.clone(),
                                        );
                                    }
                                }
                                Value::String(text) => {
                                    for (index, ch) in text.chars().enumerate() {
                                        Self::object_set_entry(
                                            &mut object_entries,
                                            index.to_string(),
                                            Value::String(ch.to_string()),
                                        );
                                    }
                                }
                                _ => {
                                    return Err(Error::ScriptRuntime(
                                        "object spread source must be an object, array, string, null, or undefined".into(),
                                    ));
                                }
                            }
                        }
                    }
                }
                Ok(Self::new_object_value(object_entries))
            }
            Expr::ObjectGet { target, key } => match env.get(target) {
                Some(value) => {
                    self.object_property_from_value(value, key)
                        .map_err(|err| match err {
                            Error::ScriptRuntime(msg) if msg == "value is not an object" => {
                                Error::ScriptRuntime(format!(
                                    "variable '{}' is not an object",
                                    target
                                ))
                            }
                            other => other,
                        })
                }
                None => Err(Error::ScriptRuntime(format!(
                    "unknown variable: {}",
                    target
                ))),
            },
            Expr::ObjectPathGet { target, path } => {
                let Some(mut value) = env.get(target).cloned() else {
                    return Err(Error::ScriptRuntime(format!(
                        "unknown variable: {}",
                        target
                    )));
                };
                for key in path {
                    value = self.object_property_from_value(&value, key)?;
                }
                Ok(value)
            }
            Expr::ObjectGetOwnPropertySymbols(object) => {
                let object = self.eval_expr(object, env, event_param, event)?;
                match object {
                    Value::Object(entries) => {
                        let mut out = Vec::new();
                        for (key, _) in entries.borrow().iter() {
                            if let Some(symbol_id) = Self::symbol_id_from_storage_key(key) {
                                if let Some(symbol) = self.symbols_by_id.get(&symbol_id) {
                                    out.push(Value::Symbol(symbol.clone()));
                                }
                            }
                        }
                        Ok(Self::new_array_value(out))
                    }
                    _ => Err(Error::ScriptRuntime(
                        "Object.getOwnPropertySymbols argument must be an object".into(),
                    )),
                }
            }
            Expr::ObjectKeys(object) => {
                let object = self.eval_expr(object, env, event_param, event)?;
                match object {
                    Value::Object(entries) => {
                        let keys = entries
                            .borrow()
                            .iter()
                            .filter(|(key, _)| !Self::is_internal_object_key(key))
                            .map(|(key, _)| Value::String(key.clone()))
                            .collect::<Vec<_>>();
                        Ok(Self::new_array_value(keys))
                    }
                    _ => Err(Error::ScriptRuntime(
                        "Object.keys argument must be an object".into(),
                    )),
                }
            }
            Expr::ObjectValues(object) => {
                let object = self.eval_expr(object, env, event_param, event)?;
                match object {
                    Value::Object(entries) => {
                        let values = entries
                            .borrow()
                            .iter()
                            .filter(|(key, _)| !Self::is_internal_object_key(key))
                            .map(|(_, value)| value.clone())
                            .collect::<Vec<_>>();
                        Ok(Self::new_array_value(values))
                    }
                    _ => Err(Error::ScriptRuntime(
                        "Object.values argument must be an object".into(),
                    )),
                }
            }
            Expr::ObjectEntries(object) => {
                let object = self.eval_expr(object, env, event_param, event)?;
                match object {
                    Value::Object(entries) => {
                        let values = entries
                            .borrow()
                            .iter()
                            .filter(|(key, _)| !Self::is_internal_object_key(key))
                            .map(|(key, value)| {
                                Self::new_array_value(vec![
                                    Value::String(key.clone()),
                                    value.clone(),
                                ])
                            })
                            .collect::<Vec<_>>();
                        Ok(Self::new_array_value(values))
                    }
                    _ => Err(Error::ScriptRuntime(
                        "Object.entries argument must be an object".into(),
                    )),
                }
            }
            Expr::ObjectHasOwn { object, key } => {
                let object = self.eval_expr(object, env, event_param, event)?;
                let key = self.eval_expr(key, env, event_param, event)?;
                let key = self.property_key_to_storage_key(&key);
                match object {
                    Value::Object(entries) => Ok(Value::Bool(
                        Self::object_get_entry(&entries.borrow(), &key).is_some(),
                    )),
                    _ => Err(Error::ScriptRuntime(
                        "Object.hasOwn first argument must be an object".into(),
                    )),
                }
            }
            Expr::ObjectGetPrototypeOf(value) => {
                let value = self.eval_expr(value, env, event_param, event)?;
                match value {
                    Value::TypedArrayConstructor(TypedArrayConstructorKind::Concrete(_)) => Ok(
                        Value::TypedArrayConstructor(TypedArrayConstructorKind::Abstract),
                    ),
                    Value::TypedArray(_) => Ok(Value::TypedArrayConstructor(
                        TypedArrayConstructorKind::Abstract,
                    )),
                    _ => Ok(Value::Object(Rc::new(RefCell::new(Vec::new())))),
                }
            }
            Expr::ObjectFreeze(value) => {
                let value = self.eval_expr(value, env, event_param, event)?;
                match value {
                    Value::TypedArray(array) => {
                        if array.borrow().observed_length() > 0 {
                            return Err(Error::ScriptRuntime(
                                "Cannot freeze array buffer views with elements".into(),
                            ));
                        }
                        Ok(Value::TypedArray(array))
                    }
                    other => Ok(other),
                }
            }
            Expr::ObjectHasOwnProperty { target, key } => {
                let key = self.eval_expr(key, env, event_param, event)?;
                let key = self.property_key_to_storage_key(&key);
                match env.get(target) {
                    Some(Value::Object(entries)) => Ok(Value::Bool(
                        Self::object_get_entry(&entries.borrow(), &key).is_some(),
                    )),
                    Some(_) => Err(Error::ScriptRuntime(format!(
                        "variable '{}' is not an object",
                        target
                    ))),
                    None => Err(Error::ScriptRuntime(format!(
                        "unknown variable: {}",
                        target
                    ))),
                }
            }
            Expr::ArrayLiteral(values) => {
                let mut out = Vec::with_capacity(values.len());
                for value in values {
                    match value {
                        Expr::Spread(expr) => {
                            let spread_value = self.eval_expr(expr, env, event_param, event)?;
                            out.extend(self.array_like_values_from_value(&spread_value)?);
                        }
                        _ => out.push(self.eval_expr(value, env, event_param, event)?),
                    }
                }
                Ok(Self::new_array_value(out))
            }
            Expr::ArrayIsArray(value) => {
                let value = self.eval_expr(value, env, event_param, event)?;
                Ok(Value::Bool(matches!(value, Value::Array(_))))
            }
            Expr::ArrayFrom { source, map_fn } => {
                let source = self.eval_expr(source, env, event_param, event)?;
                let values = self.array_like_values_from_value(&source)?;
                if let Some(map_fn) = map_fn {
                    let callback = self.eval_expr(map_fn, env, event_param, event)?;
                    let mut mapped = Vec::with_capacity(values.len());
                    for (index, value) in values.into_iter().enumerate() {
                        mapped.push(self.execute_callback_value(
                            &callback,
                            &[value, Value::Number(index as i64)],
                            event,
                        )?);
                    }
                    return Ok(Self::new_array_value(mapped));
                }
                Ok(Self::new_array_value(values))
            }
            Expr::ArrayLength(target) => match env.get(target) {
                Some(Value::Array(values)) => Ok(Value::Number(values.borrow().len() as i64)),
                Some(Value::TypedArray(values)) => {
                    Ok(Value::Number(values.borrow().observed_length() as i64))
                }
                Some(Value::NodeList(nodes)) => Ok(Value::Number(nodes.len() as i64)),
                Some(Value::String(value)) => Ok(Value::Number(value.chars().count() as i64)),
                Some(Value::Object(entries)) => {
                    let entries = entries.borrow();
                    if Self::is_history_object(&entries) {
                        return Ok(Self::object_get_entry(&entries, "length")
                            .unwrap_or(Value::Number(self.history_entries.len() as i64)));
                    }
                    if Self::is_window_object(&entries) {
                        return Ok(
                            Self::object_get_entry(&entries, "length").unwrap_or(Value::Number(0))
                        );
                    }
                    if let Some(value) = Self::string_wrapper_value_from_object(&entries) {
                        Ok(Value::Number(value.chars().count() as i64))
                    } else {
                        Err(Error::ScriptRuntime(format!(
                            "variable '{}' is not an array",
                            target
                        )))
                    }
                }
                Some(_) => Err(Error::ScriptRuntime(format!(
                    "variable '{}' is not an array",
                    target
                ))),
                None => Err(Error::ScriptRuntime(format!(
                    "unknown variable: {}",
                    target
                ))),
            },
            Expr::ArrayIndex { target, index } => {
                let index = self.eval_expr(index, env, event_param, event)?;
                match env.get(target) {
                    Some(Value::Object(entries)) => {
                        let entries_ref = entries.borrow();
                        if let Some(value) = Self::string_wrapper_value_from_object(&entries_ref) {
                            let Some(index) = self.value_as_index(&index) else {
                                return Ok(Value::Undefined);
                            };
                            return Ok(value
                                .chars()
                                .nth(index)
                                .map(|ch| Value::String(ch.to_string()))
                                .unwrap_or(Value::Undefined));
                        }
                        let key = self.property_key_to_storage_key(&index);
                        Ok(Self::object_get_entry(&entries_ref, &key).unwrap_or(Value::Undefined))
                    }
                    Some(Value::Array(values)) => {
                        let Some(index) = self.value_as_index(&index) else {
                            return Ok(Value::Undefined);
                        };
                        Ok(values
                            .borrow()
                            .get(index)
                            .cloned()
                            .unwrap_or(Value::Undefined))
                    }
                    Some(Value::TypedArray(values)) => {
                        let Some(index) = self.value_as_index(&index) else {
                            return Ok(Value::Undefined);
                        };
                        self.typed_array_get_index(values, index)
                    }
                    Some(Value::NodeList(nodes)) => {
                        let Some(index) = self.value_as_index(&index) else {
                            return Ok(Value::Undefined);
                        };
                        Ok(nodes
                            .get(index)
                            .copied()
                            .map(Value::Node)
                            .unwrap_or(Value::Undefined))
                    }
                    Some(Value::String(value)) => {
                        let Some(index) = self.value_as_index(&index) else {
                            return Ok(Value::Undefined);
                        };
                        Ok(value
                            .chars()
                            .nth(index)
                            .map(|ch| Value::String(ch.to_string()))
                            .unwrap_or(Value::Undefined))
                    }
                    Some(_) => Err(Error::ScriptRuntime(format!(
                        "variable '{}' is not an array",
                        target
                    ))),
                    None => Err(Error::ScriptRuntime(format!(
                        "unknown variable: {}",
                        target
                    ))),
                }
            }
            Expr::ArrayPush { target, args } => {
                let values = self.resolve_array_from_env(env, target)?;
                let mut evaluated = Vec::with_capacity(args.len());
                for arg in args {
                    evaluated.push(self.eval_expr(arg, env, event_param, event)?);
                }
                let mut values = values.borrow_mut();
                values.extend(evaluated);
                Ok(Value::Number(values.len() as i64))
            }
            Expr::ArrayPop(target) => {
                let values = self.resolve_array_from_env(env, target)?;
                Ok(values.borrow_mut().pop().unwrap_or(Value::Undefined))
            }
            Expr::ArrayShift(target) => {
                let values = self.resolve_array_from_env(env, target)?;
                let mut values = values.borrow_mut();
                if values.is_empty() {
                    Ok(Value::Undefined)
                } else {
                    Ok(values.remove(0))
                }
            }
            Expr::ArrayUnshift { target, args } => {
                let values = self.resolve_array_from_env(env, target)?;
                let mut evaluated = Vec::with_capacity(args.len());
                for arg in args {
                    evaluated.push(self.eval_expr(arg, env, event_param, event)?);
                }
                let mut values = values.borrow_mut();
                for value in evaluated.into_iter().rev() {
                    values.insert(0, value);
                }
                Ok(Value::Number(values.len() as i64))
            }
            Expr::ArrayMap { target, callback } => match env.get(target) {
                Some(Value::Array(values)) => {
                    let input = values.borrow().clone();
                    let mut out = Vec::with_capacity(input.len());
                    for (idx, item) in input.into_iter().enumerate() {
                        let mapped = self.execute_array_callback(
                            callback,
                            &[
                                item,
                                Value::Number(idx as i64),
                                Value::Array(values.clone()),
                            ],
                            env,
                            event,
                        )?;
                        out.push(mapped);
                    }
                    Ok(Self::new_array_value(out))
                }
                Some(Value::TypedArray(values)) => {
                    let input = self.typed_array_snapshot(values)?;
                    let kind = values.borrow().kind;
                    let mut out = Vec::with_capacity(input.len());
                    for (idx, item) in input.into_iter().enumerate() {
                        let mapped = self.execute_array_callback(
                            callback,
                            &[
                                item,
                                Value::Number(idx as i64),
                                Value::TypedArray(values.clone()),
                            ],
                            env,
                            event,
                        )?;
                        out.push(mapped);
                    }
                    self.new_typed_array_from_values(kind, &out)
                }
                Some(_) => Err(Error::ScriptRuntime(format!(
                    "variable '{}' is not an array",
                    target
                ))),
                None => Err(Error::ScriptRuntime(format!(
                    "unknown variable: {}",
                    target
                ))),
            },
            Expr::ArrayFilter { target, callback } => match env.get(target) {
                Some(Value::Array(values)) => {
                    let input = values.borrow().clone();
                    let mut out = Vec::new();
                    for (idx, item) in input.into_iter().enumerate() {
                        let keep = self.execute_array_callback(
                            callback,
                            &[
                                item.clone(),
                                Value::Number(idx as i64),
                                Value::Array(values.clone()),
                            ],
                            env,
                            event,
                        )?;
                        if keep.truthy() {
                            out.push(item);
                        }
                    }
                    Ok(Self::new_array_value(out))
                }
                Some(Value::TypedArray(values)) => {
                    let input = self.typed_array_snapshot(values)?;
                    let kind = values.borrow().kind;
                    let mut out = Vec::new();
                    for (idx, item) in input.into_iter().enumerate() {
                        let keep = self.execute_array_callback(
                            callback,
                            &[
                                item.clone(),
                                Value::Number(idx as i64),
                                Value::TypedArray(values.clone()),
                            ],
                            env,
                            event,
                        )?;
                        if keep.truthy() {
                            out.push(item);
                        }
                    }
                    self.new_typed_array_from_values(kind, &out)
                }
                Some(_) => Err(Error::ScriptRuntime(format!(
                    "variable '{}' is not an array",
                    target
                ))),
                None => Err(Error::ScriptRuntime(format!(
                    "unknown variable: {}",
                    target
                ))),
            },
            Expr::ArrayReduce {
                target,
                callback,
                initial,
            } => match env.get(target) {
                Some(Value::Array(values)) => {
                    let input = values.borrow().clone();
                    let mut start_index = 0usize;
                    let mut acc = if let Some(initial) = initial {
                        self.eval_expr(initial, env, event_param, event)?
                    } else {
                        let Some(first) = input.first().cloned() else {
                            return Err(Error::ScriptRuntime(
                                "reduce of empty array with no initial value".into(),
                            ));
                        };
                        start_index = 1;
                        first
                    };
                    for (idx, item) in input.into_iter().enumerate().skip(start_index) {
                        acc = self.execute_array_callback(
                            callback,
                            &[
                                acc,
                                item,
                                Value::Number(idx as i64),
                                Value::Array(values.clone()),
                            ],
                            env,
                            event,
                        )?;
                    }
                    Ok(acc)
                }
                Some(Value::TypedArray(values)) => {
                    let input = self.typed_array_snapshot(values)?;
                    let mut start_index = 0usize;
                    let mut acc = if let Some(initial) = initial {
                        self.eval_expr(initial, env, event_param, event)?
                    } else {
                        let Some(first) = input.first().cloned() else {
                            return Err(Error::ScriptRuntime(
                                "reduce of empty array with no initial value".into(),
                            ));
                        };
                        start_index = 1;
                        first
                    };
                    for (idx, item) in input.into_iter().enumerate().skip(start_index) {
                        acc = self.execute_array_callback(
                            callback,
                            &[
                                acc,
                                item,
                                Value::Number(idx as i64),
                                Value::TypedArray(values.clone()),
                            ],
                            env,
                            event,
                        )?;
                    }
                    Ok(acc)
                }
                Some(_) => Err(Error::ScriptRuntime(format!(
                    "variable '{}' is not an array",
                    target
                ))),
                None => Err(Error::ScriptRuntime(format!(
                    "unknown variable: {}",
                    target
                ))),
            },
            Expr::ArrayForEach { target, callback } => match env.get(target) {
                Some(Value::Array(values)) => {
                    let input = values.borrow().clone();
                    for (idx, item) in input.into_iter().enumerate() {
                        let _ = self.execute_array_callback(
                            callback,
                            &[
                                item,
                                Value::Number(idx as i64),
                                Value::Array(values.clone()),
                            ],
                            env,
                            event,
                        )?;
                    }
                    Ok(Value::Undefined)
                }
                Some(Value::TypedArray(values)) => {
                    let input = self.typed_array_snapshot(values)?;
                    for (idx, item) in input.into_iter().enumerate() {
                        let _ = self.execute_array_callback(
                            callback,
                            &[
                                item,
                                Value::Number(idx as i64),
                                Value::TypedArray(values.clone()),
                            ],
                            env,
                            event,
                        )?;
                    }
                    Ok(Value::Undefined)
                }
                Some(_) => Err(Error::ScriptRuntime(format!(
                    "variable '{}' is not an array",
                    target
                ))),
                None => Err(Error::ScriptRuntime(format!(
                    "unknown variable: {}",
                    target
                ))),
            },
            Expr::ArrayFind { target, callback } => match env.get(target) {
                Some(Value::Array(values)) => {
                    let input = values.borrow().clone();
                    for (idx, item) in input.into_iter().enumerate() {
                        let matched = self.execute_array_callback(
                            callback,
                            &[
                                item.clone(),
                                Value::Number(idx as i64),
                                Value::Array(values.clone()),
                            ],
                            env,
                            event,
                        )?;
                        if matched.truthy() {
                            return Ok(item);
                        }
                    }
                    Ok(Value::Undefined)
                }
                Some(Value::TypedArray(values)) => {
                    let input = self.typed_array_snapshot(values)?;
                    for (idx, item) in input.into_iter().enumerate() {
                        let matched = self.execute_array_callback(
                            callback,
                            &[
                                item.clone(),
                                Value::Number(idx as i64),
                                Value::TypedArray(values.clone()),
                            ],
                            env,
                            event,
                        )?;
                        if matched.truthy() {
                            return Ok(item);
                        }
                    }
                    Ok(Value::Undefined)
                }
                Some(_) => Err(Error::ScriptRuntime(format!(
                    "variable '{}' is not an array",
                    target
                ))),
                None => Err(Error::ScriptRuntime(format!(
                    "unknown variable: {}",
                    target
                ))),
            },
            Expr::ArraySome { target, callback } => match env.get(target) {
                Some(Value::Array(values)) => {
                    let input = values.borrow().clone();
                    for (idx, item) in input.into_iter().enumerate() {
                        let matched = self.execute_array_callback(
                            callback,
                            &[
                                item,
                                Value::Number(idx as i64),
                                Value::Array(values.clone()),
                            ],
                            env,
                            event,
                        )?;
                        if matched.truthy() {
                            return Ok(Value::Bool(true));
                        }
                    }
                    Ok(Value::Bool(false))
                }
                Some(Value::TypedArray(values)) => {
                    let input = self.typed_array_snapshot(values)?;
                    for (idx, item) in input.into_iter().enumerate() {
                        let matched = self.execute_array_callback(
                            callback,
                            &[
                                item,
                                Value::Number(idx as i64),
                                Value::TypedArray(values.clone()),
                            ],
                            env,
                            event,
                        )?;
                        if matched.truthy() {
                            return Ok(Value::Bool(true));
                        }
                    }
                    Ok(Value::Bool(false))
                }
                Some(_) => Err(Error::ScriptRuntime(format!(
                    "variable '{}' is not an array",
                    target
                ))),
                None => Err(Error::ScriptRuntime(format!(
                    "unknown variable: {}",
                    target
                ))),
            },
            Expr::ArrayEvery { target, callback } => match env.get(target) {
                Some(Value::Array(values)) => {
                    let input = values.borrow().clone();
                    for (idx, item) in input.into_iter().enumerate() {
                        let matched = self.execute_array_callback(
                            callback,
                            &[
                                item,
                                Value::Number(idx as i64),
                                Value::Array(values.clone()),
                            ],
                            env,
                            event,
                        )?;
                        if !matched.truthy() {
                            return Ok(Value::Bool(false));
                        }
                    }
                    Ok(Value::Bool(true))
                }
                Some(Value::TypedArray(values)) => {
                    let input = self.typed_array_snapshot(values)?;
                    for (idx, item) in input.into_iter().enumerate() {
                        let matched = self.execute_array_callback(
                            callback,
                            &[
                                item,
                                Value::Number(idx as i64),
                                Value::TypedArray(values.clone()),
                            ],
                            env,
                            event,
                        )?;
                        if !matched.truthy() {
                            return Ok(Value::Bool(false));
                        }
                    }
                    Ok(Value::Bool(true))
                }
                Some(_) => Err(Error::ScriptRuntime(format!(
                    "variable '{}' is not an array",
                    target
                ))),
                None => Err(Error::ScriptRuntime(format!(
                    "unknown variable: {}",
                    target
                ))),
            },
            Expr::ArrayIncludes {
                target,
                search,
                from_index,
            } => {
                let search = self.eval_expr(search, env, event_param, event)?;
                match env.get(target) {
                    Some(Value::Array(values)) => {
                        let values = values.borrow();
                        let len = values.len() as i64;
                        let mut start = from_index
                            .as_ref()
                            .map(|value| self.eval_expr(value, env, event_param, event))
                            .transpose()?
                            .map(|value| Self::value_to_i64(&value))
                            .unwrap_or(0);
                        if start < 0 {
                            start = (len + start).max(0);
                        }
                        let start = start.min(len) as usize;
                        for value in values.iter().skip(start) {
                            if self.strict_equal(value, &search) {
                                return Ok(Value::Bool(true));
                            }
                        }
                        Ok(Value::Bool(false))
                    }
                    Some(Value::TypedArray(values)) => {
                        let values_vec = self.typed_array_snapshot(values)?;
                        let len = values_vec.len() as i64;
                        let mut start = from_index
                            .as_ref()
                            .map(|value| self.eval_expr(value, env, event_param, event))
                            .transpose()?
                            .map(|value| Self::value_to_i64(&value))
                            .unwrap_or(0);
                        if start < 0 {
                            start = (len + start).max(0);
                        }
                        let start = start.min(len) as usize;
                        for value in values_vec.iter().skip(start) {
                            if self.strict_equal(value, &search) {
                                return Ok(Value::Bool(true));
                            }
                        }
                        Ok(Value::Bool(false))
                    }
                    Some(Value::String(value)) => {
                        let search = search.as_string();
                        let len = value.chars().count() as i64;
                        let mut start = from_index
                            .as_ref()
                            .map(|value| self.eval_expr(value, env, event_param, event))
                            .transpose()?
                            .map(|value| Self::value_to_i64(&value))
                            .unwrap_or(0);
                        if start < 0 {
                            start = (len + start).max(0);
                        }
                        let start = start.min(len) as usize;
                        let start_byte = Self::char_index_to_byte(value, start);
                        Ok(Value::Bool(value[start_byte..].contains(&search)))
                    }
                    Some(_) => Err(Error::ScriptRuntime(format!(
                        "variable '{}' is not an array",
                        target
                    ))),
                    None => Err(Error::ScriptRuntime(format!(
                        "unknown variable: {}",
                        target
                    ))),
                }
            }
            Expr::ArraySlice { target, start, end } => match env.get(target) {
                Some(Value::Array(values)) => {
                    let values = values.borrow();
                    let len = values.len();
                    let start = start
                        .as_ref()
                        .map(|value| self.eval_expr(value, env, event_param, event))
                        .transpose()?
                        .map(|value| Self::value_to_i64(&value))
                        .map(|value| Self::normalize_slice_index(len, value))
                        .unwrap_or(0);
                    let end = end
                        .as_ref()
                        .map(|value| self.eval_expr(value, env, event_param, event))
                        .transpose()?
                        .map(|value| Self::value_to_i64(&value))
                        .map(|value| Self::normalize_slice_index(len, value))
                        .unwrap_or(len);
                    let end = end.max(start);
                    Ok(Self::new_array_value(values[start..end].to_vec()))
                }
                Some(Value::TypedArray(values)) => {
                    let snapshot = self.typed_array_snapshot(values)?;
                    let kind = values.borrow().kind;
                    let len = snapshot.len();
                    let start = start
                        .as_ref()
                        .map(|value| self.eval_expr(value, env, event_param, event))
                        .transpose()?
                        .map(|value| Self::value_to_i64(&value))
                        .map(|value| Self::normalize_slice_index(len, value))
                        .unwrap_or(0);
                    let end = end
                        .as_ref()
                        .map(|value| self.eval_expr(value, env, event_param, event))
                        .transpose()?
                        .map(|value| Self::value_to_i64(&value))
                        .map(|value| Self::normalize_slice_index(len, value))
                        .unwrap_or(len);
                    let end = end.max(start);
                    self.new_typed_array_from_values(kind, &snapshot[start..end])
                }
                Some(Value::ArrayBuffer(buffer)) => {
                    Self::ensure_array_buffer_not_detached(buffer, "slice")?;
                    let source = buffer.borrow();
                    let len = source.bytes.len();
                    let start = start
                        .as_ref()
                        .map(|value| self.eval_expr(value, env, event_param, event))
                        .transpose()?
                        .map(|value| Self::value_to_i64(&value))
                        .map(|value| Self::normalize_slice_index(len, value))
                        .unwrap_or(0);
                    let end = end
                        .as_ref()
                        .map(|value| self.eval_expr(value, env, event_param, event))
                        .transpose()?
                        .map(|value| Self::value_to_i64(&value))
                        .map(|value| Self::normalize_slice_index(len, value))
                        .unwrap_or(len);
                    let end = end.max(start);
                    Ok(Value::ArrayBuffer(Rc::new(RefCell::new(
                        ArrayBufferValue {
                            bytes: source.bytes[start..end].to_vec(),
                            max_byte_length: None,
                            detached: false,
                        },
                    ))))
                }
                Some(Value::String(value)) => {
                    let len = value.chars().count();
                    let start = start
                        .as_ref()
                        .map(|value| self.eval_expr(value, env, event_param, event))
                        .transpose()?
                        .map(|value| Self::value_to_i64(&value))
                        .map(|value| Self::normalize_slice_index(len, value))
                        .unwrap_or(0);
                    let end = end
                        .as_ref()
                        .map(|value| self.eval_expr(value, env, event_param, event))
                        .transpose()?
                        .map(|value| Self::value_to_i64(&value))
                        .map(|value| Self::normalize_slice_index(len, value))
                        .unwrap_or(len);
                    let end = end.max(start);
                    Ok(Value::String(Self::substring_chars(value, start, end)))
                }
                Some(_) => Err(Error::ScriptRuntime(format!(
                    "variable '{}' is not an array",
                    target
                ))),
                None => Err(Error::ScriptRuntime(format!(
                    "unknown variable: {}",
                    target
                ))),
            },
            Expr::ArraySplice {
                target,
                start,
                delete_count,
                items,
            } => {
                let values = self.resolve_array_from_env(env, target)?;
                let start = self.eval_expr(start, env, event_param, event)?;
                let start = Self::value_to_i64(&start);
                let delete_count = delete_count
                    .as_ref()
                    .map(|value| self.eval_expr(value, env, event_param, event))
                    .transpose()?
                    .map(|value| Self::value_to_i64(&value));
                let mut insert_items = Vec::with_capacity(items.len());
                for item in items {
                    insert_items.push(self.eval_expr(item, env, event_param, event)?);
                }

                let mut values = values.borrow_mut();
                let len = values.len();
                let start = Self::normalize_splice_start_index(len, start);
                let delete_count = delete_count
                    .unwrap_or((len.saturating_sub(start)) as i64)
                    .max(0) as usize;
                let delete_count = delete_count.min(len.saturating_sub(start));
                let removed = values
                    .drain(start..start + delete_count)
                    .collect::<Vec<_>>();
                for (offset, item) in insert_items.into_iter().enumerate() {
                    values.insert(start + offset, item);
                }
                Ok(Self::new_array_value(removed))
            }
            Expr::ArrayJoin { target, separator } => {
                let separator = separator
                    .as_ref()
                    .map(|value| self.eval_expr(value, env, event_param, event))
                    .transpose()?
                    .map(|value| value.as_string())
                    .unwrap_or_else(|| ",".to_string());
                let values = match env.get(target) {
                    Some(Value::Array(values)) => values.borrow().clone(),
                    Some(Value::TypedArray(values)) => self.typed_array_snapshot(values)?,
                    Some(_) => {
                        return Err(Error::ScriptRuntime(format!(
                            "variable '{}' is not an array",
                            target
                        )));
                    }
                    None => {
                        return Err(Error::ScriptRuntime(format!(
                            "unknown variable: {}",
                            target
                        )));
                    }
                };
                let mut out = String::new();
                for (idx, value) in values.iter().enumerate() {
                    if idx > 0 {
                        out.push_str(&separator);
                    }
                    if matches!(value, Value::Null | Value::Undefined) {
                        continue;
                    }
                    out.push_str(&value.as_string());
                }
                Ok(Value::String(out))
            }
            Expr::ArraySort { target, comparator } => {
                let comparator = comparator
                    .as_ref()
                    .map(|value| self.eval_expr(value, env, event_param, event))
                    .transpose()?;
                if comparator
                    .as_ref()
                    .is_some_and(|value| !self.is_callable_value(value))
                {
                    return Err(Error::ScriptRuntime("callback is not a function".into()));
                }

                let values = self.resolve_array_from_env(env, target)?;
                let mut snapshot = values.borrow().clone();
                let len = snapshot.len();
                for i in 0..len {
                    let end = len.saturating_sub(i + 1);
                    for j in 0..end {
                        let should_swap = if let Some(comparator) = comparator.as_ref() {
                            let compared = self.execute_callable_value(
                                comparator,
                                &[snapshot[j].clone(), snapshot[j + 1].clone()],
                                event,
                            )?;
                            Self::coerce_number_for_global(&compared) > 0.0
                        } else {
                            snapshot[j].as_string() > snapshot[j + 1].as_string()
                        };
                        if should_swap {
                            snapshot.swap(j, j + 1);
                        }
                    }
                }
                *values.borrow_mut() = snapshot;
                Ok(Value::Array(values))
            }
            Expr::StringCharAt { value, index } => {
                let value = self.eval_expr(value, env, event_param, event)?.as_string();
                let len = value.chars().count();
                let index = index
                    .as_ref()
                    .map(|value| self.eval_expr(value, env, event_param, event))
                    .transpose()?
                    .map(|value| Self::value_to_i64(&value))
                    .unwrap_or(0);
                if index < 0 || (index as usize) >= len {
                    Ok(Value::String(String::new()))
                } else {
                    Ok(value
                        .chars()
                        .nth(index as usize)
                        .map(|ch| Value::String(ch.to_string()))
                        .unwrap_or_else(|| Value::String(String::new())))
                }
            }
            Expr::StringCharCodeAt { value, index } => {
                let value = self.eval_expr(value, env, event_param, event)?.as_string();
                let len = value.chars().count();
                let index = index
                    .as_ref()
                    .map(|value| self.eval_expr(value, env, event_param, event))
                    .transpose()?
                    .map(|value| Self::value_to_i64(&value))
                    .unwrap_or(0);
                if index < 0 || (index as usize) >= len {
                    Ok(Value::Float(f64::NAN))
                } else {
                    Ok(value
                        .chars()
                        .nth(index as usize)
                        .map(|ch| Value::Number(ch as i64))
                        .unwrap_or(Value::Float(f64::NAN)))
                }
            }
            Expr::StringCodePointAt { value, index } => {
                let value = self.eval_expr(value, env, event_param, event)?.as_string();
                let len = value.chars().count();
                let index = index
                    .as_ref()
                    .map(|value| self.eval_expr(value, env, event_param, event))
                    .transpose()?
                    .map(|value| Self::value_to_i64(&value))
                    .unwrap_or(0);
                if index < 0 || (index as usize) >= len {
                    Ok(Value::Undefined)
                } else {
                    Ok(value
                        .chars()
                        .nth(index as usize)
                        .map(|ch| Value::Number(ch as i64))
                        .unwrap_or(Value::Undefined))
                }
            }
            Expr::StringAt { value, index } => {
                let value = self.eval_expr(value, env, event_param, event)?.as_string();
                let len = value.chars().count() as i64;
                let index = index
                    .as_ref()
                    .map(|value| self.eval_expr(value, env, event_param, event))
                    .transpose()?
                    .map(|value| Self::value_to_i64(&value))
                    .unwrap_or(0);
                let index = if index < 0 { len + index } else { index };
                if index < 0 || index >= len {
                    Ok(Value::Undefined)
                } else {
                    Ok(value
                        .chars()
                        .nth(index as usize)
                        .map(|ch| Value::String(ch.to_string()))
                        .unwrap_or(Value::Undefined))
                }
            }
            Expr::StringConcat { value, args } => {
                let mut out = self.eval_expr(value, env, event_param, event)?.as_string();
                for arg in args {
                    let value = self.eval_expr(arg, env, event_param, event)?;
                    out.push_str(&value.as_string());
                }
                Ok(Value::String(out))
            }
            Expr::StringTrim { value, mode } => {
                let value = self.eval_expr(value, env, event_param, event)?.as_string();
                let value = match mode {
                    StringTrimMode::Both => value.trim().to_string(),
                    StringTrimMode::Start => value.trim_start().to_string(),
                    StringTrimMode::End => value.trim_end().to_string(),
                };
                Ok(Value::String(value))
            }
            Expr::StringToUpperCase(value) => {
                let value = self.eval_expr(value, env, event_param, event)?.as_string();
                Ok(Value::String(value.to_uppercase()))
            }
            Expr::StringToLowerCase(value) => {
                let value = self.eval_expr(value, env, event_param, event)?.as_string();
                Ok(Value::String(value.to_lowercase()))
            }
            Expr::StringIncludes {
                value,
                search,
                position,
            } => {
                let value = self.eval_expr(value, env, event_param, event)?.as_string();
                let search = self.eval_expr(search, env, event_param, event)?;
                if matches!(search, Value::RegExp(_)) {
                    return Err(Error::ScriptRuntime(
                        "First argument to String.prototype.includes must not be a regular expression"
                            .into(),
                    ));
                }
                let search = search.as_string();
                let len = value.chars().count() as i64;
                let mut position = position
                    .as_ref()
                    .map(|value| self.eval_expr(value, env, event_param, event))
                    .transpose()?
                    .map(|value| Self::value_to_i64(&value))
                    .unwrap_or(0);
                if position < 0 {
                    position = 0;
                }
                let position = position.min(len) as usize;
                let position_byte = Self::char_index_to_byte(&value, position);
                Ok(Value::Bool(value[position_byte..].contains(&search)))
            }
            Expr::StringStartsWith {
                value,
                search,
                position,
            } => {
                let value = self.eval_expr(value, env, event_param, event)?.as_string();
                let search = self.eval_expr(search, env, event_param, event)?;
                if matches!(search, Value::RegExp(_)) {
                    return Err(Error::ScriptRuntime(
                        "First argument to String.prototype.startsWith must not be a regular expression"
                            .into(),
                    ));
                }
                let search = search.as_string();
                let len = value.chars().count() as i64;
                let mut position = position
                    .as_ref()
                    .map(|value| self.eval_expr(value, env, event_param, event))
                    .transpose()?
                    .map(|value| Self::value_to_i64(&value))
                    .unwrap_or(0);
                if position < 0 {
                    position = 0;
                }
                let position = position.min(len) as usize;
                let position_byte = Self::char_index_to_byte(&value, position);
                Ok(Value::Bool(value[position_byte..].starts_with(&search)))
            }
            Expr::StringEndsWith {
                value,
                search,
                length,
            } => {
                let value = self.eval_expr(value, env, event_param, event)?.as_string();
                let search = self.eval_expr(search, env, event_param, event)?;
                if matches!(search, Value::RegExp(_)) {
                    return Err(Error::ScriptRuntime(
                        "First argument to String.prototype.endsWith must not be a regular expression"
                            .into(),
                    ));
                }
                let search = search.as_string();
                let len = value.chars().count();
                let end = length
                    .as_ref()
                    .map(|value| self.eval_expr(value, env, event_param, event))
                    .transpose()?
                    .map(|value| Self::value_to_i64(&value))
                    .map(|value| {
                        if value < 0 {
                            0
                        } else {
                            (value as usize).min(len)
                        }
                    })
                    .unwrap_or(len);
                let hay = Self::substring_chars(&value, 0, end);
                Ok(Value::Bool(hay.ends_with(&search)))
            }
            Expr::StringSlice { value, start, end } => {
                let value = self.eval_expr(value, env, event_param, event)?.as_string();
                let len = value.chars().count();
                let start = start
                    .as_ref()
                    .map(|value| self.eval_expr(value, env, event_param, event))
                    .transpose()?
                    .map(|value| Self::value_to_i64(&value))
                    .map(|value| Self::normalize_slice_index(len, value))
                    .unwrap_or(0);
                let end = end
                    .as_ref()
                    .map(|value| self.eval_expr(value, env, event_param, event))
                    .transpose()?
                    .map(|value| Self::value_to_i64(&value))
                    .map(|value| Self::normalize_slice_index(len, value))
                    .unwrap_or(len);
                let end = end.max(start);
                Ok(Value::String(Self::substring_chars(&value, start, end)))
            }
            Expr::StringSubstring { value, start, end } => {
                let value = self.eval_expr(value, env, event_param, event)?.as_string();
                let len = value.chars().count();
                let start = start
                    .as_ref()
                    .map(|value| self.eval_expr(value, env, event_param, event))
                    .transpose()?
                    .map(|value| Self::value_to_i64(&value))
                    .map(|value| Self::normalize_substring_index(len, value))
                    .unwrap_or(0);
                let end = end
                    .as_ref()
                    .map(|value| self.eval_expr(value, env, event_param, event))
                    .transpose()?
                    .map(|value| Self::value_to_i64(&value))
                    .map(|value| Self::normalize_substring_index(len, value))
                    .unwrap_or(len);
                let (start, end) = if start <= end {
                    (start, end)
                } else {
                    (end, start)
                };
                Ok(Value::String(Self::substring_chars(&value, start, end)))
            }
            Expr::StringMatch { value, pattern } => {
                let value = self.eval_expr(value, env, event_param, event)?.as_string();
                let pattern = self.eval_expr(pattern, env, event_param, event)?;
                self.eval_string_match(&value, pattern)
            }
            Expr::StringSplit {
                value,
                separator,
                limit,
            } => {
                let text = self.eval_expr(value, env, event_param, event)?.as_string();
                let separator = separator
                    .as_ref()
                    .map(|value| self.eval_expr(value, env, event_param, event))
                    .transpose()?;
                let limit = limit
                    .as_ref()
                    .map(|value| self.eval_expr(value, env, event_param, event))
                    .transpose()?
                    .map(|value| Self::value_to_i64(&value));
                let parts = match separator {
                    None => Self::split_string(&text, None, limit),
                    Some(Value::RegExp(regex)) => {
                        Self::split_string_with_regex(&text, &regex, limit)
                    }
                    Some(value) => Self::split_string(&text, Some(value.as_string()), limit),
                };
                Ok(Self::new_array_value(parts))
            }
            Expr::StringReplace { value, from, to } => {
                let value = self.eval_expr(value, env, event_param, event)?.as_string();
                let to = self.eval_expr(to, env, event_param, event)?.as_string();
                let from = self.eval_expr(from, env, event_param, event)?;
                let replaced = match from {
                    Value::RegExp(regex) => Self::replace_string_with_regex(&value, &regex, &to),
                    other => value.replacen(&other.as_string(), &to, 1),
                };
                Ok(Value::String(replaced))
            }
            Expr::StringReplaceAll { value, from, to } => {
                let value = self.eval_expr(value, env, event_param, event)?.as_string();
                let to = self.eval_expr(to, env, event_param, event)?.as_string();
                let from = self.eval_expr(from, env, event_param, event)?;
                let replaced = match from {
                    Value::RegExp(regex) => {
                        if !regex.borrow().global {
                            return Err(Error::ScriptRuntime(
                                "String.prototype.replaceAll called with a non-global RegExp argument"
                                    .into(),
                            ));
                        }
                        Self::replace_string_with_regex(&value, &regex, &to)
                    }
                    other => {
                        let from = other.as_string();
                        if from.is_empty() {
                            let mut out = String::new();
                            for ch in value.chars() {
                                out.push_str(&to);
                                out.push(ch);
                            }
                            out.push_str(&to);
                            out
                        } else {
                            value.replace(&from, &to)
                        }
                    }
                };
                Ok(Value::String(replaced))
            }
            Expr::StringIndexOf {
                value,
                search,
                position,
            } => {
                let value = self.eval_expr(value, env, event_param, event)?.as_string();
                let search = self.eval_expr(search, env, event_param, event)?.as_string();
                let len = value.chars().count() as i64;
                let mut position = position
                    .as_ref()
                    .map(|value| self.eval_expr(value, env, event_param, event))
                    .transpose()?
                    .map(|value| Self::value_to_i64(&value))
                    .unwrap_or(0);
                if position < 0 {
                    position = 0;
                }
                let position = position.min(len) as usize;
                Ok(Value::Number(
                    Self::string_index_of(&value, &search, position)
                        .map(|value| value as i64)
                        .unwrap_or(-1),
                ))
            }
            Expr::StringLastIndexOf {
                value,
                search,
                position,
            } => {
                let value = self.eval_expr(value, env, event_param, event)?.as_string();
                let search = self.eval_expr(search, env, event_param, event)?.as_string();
                let len = value.chars().count() as i64;
                let position = position
                    .as_ref()
                    .map(|value| self.eval_expr(value, env, event_param, event))
                    .transpose()?
                    .map(|value| Self::value_to_i64(&value))
                    .unwrap_or(len);
                let position = if position < 0 { 0 } else { position.min(len) } as usize;
                let candidate = Self::substring_chars(&value, 0, position.saturating_add(1));
                let found = if search.is_empty() {
                    Some(position.min(candidate.chars().count()))
                } else {
                    candidate
                        .rfind(&search)
                        .map(|byte| candidate[..byte].chars().count())
                };
                Ok(Value::Number(found.map(|idx| idx as i64).unwrap_or(-1)))
            }
            Expr::StringSearch { value, pattern } => {
                let value = self.eval_expr(value, env, event_param, event)?.as_string();
                let pattern = self.eval_expr(pattern, env, event_param, event)?;
                let idx = match pattern {
                    Value::RegExp(regex) => regex
                        .borrow()
                        .compiled
                        .find(&value)
                        .map(|m| value[..m.start()].chars().count() as i64),
                    other => {
                        let search = other.as_string();
                        Self::string_index_of(&value, &search, 0).map(|idx| idx as i64)
                    }
                };
                Ok(Value::Number(idx.unwrap_or(-1)))
            }
            Expr::StringRepeat { value, count } => {
                let value = self.eval_expr(value, env, event_param, event)?.as_string();
                let count = self.eval_expr(count, env, event_param, event)?;
                let count = Self::value_to_i64(&count);
                if count < 0 {
                    return Err(Error::ScriptRuntime(
                        "Invalid count value for String.prototype.repeat".into(),
                    ));
                }
                let count = usize::try_from(count).map_err(|_| {
                    Error::ScriptRuntime("Invalid count value for String.prototype.repeat".into())
                })?;
                Ok(Value::String(value.repeat(count)))
            }
            Expr::StringPadStart {
                value,
                target_length,
                pad,
            } => {
                let value = self.eval_expr(value, env, event_param, event)?.as_string();
                let target_length = self.eval_expr(target_length, env, event_param, event)?;
                let target_length = Self::value_to_i64(&target_length).max(0) as usize;
                let current_len = value.chars().count();
                if target_length <= current_len {
                    return Ok(Value::String(value));
                }
                let pad = pad
                    .as_ref()
                    .map(|value| self.eval_expr(value, env, event_param, event))
                    .transpose()?
                    .map(|value| value.as_string())
                    .unwrap_or_else(|| " ".to_string());
                if pad.is_empty() {
                    return Ok(Value::String(value));
                }
                let mut filler = String::new();
                let needed = target_length - current_len;
                while filler.chars().count() < needed {
                    filler.push_str(&pad);
                }
                let filler = filler.chars().take(needed).collect::<String>();
                Ok(Value::String(format!("{filler}{value}")))
            }
            Expr::StringPadEnd {
                value,
                target_length,
                pad,
            } => {
                let value = self.eval_expr(value, env, event_param, event)?.as_string();
                let target_length = self.eval_expr(target_length, env, event_param, event)?;
                let target_length = Self::value_to_i64(&target_length).max(0) as usize;
                let current_len = value.chars().count();
                if target_length <= current_len {
                    return Ok(Value::String(value));
                }
                let pad = pad
                    .as_ref()
                    .map(|value| self.eval_expr(value, env, event_param, event))
                    .transpose()?
                    .map(|value| value.as_string())
                    .unwrap_or_else(|| " ".to_string());
                if pad.is_empty() {
                    return Ok(Value::String(value));
                }
                let mut filler = String::new();
                let needed = target_length - current_len;
                while filler.chars().count() < needed {
                    filler.push_str(&pad);
                }
                let filler = filler.chars().take(needed).collect::<String>();
                Ok(Value::String(format!("{value}{filler}")))
            }
            Expr::StringLocaleCompare {
                value,
                compare,
                locales,
                options,
            } => {
                let value = self.eval_expr(value, env, event_param, event)?.as_string();
                let compare = self
                    .eval_expr(compare, env, event_param, event)?
                    .as_string();
                let locale = locales
                    .as_ref()
                    .map(|locales| self.eval_expr(locales, env, event_param, event))
                    .transpose()?
                    .map(|locales| self.intl_collect_locales(&locales))
                    .transpose()?
                    .and_then(|locales| locales.into_iter().next())
                    .unwrap_or_else(|| DEFAULT_LOCALE.to_string());
                let mut case_first = "false".to_string();
                let mut sensitivity = "variant".to_string();
                if let Some(options) = options {
                    let options = self.eval_expr(options, env, event_param, event)?;
                    if let Value::Object(entries) = options {
                        let entries = entries.borrow();
                        if let Some(Value::String(value)) =
                            Self::object_get_entry(&entries, "caseFirst")
                        {
                            case_first = value;
                        }
                        if let Some(Value::String(value)) =
                            Self::object_get_entry(&entries, "sensitivity")
                        {
                            sensitivity = value;
                        }
                    }
                }
                Ok(Value::Number(Self::intl_collator_compare_strings(
                    &value,
                    &compare,
                    &locale,
                    &case_first,
                    &sensitivity,
                )))
            }
            Expr::StringIsWellFormed(value) => {
                let _ = self.eval_expr(value, env, event_param, event)?.as_string();
                Ok(Value::Bool(true))
            }
            Expr::StringToWellFormed(value) => {
                let value = self.eval_expr(value, env, event_param, event)?.as_string();
                Ok(Value::String(value))
            }
            Expr::StringValueOf(value) => {
                let value = self.eval_expr(value, env, event_param, event)?;
                match value {
                    Value::Object(entries) => {
                        let entries_ref = entries.borrow();
                        if let Some(value) = Self::string_wrapper_value_from_object(&entries_ref) {
                            Ok(Value::String(value))
                        } else {
                            Ok(Value::Object(entries.clone()))
                        }
                    }
                    Value::String(value) => Ok(Value::String(value)),
                    other => Ok(other),
                }
            }
            Expr::StringToString(value) => {
                let value = self.eval_expr(value, env, event_param, event)?.as_string();
                Ok(Value::String(value))
            }
            Expr::StructuredClone(value) => {
                let value = self.eval_expr(value, env, event_param, event)?;
                Self::structured_clone_value(&value, &mut Vec::new(), &mut Vec::new())
            }
            Expr::Fetch(request) => {
                let request = self
                    .eval_expr(request, env, event_param, event)?
                    .as_string();
                self.fetch_calls.push(request.clone());
                let response = self.fetch_mocks.get(&request).cloned().ok_or_else(|| {
                    Error::ScriptRuntime(format!("fetch mock not found for request: {request}"))
                })?;
                Ok(Value::String(response))
            }
            Expr::MatchMedia(query) => {
                let query = self.eval_expr(query, env, event_param, event)?.as_string();
                self.match_media_calls.push(query.clone());
                let matches = self
                    .match_media_mocks
                    .get(&query)
                    .copied()
                    .unwrap_or(self.default_match_media_matches);
                Ok(Self::new_object_value(vec![
                    ("matches".into(), Value::Bool(matches)),
                    ("media".into(), Value::String(query)),
                ]))
            }
            Expr::MatchMediaProp { query, prop } => {
                let query = self.eval_expr(query, env, event_param, event)?.as_string();
                self.match_media_calls.push(query.clone());
                let matches = self
                    .match_media_mocks
                    .get(&query)
                    .copied()
                    .unwrap_or(self.default_match_media_matches);
                match prop {
                    MatchMediaProp::Matches => Ok(Value::Bool(matches)),
                    MatchMediaProp::Media => Ok(Value::String(query)),
                }
            }
            Expr::Alert(message) => {
                let message = self
                    .eval_expr(message, env, event_param, event)?
                    .as_string();
                self.alert_messages.push(message);
                Ok(Value::Undefined)
            }
            Expr::Confirm(message) => {
                let _ = self.eval_expr(message, env, event_param, event)?;
                let accepted = self
                    .confirm_responses
                    .pop_front()
                    .unwrap_or(self.default_confirm_response);
                Ok(Value::Bool(accepted))
            }
            Expr::Prompt { message, default } => {
                let _ = self.eval_expr(message, env, event_param, event)?;
                let default_value = default
                    .as_ref()
                    .map(|value| self.eval_expr(value, env, event_param, event))
                    .transpose()?
                    .map(|value| value.as_string());
                let response = self
                    .prompt_responses
                    .pop_front()
                    .unwrap_or_else(|| self.default_prompt_response.clone().or(default_value));
                match response {
                    Some(value) => Ok(Value::String(value)),
                    None => Ok(Value::Null),
                }
            }
            Expr::FunctionConstructor { args } => {
                if args.is_empty() {
                    return Err(Error::ScriptRuntime(
                        "new Function requires at least one argument".into(),
                    ));
                }

                let mut parts = Vec::with_capacity(args.len());
                for arg in args {
                    let part = self.eval_expr(arg, env, event_param, event)?.as_string();
                    parts.push(part);
                }

                let body_src = parts.last().cloned().ok_or_else(|| {
                    Error::ScriptRuntime("new Function requires body argument".into())
                })?;
                let mut params = Vec::new();
                for part in parts.iter().take(parts.len().saturating_sub(1)) {
                    let names = Self::parse_function_constructor_param_names(part)?;
                    params.extend(names.into_iter().map(|name| FunctionParam {
                        name,
                        default: None,
                    }));
                }

                let stmts = parse_block_statements(&body_src).map_err(|err| {
                    Error::ScriptRuntime(format!("new Function body parse failed: {err}"))
                })?;
                Ok(self.make_function_value(ScriptHandler { params, stmts }, env, true, false))
            }
            Expr::FunctionCall { target, args } => {
                let callee = env
                    .get(target)
                    .cloned()
                    .ok_or_else(|| Error::ScriptRuntime(format!("unknown variable: {target}")))?;
                let mut evaluated_args = Vec::with_capacity(args.len());
                for arg in args {
                    evaluated_args.push(self.eval_expr(arg, env, event_param, event)?);
                }
                self.execute_callable_value(&callee, &evaluated_args, event)
                    .map_err(|err| match err {
                        Error::ScriptRuntime(msg) if msg == "callback is not a function" => {
                            Error::ScriptRuntime(format!("'{target}' is not a function"))
                        }
                        other => other,
                    })
            }
            Expr::Var(name) => env
                .get(name)
                .cloned()
                .ok_or_else(|| Error::ScriptRuntime(format!("unknown variable: {name}"))),
            Expr::DomRef(target) => {
                let is_list_query = matches!(
                    target,
                    DomQuery::BySelectorAll { .. } | DomQuery::QuerySelectorAll { .. }
                );
                if is_list_query {
                    let nodes = self
                        .resolve_dom_query_list_runtime(target, env)?
                        .unwrap_or_default();
                    Ok(Value::NodeList(nodes))
                } else {
                    let node = self.resolve_dom_query_required_runtime(target, env)?;
                    Ok(Value::Node(node))
                }
            }
            Expr::CreateElement(tag_name) => {
                let node = self.dom.create_detached_element(tag_name.clone());
                Ok(Value::Node(node))
            }
            Expr::CreateTextNode(text) => {
                let node = self.dom.create_detached_text(text.clone());
                Ok(Value::Node(node))
            }
            Expr::Function { handler, is_async } => {
                Ok(self.make_function_value(handler.clone(), env, false, *is_async))
            }
            Expr::SetTimeout { handler, delay_ms } => {
                let delay = self.eval_expr(delay_ms, env, event_param, event)?;
                let delay = Self::value_to_i64(&delay);
                let callback_args = handler
                    .args
                    .iter()
                    .map(|arg| self.eval_expr(arg, env, event_param, event))
                    .collect::<Result<Vec<_>>>()?;
                let id = self.schedule_timeout(handler.callback.clone(), delay, callback_args, env);
                Ok(Value::Number(id))
            }
            Expr::SetInterval { handler, delay_ms } => {
                let interval = self.eval_expr(delay_ms, env, event_param, event)?;
                let interval = Self::value_to_i64(&interval);
                let callback_args = handler
                    .args
                    .iter()
                    .map(|arg| self.eval_expr(arg, env, event_param, event))
                    .collect::<Result<Vec<_>>>()?;
                let id =
                    self.schedule_interval(handler.callback.clone(), interval, callback_args, env);
                Ok(Value::Number(id))
            }
            Expr::RequestAnimationFrame { callback } => {
                const FRAME_DELAY_MS: i64 = 16;
                let callback_args = vec![Value::Number(self.now_ms.saturating_add(FRAME_DELAY_MS))];
                let id =
                    self.schedule_timeout(callback.clone(), FRAME_DELAY_MS, callback_args, env);
                Ok(Value::Number(id))
            }
            Expr::QueueMicrotask { handler } => {
                self.queue_microtask(handler.clone(), env);
                Ok(Value::Null)
            }
            Expr::Binary { left, op, right } => {
                let left = self.eval_expr(left, env, event_param, event)?;
                let right = self.eval_expr(right, env, event_param, event)?;
                self.eval_binary(op, &left, &right)
            }
            Expr::DomRead { target, prop } => {
                if let DomQuery::Var(name) = target {
                    if let Some(Value::Object(entries)) = env.get(name) {
                        if let Some(key) = Self::object_key_from_dom_prop(prop) {
                            return Ok(Self::object_get_entry(&entries.borrow(), key)
                                .unwrap_or(Value::Undefined));
                        }
                    }
                }
                let node = self.resolve_dom_query_required_runtime(target, env)?;
                match prop {
                    DomProp::Value => Ok(Value::String(self.dom.value(node)?)),
                    DomProp::Checked => Ok(Value::Bool(self.dom.checked(node)?)),
                    DomProp::Open => Ok(Value::Bool(self.dom.has_attr(node, "open")?)),
                    DomProp::ReturnValue => Ok(Value::String(self.dialog_return_value(node)?)),
                    DomProp::ClosedBy => Ok(Value::String(
                        self.dom.attr(node, "closedby").unwrap_or_default(),
                    )),
                    DomProp::Readonly => Ok(Value::Bool(self.dom.readonly(node))),
                    DomProp::Disabled => Ok(Value::Bool(self.dom.disabled(node))),
                    DomProp::Required => Ok(Value::Bool(self.dom.required(node))),
                    DomProp::TextContent => Ok(Value::String(self.dom.text_content(node))),
                    DomProp::InnerHtml => Ok(Value::String(self.dom.inner_html(node)?)),
                    DomProp::ClassName => Ok(Value::String(
                        self.dom.attr(node, "class").unwrap_or_default(),
                    )),
                    DomProp::Id => Ok(Value::String(self.dom.attr(node, "id").unwrap_or_default())),
                    DomProp::Name => Ok(Value::String(
                        self.dom.attr(node, "name").unwrap_or_default(),
                    )),
                    DomProp::Dataset(key) => Ok(Value::String(self.dom.dataset_get(node, key)?)),
                    DomProp::Style(prop) => Ok(Value::String(self.dom.style_get(node, prop)?)),
                    DomProp::OffsetWidth => Ok(Value::Number(self.dom.offset_width(node)?)),
                    DomProp::OffsetHeight => Ok(Value::Number(self.dom.offset_height(node)?)),
                    DomProp::OffsetLeft => Ok(Value::Number(self.dom.offset_left(node)?)),
                    DomProp::OffsetTop => Ok(Value::Number(self.dom.offset_top(node)?)),
                    DomProp::ScrollWidth => Ok(Value::Number(self.dom.scroll_width(node)?)),
                    DomProp::ScrollHeight => Ok(Value::Number(self.dom.scroll_height(node)?)),
                    DomProp::ScrollLeft => Ok(Value::Number(self.dom.scroll_left(node)?)),
                    DomProp::ScrollTop => Ok(Value::Number(self.dom.scroll_top(node)?)),
                    DomProp::ActiveElement => Ok(self
                        .dom
                        .active_element()
                        .map(Value::Node)
                        .unwrap_or(Value::Null)),
                    DomProp::CharacterSet => Ok(Value::String("UTF-8".to_string())),
                    DomProp::CompatMode => Ok(Value::String("CSS1Compat".to_string())),
                    DomProp::ContentType => Ok(Value::String("text/html".to_string())),
                    DomProp::ReadyState => Ok(Value::String("complete".to_string())),
                    DomProp::Referrer => Ok(Value::String(String::new())),
                    DomProp::Title => Ok(Value::String(self.dom.document_title())),
                    DomProp::Url | DomProp::DocumentUri => {
                        Ok(Value::String(self.document_url.clone()))
                    }
                    DomProp::Location => Ok(Value::Object(self.location_object.clone())),
                    DomProp::LocationHref => Ok(Value::String(self.document_url.clone())),
                    DomProp::LocationProtocol => {
                        Ok(Value::String(self.current_location_parts().protocol()))
                    }
                    DomProp::LocationHost => {
                        Ok(Value::String(self.current_location_parts().host()))
                    }
                    DomProp::LocationHostname => {
                        Ok(Value::String(self.current_location_parts().hostname))
                    }
                    DomProp::LocationPort => Ok(Value::String(self.current_location_parts().port)),
                    DomProp::LocationPathname => {
                        let parts = self.current_location_parts();
                        Ok(Value::String(if parts.has_authority {
                            parts.pathname
                        } else {
                            parts.opaque_path
                        }))
                    }
                    DomProp::LocationSearch => {
                        Ok(Value::String(self.current_location_parts().search))
                    }
                    DomProp::LocationHash => Ok(Value::String(self.current_location_parts().hash)),
                    DomProp::LocationOrigin => {
                        Ok(Value::String(self.current_location_parts().origin()))
                    }
                    DomProp::LocationAncestorOrigins => Ok(Self::new_array_value(Vec::new())),
                    DomProp::History => Ok(Value::Object(self.history_object.clone())),
                    DomProp::HistoryLength => Ok(Value::Number(self.history_entries.len() as i64)),
                    DomProp::HistoryState => Ok(self.current_history_state()),
                    DomProp::HistoryScrollRestoration => {
                        Ok(Value::String(self.history_scroll_restoration.clone()))
                    }
                    DomProp::DefaultView => {
                        Ok(env.get("window").cloned().unwrap_or(Value::Undefined))
                    }
                    DomProp::Hidden => Ok(Value::Bool(false)),
                    DomProp::VisibilityState => Ok(Value::String("visible".to_string())),
                    DomProp::Forms => Ok(Value::NodeList(self.dom.query_selector_all("form")?)),
                    DomProp::Images => Ok(Value::NodeList(self.dom.query_selector_all("img")?)),
                    DomProp::Links => Ok(Value::NodeList(
                        self.dom.query_selector_all("a[href], area[href]")?,
                    )),
                    DomProp::Scripts => Ok(Value::NodeList(self.dom.query_selector_all("script")?)),
                    DomProp::Children => Ok(Value::NodeList(self.dom.child_elements(node))),
                    DomProp::ChildElementCount => {
                        Ok(Value::Number(self.dom.child_element_count(node) as i64))
                    }
                    DomProp::FirstElementChild => Ok(self
                        .dom
                        .first_element_child(node)
                        .map(Value::Node)
                        .unwrap_or(Value::Null)),
                    DomProp::LastElementChild => Ok(self
                        .dom
                        .last_element_child(node)
                        .map(Value::Node)
                        .unwrap_or(Value::Null)),
                    DomProp::CurrentScript => Ok(Value::Null),
                    DomProp::FormsLength => Ok(Value::Number(
                        self.dom.query_selector_all("form")?.len() as i64,
                    )),
                    DomProp::ImagesLength => Ok(Value::Number(
                        self.dom.query_selector_all("img")?.len() as i64,
                    )),
                    DomProp::LinksLength => Ok(Value::Number(
                        self.dom.query_selector_all("a[href], area[href]")?.len() as i64,
                    )),
                    DomProp::ScriptsLength => Ok(Value::Number(
                        self.dom.query_selector_all("script")?.len() as i64,
                    )),
                    DomProp::ChildrenLength => {
                        Ok(Value::Number(self.dom.child_element_count(node) as i64))
                    }
                }
            }
            Expr::LocationMethodCall { method, url } => match method {
                LocationMethod::Assign => {
                    let Some(url_expr) = url else {
                        return Err(Error::ScriptRuntime(
                            "location.assign requires exactly one argument".into(),
                        ));
                    };
                    let url = self
                        .eval_expr(url_expr, env, event_param, event)?
                        .as_string();
                    self.navigate_location(&url, LocationNavigationKind::Assign)?;
                    Ok(Value::Undefined)
                }
                LocationMethod::Reload => {
                    self.reload_location()?;
                    Ok(Value::Undefined)
                }
                LocationMethod::Replace => {
                    let Some(url_expr) = url else {
                        return Err(Error::ScriptRuntime(
                            "location.replace requires exactly one argument".into(),
                        ));
                    };
                    let url = self
                        .eval_expr(url_expr, env, event_param, event)?
                        .as_string();
                    self.navigate_location(&url, LocationNavigationKind::Replace)?;
                    Ok(Value::Undefined)
                }
                LocationMethod::ToString => Ok(Value::String(self.document_url.clone())),
            },
            Expr::HistoryMethodCall { method, args } => match method {
                HistoryMethod::Back => {
                    let _ = args;
                    self.history_go_with_env(-1)?;
                    Ok(Value::Undefined)
                }
                HistoryMethod::Forward => {
                    let _ = args;
                    self.history_go_with_env(1)?;
                    Ok(Value::Undefined)
                }
                HistoryMethod::Go => {
                    let delta = if let Some(delta) = args.first() {
                        let value = self.eval_expr(delta, env, event_param, event)?;
                        Self::value_to_i64(&value)
                    } else {
                        0
                    };
                    self.history_go_with_env(delta)?;
                    Ok(Value::Undefined)
                }
                HistoryMethod::PushState => {
                    let state = self.eval_expr(&args[0], env, event_param, event)?;
                    let url = if args.len() >= 3 {
                        Some(
                            self.eval_expr(&args[2], env, event_param, event)?
                                .as_string(),
                        )
                    } else {
                        None
                    };
                    self.history_push_state(state, url.as_deref(), false)?;
                    Ok(Value::Undefined)
                }
                HistoryMethod::ReplaceState => {
                    let state = self.eval_expr(&args[0], env, event_param, event)?;
                    let url = if args.len() >= 3 {
                        Some(
                            self.eval_expr(&args[2], env, event_param, event)?
                                .as_string(),
                        )
                    } else {
                        None
                    };
                    self.history_push_state(state, url.as_deref(), true)?;
                    Ok(Value::Undefined)
                }
            },
            Expr::ClipboardMethodCall { method, args } => match method {
                ClipboardMethod::ReadText => {
                    let _ = args;
                    let promise = self.new_pending_promise();
                    self.promise_resolve(&promise, Value::String(self.clipboard_text.clone()))?;
                    Ok(Value::Promise(promise))
                }
                ClipboardMethod::WriteText => {
                    let text = self
                        .eval_expr(&args[0], env, event_param, event)?
                        .as_string();
                    self.clipboard_text = text;
                    let promise = self.new_pending_promise();
                    self.promise_resolve(&promise, Value::Undefined)?;
                    Ok(Value::Promise(promise))
                }
            },
            Expr::DocumentHasFocus => Ok(Value::Bool(self.active_element.is_some())),
            Expr::DomMatches { target, selector } => {
                let node = self.resolve_dom_query_required_runtime(target, env)?;
                let result = self.dom.matches_selector(node, selector)?;
                Ok(Value::Bool(result))
            }
            Expr::DomClosest { target, selector } => {
                let node = self.resolve_dom_query_required_runtime(target, env)?;
                let result = self.dom.closest(node, selector)?;
                Ok(result.map_or(Value::Null, Value::Node))
            }
            Expr::DomComputedStyleProperty { target, property } => {
                let node = self.resolve_dom_query_required_runtime(target, env)?;
                Ok(Value::String(self.dom.style_get(node, property)?))
            }
            Expr::ClassListContains { target, class_name } => {
                let node = self.resolve_dom_query_required_runtime(target, env)?;
                Ok(Value::Bool(self.dom.class_contains(node, class_name)?))
            }
            Expr::QuerySelectorAllLength { target } => {
                let len = self
                    .resolve_dom_query_list_runtime(target, env)?
                    .unwrap_or_default()
                    .len() as i64;
                Ok(Value::Number(len))
            }
            Expr::FormElementsLength { form } => {
                let form_node = self.resolve_dom_query_required_runtime(form, env)?;
                let len = self.form_elements(form_node)?.len() as i64;
                Ok(Value::Number(len))
            }
            Expr::FormDataNew { form } => {
                let form_node = self.resolve_dom_query_required_runtime(form, env)?;
                Ok(Value::FormData(self.form_data_entries(form_node)?))
            }
            Expr::FormDataGet { source, name } => {
                let entries = self.eval_form_data_source(source, env)?;
                let value = entries
                    .iter()
                    .find_map(|(entry_name, value)| (entry_name == name).then(|| value.clone()))
                    .unwrap_or_default();
                Ok(Value::String(value))
            }
            Expr::FormDataHas { source, name } => {
                let entries = self.eval_form_data_source(source, env)?;
                let has = entries.iter().any(|(entry_name, _)| entry_name == name);
                Ok(Value::Bool(has))
            }
            Expr::FormDataGetAll { source, name } => {
                let entries = self.eval_form_data_source(source, env)?;
                let values = entries
                    .iter()
                    .filter(|(entry_name, _)| entry_name == name)
                    .map(|(_, value)| Value::String(value.clone()))
                    .collect::<Vec<_>>();
                Ok(Self::new_array_value(values))
            }
            Expr::FormDataGetAllLength { source, name } => {
                let entries = self.eval_form_data_source(source, env)?;
                let len = entries
                    .iter()
                    .filter(|(entry_name, _)| entry_name == name)
                    .count() as i64;
                Ok(Value::Number(len))
            }
            Expr::DomGetAttribute { target, name } => {
                let node = self.resolve_dom_query_required_runtime(target, env)?;
                Ok(Value::String(self.dom.attr(node, name).unwrap_or_default()))
            }
            Expr::DomHasAttribute { target, name } => {
                let node = self.resolve_dom_query_required_runtime(target, env)?;
                Ok(Value::Bool(self.dom.has_attr(node, name)?))
            }
            Expr::EventProp { event_var, prop } => {
                let Some(param) = event_param else {
                    return Err(Error::ScriptRuntime(format!(
                        "event variable '{}' is not available in this handler",
                        event_var
                    )));
                };
                if param != event_var {
                    return Err(Error::ScriptRuntime(format!(
                        "unknown event variable: {}",
                        event_var
                    )));
                }

                let value = match prop {
                    EventExprProp::Type => Value::String(event.event_type.clone()),
                    EventExprProp::Target => Value::String(self.event_node_label(event.target)),
                    EventExprProp::CurrentTarget => {
                        Value::String(self.event_node_label(event.current_target))
                    }
                    EventExprProp::TargetName => {
                        Value::String(self.dom.attr(event.target, "name").unwrap_or_default())
                    }
                    EventExprProp::CurrentTargetName => Value::String(
                        self.dom
                            .attr(event.current_target, "name")
                            .unwrap_or_default(),
                    ),
                    EventExprProp::DefaultPrevented => Value::Bool(event.default_prevented),
                    EventExprProp::IsTrusted => Value::Bool(event.is_trusted),
                    EventExprProp::Bubbles => Value::Bool(event.bubbles),
                    EventExprProp::Cancelable => Value::Bool(event.cancelable),
                    EventExprProp::TargetId => {
                        Value::String(self.dom.attr(event.target, "id").unwrap_or_default())
                    }
                    EventExprProp::CurrentTargetId => Value::String(
                        self.dom
                            .attr(event.current_target, "id")
                            .unwrap_or_default(),
                    ),
                    EventExprProp::EventPhase => Value::Number(event.event_phase as i64),
                    EventExprProp::TimeStamp => Value::Number(event.time_stamp_ms),
                    EventExprProp::State => {
                        event.state.as_ref().cloned().unwrap_or(Value::Undefined)
                    }
                    EventExprProp::OldState => event
                        .old_state
                        .as_ref()
                        .map(|value| Value::String(value.clone()))
                        .unwrap_or(Value::Undefined),
                    EventExprProp::NewState => event
                        .new_state
                        .as_ref()
                        .map(|value| Value::String(value.clone()))
                        .unwrap_or(Value::Undefined),
                };
                Ok(value)
            }
            Expr::Neg(inner) => {
                let value = self.eval_expr(inner, env, event_param, event)?;
                if matches!(value, Value::Symbol(_)) {
                    return Err(Error::ScriptRuntime(
                        "Cannot convert a Symbol value to a number".into(),
                    ));
                }
                match value {
                    Value::Number(v) => Ok(Value::Number(-v)),
                    Value::Float(v) => Ok(Value::Float(-v)),
                    Value::BigInt(v) => Ok(Value::BigInt(-v)),
                    other => Ok(Value::Float(-self.numeric_value(&other))),
                }
            }
            Expr::Pos(inner) => {
                let value = self.eval_expr(inner, env, event_param, event)?;
                if matches!(value, Value::BigInt(_)) {
                    return Err(Error::ScriptRuntime(
                        "unary plus is not supported for BigInt values".into(),
                    ));
                }
                if matches!(value, Value::Symbol(_)) {
                    return Err(Error::ScriptRuntime(
                        "Cannot convert a Symbol value to a number".into(),
                    ));
                }
                Ok(Value::Float(self.numeric_value(&value)))
            }
            Expr::BitNot(inner) => {
                let value = self.eval_expr(inner, env, event_param, event)?;
                if matches!(value, Value::Symbol(_)) {
                    return Err(Error::ScriptRuntime(
                        "Cannot convert a Symbol value to a number".into(),
                    ));
                }
                if let Value::BigInt(v) = value {
                    return Ok(Value::BigInt(!v));
                }
                Ok(Value::Number((!self.to_i32_for_bitwise(&value)) as i64))
            }
            Expr::Not(inner) => {
                let value = self.eval_expr(inner, env, event_param, event)?;
                Ok(Value::Bool(!value.truthy()))
            }
            Expr::Void(inner) => {
                self.eval_expr(inner, env, event_param, event)?;
                Ok(Value::Undefined)
            }
            Expr::Delete(inner) => match inner.as_ref() {
                Expr::Var(name) => Ok(Value::Bool(!env.contains_key(name))),
                _ => {
                    self.eval_expr(inner, env, event_param, event)?;
                    Ok(Value::Bool(true))
                }
            },
            Expr::TypeOf(inner) => {
                let js_type = match inner.as_ref() {
                    Expr::Var(name) => env.get(name).map_or("undefined", |value| match value {
                        Value::Null => "object",
                        Value::Bool(_) => "boolean",
                        Value::Number(_) | Value::Float(_) => "number",
                        Value::BigInt(_) => "bigint",
                        Value::Symbol(_) => "symbol",
                        Value::Undefined => "undefined",
                        Value::String(_) => "string",
                        Value::StringConstructor => "function",
                        Value::TypedArrayConstructor(_)
                        | Value::ArrayBufferConstructor
                        | Value::PromiseConstructor
                        | Value::MapConstructor
                        | Value::SetConstructor
                        | Value::SymbolConstructor
                        | Value::RegExpConstructor
                        | Value::PromiseCapability(_) => "function",
                        Value::Function(_) => "function",
                        Value::Node(_)
                        | Value::NodeList(_)
                        | Value::FormData(_)
                        | Value::Array(_)
                        | Value::Object(_)
                        | Value::Map(_)
                        | Value::Set(_)
                        | Value::Promise(_)
                        | Value::ArrayBuffer(_)
                        | Value::TypedArray(_)
                        | Value::RegExp(_)
                        | Value::Date(_) => "object",
                    }),
                    _ => {
                        let value = self.eval_expr(inner, env, event_param, event)?;
                        match value {
                            Value::Null => "object",
                            Value::Bool(_) => "boolean",
                            Value::Number(_) | Value::Float(_) => "number",
                            Value::BigInt(_) => "bigint",
                            Value::Symbol(_) => "symbol",
                            Value::Undefined => "undefined",
                            Value::String(_) => "string",
                            Value::StringConstructor => "function",
                            Value::TypedArrayConstructor(_)
                            | Value::ArrayBufferConstructor
                            | Value::PromiseConstructor
                            | Value::MapConstructor
                            | Value::SetConstructor
                            | Value::SymbolConstructor
                            | Value::RegExpConstructor
                            | Value::PromiseCapability(_) => "function",
                            Value::Function(_) => "function",
                            Value::Node(_)
                            | Value::NodeList(_)
                            | Value::FormData(_)
                            | Value::Array(_)
                            | Value::Object(_)
                            | Value::Map(_)
                            | Value::Set(_)
                            | Value::Promise(_)
                            | Value::ArrayBuffer(_)
                            | Value::TypedArray(_)
                            | Value::RegExp(_)
                            | Value::Date(_) => "object",
                        }
                    }
                };
                Ok(Value::String(js_type.to_string()))
            }
            Expr::Await(inner) => {
                let value = self.eval_expr(inner, env, event_param, event)?;
                if let Value::Promise(promise) = value {
                    let settled = {
                        let promise = promise.borrow();
                        match &promise.state {
                            PromiseState::Pending => None,
                            PromiseState::Fulfilled(value) => {
                                Some(PromiseSettledValue::Fulfilled(value.clone()))
                            }
                            PromiseState::Rejected(reason) => {
                                Some(PromiseSettledValue::Rejected(reason.clone()))
                            }
                        }
                    };
                    match settled {
                        Some(PromiseSettledValue::Fulfilled(value)) => Ok(value),
                        Some(PromiseSettledValue::Rejected(reason)) => Err(Error::ScriptRuntime(
                            format!("await rejected Promise: {}", reason.as_string()),
                        )),
                        None => Ok(Value::Undefined),
                    }
                } else {
                    Ok(value)
                }
            }
            Expr::Yield(inner) => self.eval_expr(inner, env, event_param, event),
            Expr::YieldStar(inner) => self.eval_expr(inner, env, event_param, event),
            Expr::Comma(parts) => {
                let mut last = Value::Undefined;
                for part in parts {
                    last = self.eval_expr(part, env, event_param, event)?;
                }
                Ok(last)
            }
            Expr::Spread(_) => Err(Error::ScriptRuntime(
                "spread syntax is only supported in array and object literals".into(),
            )),
            Expr::Add(parts) => {
                if parts.is_empty() {
                    return Ok(Value::String(String::new()));
                }
                let mut iter = parts.iter();
                let first = iter
                    .next()
                    .ok_or_else(|| Error::ScriptRuntime("empty add expression".into()))?;
                let mut acc = self.eval_expr(first, env, event_param, event)?;
                for part in iter {
                    let rhs = self.eval_expr(part, env, event_param, event)?;
                    acc = self.add_values(&acc, &rhs)?;
                }
                Ok(acc)
            }
            Expr::Ternary {
                cond,
                on_true,
                on_false,
            } => {
                let cond = self.eval_expr(cond, env, event_param, event)?;
                if cond.truthy() {
                    self.eval_expr(on_true, env, event_param, event)
                } else {
                    self.eval_expr(on_false, env, event_param, event)
                }
            }
        }
    }

    fn eval_binary(&self, op: &BinaryOp, left: &Value, right: &Value) -> Result<Value> {
        if matches!(left, Value::Symbol(_)) || matches!(right, Value::Symbol(_)) {
            if matches!(
                op,
                BinaryOp::BitOr
                    | BinaryOp::BitXor
                    | BinaryOp::BitAnd
                    | BinaryOp::ShiftLeft
                    | BinaryOp::ShiftRight
                    | BinaryOp::UnsignedShiftRight
                    | BinaryOp::Pow
                    | BinaryOp::Lt
                    | BinaryOp::Gt
                    | BinaryOp::Le
                    | BinaryOp::Ge
                    | BinaryOp::Sub
                    | BinaryOp::Mul
                    | BinaryOp::Mod
                    | BinaryOp::Div
            ) {
                return Err(Error::ScriptRuntime(
                    "Cannot convert a Symbol value to a number".into(),
                ));
            }
        }
        let out = match op {
            BinaryOp::Or => Value::Bool(left.truthy() || right.truthy()),
            BinaryOp::And => Value::Bool(left.truthy() && right.truthy()),
            BinaryOp::Nullish => {
                if matches!(left, Value::Null | Value::Undefined) {
                    right.clone()
                } else {
                    left.clone()
                }
            }
            BinaryOp::Eq => Value::Bool(self.loose_equal(left, right)),
            BinaryOp::Ne => Value::Bool(!self.loose_equal(left, right)),
            BinaryOp::StrictEq => Value::Bool(self.strict_equal(left, right)),
            BinaryOp::StrictNe => Value::Bool(!self.strict_equal(left, right)),
            BinaryOp::In => Value::Bool(self.value_in(left, right)),
            BinaryOp::InstanceOf => Value::Bool(self.value_instance_of(left, right)),
            BinaryOp::BitOr => {
                if let (Value::BigInt(l), Value::BigInt(r)) = (left, right) {
                    return Ok(Value::BigInt(l | r));
                }
                if matches!(left, Value::BigInt(_)) || matches!(right, Value::BigInt(_)) {
                    return Err(Error::ScriptRuntime(
                        "cannot mix BigInt and other types in bitwise operations".into(),
                    ));
                }
                Value::Number(i64::from(
                    self.to_i32_for_bitwise(left) | self.to_i32_for_bitwise(right),
                ))
            }
            BinaryOp::BitXor => {
                if let (Value::BigInt(l), Value::BigInt(r)) = (left, right) {
                    return Ok(Value::BigInt(l ^ r));
                }
                if matches!(left, Value::BigInt(_)) || matches!(right, Value::BigInt(_)) {
                    return Err(Error::ScriptRuntime(
                        "cannot mix BigInt and other types in bitwise operations".into(),
                    ));
                }
                Value::Number(i64::from(
                    self.to_i32_for_bitwise(left) ^ self.to_i32_for_bitwise(right),
                ))
            }
            BinaryOp::BitAnd => {
                if let (Value::BigInt(l), Value::BigInt(r)) = (left, right) {
                    return Ok(Value::BigInt(l & r));
                }
                if matches!(left, Value::BigInt(_)) || matches!(right, Value::BigInt(_)) {
                    return Err(Error::ScriptRuntime(
                        "cannot mix BigInt and other types in bitwise operations".into(),
                    ));
                }
                Value::Number(i64::from(
                    self.to_i32_for_bitwise(left) & self.to_i32_for_bitwise(right),
                ))
            }
            BinaryOp::ShiftLeft => {
                if let (Value::BigInt(l), Value::BigInt(r)) = (left, right) {
                    return Ok(Value::BigInt(Self::bigint_shift_left(l, r)?));
                }
                if matches!(left, Value::BigInt(_)) || matches!(right, Value::BigInt(_)) {
                    return Err(Error::ScriptRuntime(
                        "cannot mix BigInt and other types in bitwise operations".into(),
                    ));
                }
                let shift = self.to_u32_for_bitwise(right) & 0x1f;
                Value::Number(i64::from(self.to_i32_for_bitwise(left) << shift))
            }
            BinaryOp::ShiftRight => {
                if let (Value::BigInt(l), Value::BigInt(r)) = (left, right) {
                    return Ok(Value::BigInt(Self::bigint_shift_right(l, r)?));
                }
                if matches!(left, Value::BigInt(_)) || matches!(right, Value::BigInt(_)) {
                    return Err(Error::ScriptRuntime(
                        "cannot mix BigInt and other types in bitwise operations".into(),
                    ));
                }
                let shift = self.to_u32_for_bitwise(right) & 0x1f;
                Value::Number(i64::from(self.to_i32_for_bitwise(left) >> shift))
            }
            BinaryOp::UnsignedShiftRight => {
                if matches!(left, Value::BigInt(_)) || matches!(right, Value::BigInt(_)) {
                    return Err(Error::ScriptRuntime(
                        "BigInt values do not support unsigned right shift".into(),
                    ));
                }
                let shift = self.to_u32_for_bitwise(right) & 0x1f;
                Value::Number(i64::from(self.to_u32_for_bitwise(left) >> shift))
            }
            BinaryOp::Pow => {
                if let (Value::BigInt(l), Value::BigInt(r)) = (left, right) {
                    if r.sign() == Sign::Minus {
                        return Err(Error::ScriptRuntime(
                            "BigInt exponent must be non-negative".into(),
                        ));
                    }
                    let exp = r.to_u32().ok_or_else(|| {
                        Error::ScriptRuntime("BigInt exponent is too large".into())
                    })?;
                    return Ok(Value::BigInt(l.pow(exp)));
                }
                if matches!(left, Value::BigInt(_)) || matches!(right, Value::BigInt(_)) {
                    return Err(Error::ScriptRuntime(
                        "cannot mix BigInt and other types in arithmetic operations".into(),
                    ));
                }
                Value::Float(self.numeric_value(left).powf(self.numeric_value(right)))
            }
            BinaryOp::Lt => Value::Bool(self.compare(left, right, |l, r| l < r)),
            BinaryOp::Gt => Value::Bool(self.compare(left, right, |l, r| l > r)),
            BinaryOp::Le => Value::Bool(self.compare(left, right, |l, r| l <= r)),
            BinaryOp::Ge => Value::Bool(self.compare(left, right, |l, r| l >= r)),
            BinaryOp::Sub => {
                if let (Value::BigInt(l), Value::BigInt(r)) = (left, right) {
                    return Ok(Value::BigInt(l - r));
                }
                if matches!(left, Value::BigInt(_)) || matches!(right, Value::BigInt(_)) {
                    return Err(Error::ScriptRuntime(
                        "cannot mix BigInt and other types in arithmetic operations".into(),
                    ));
                }
                Value::Float(self.numeric_value(left) - self.numeric_value(right))
            }
            BinaryOp::Mul => {
                if let (Value::BigInt(l), Value::BigInt(r)) = (left, right) {
                    return Ok(Value::BigInt(l * r));
                }
                if matches!(left, Value::BigInt(_)) || matches!(right, Value::BigInt(_)) {
                    return Err(Error::ScriptRuntime(
                        "cannot mix BigInt and other types in arithmetic operations".into(),
                    ));
                }
                Value::Float(self.numeric_value(left) * self.numeric_value(right))
            }
            BinaryOp::Mod => {
                if let (Value::BigInt(l), Value::BigInt(r)) = (left, right) {
                    if r.is_zero() {
                        return Err(Error::ScriptRuntime("modulo by zero".into()));
                    }
                    return Ok(Value::BigInt(l % r));
                }
                if matches!(left, Value::BigInt(_)) || matches!(right, Value::BigInt(_)) {
                    return Err(Error::ScriptRuntime(
                        "cannot mix BigInt and other types in arithmetic operations".into(),
                    ));
                }
                let rhs = self.numeric_value(right);
                if rhs == 0.0 {
                    return Err(Error::ScriptRuntime("modulo by zero".into()));
                }
                Value::Float(self.numeric_value(left) % rhs)
            }
            BinaryOp::Div => {
                if let (Value::BigInt(l), Value::BigInt(r)) = (left, right) {
                    if r.is_zero() {
                        return Err(Error::ScriptRuntime("division by zero".into()));
                    }
                    return Ok(Value::BigInt(l / r));
                }
                if matches!(left, Value::BigInt(_)) || matches!(right, Value::BigInt(_)) {
                    return Err(Error::ScriptRuntime(
                        "cannot mix BigInt and other types in arithmetic operations".into(),
                    ));
                }
                let rhs = self.numeric_value(right);
                if rhs == 0.0 {
                    return Err(Error::ScriptRuntime("division by zero".into()));
                }
                Value::Float(self.numeric_value(left) / rhs)
            }
        };
        Ok(out)
    }

    fn loose_equal(&self, left: &Value, right: &Value) -> bool {
        if self.strict_equal(left, right) {
            return true;
        }

        match (left, right) {
            (Value::Null, Value::Undefined) | (Value::Undefined, Value::Null) => true,
            (Value::BigInt(l), Value::String(r)) => {
                Self::parse_js_bigint_from_string(r).is_ok_and(|parsed| parsed == *l)
            }
            (Value::String(l), Value::BigInt(r)) => {
                Self::parse_js_bigint_from_string(l).is_ok_and(|parsed| parsed == *r)
            }
            (Value::BigInt(_), Value::Number(_) | Value::Float(_))
            | (Value::Number(_) | Value::Float(_), Value::BigInt(_)) => {
                Self::number_bigint_loose_equal(left, right)
            }
            (Value::Number(_) | Value::Float(_), Value::String(_))
            | (Value::String(_), Value::Number(_) | Value::Float(_)) => {
                Self::coerce_number_for_global(left) == Self::coerce_number_for_global(right)
            }
            (Value::Bool(_), _) => {
                let coerced = Value::Float(Self::coerce_number_for_global(left));
                self.loose_equal(&coerced, right)
            }
            (_, Value::Bool(_)) => {
                let coerced = Value::Float(Self::coerce_number_for_global(right));
                self.loose_equal(left, &coerced)
            }
            _ if Self::is_loose_primitive(left) && Self::is_loose_object(right) => {
                let prim = self.to_primitive_for_loose(right);
                self.loose_equal(left, &prim)
            }
            _ if Self::is_loose_object(left) && Self::is_loose_primitive(right) => {
                let prim = self.to_primitive_for_loose(left);
                self.loose_equal(&prim, right)
            }
            _ => false,
        }
    }

    fn is_loose_primitive(value: &Value) -> bool {
        matches!(
            value,
            Value::String(_)
                | Value::Bool(_)
                | Value::Number(_)
                | Value::Float(_)
                | Value::BigInt(_)
                | Value::Symbol(_)
                | Value::Null
                | Value::Undefined
        )
    }

    fn is_loose_object(value: &Value) -> bool {
        matches!(
            value,
            Value::Array(_)
                | Value::Object(_)
                | Value::Promise(_)
                | Value::Map(_)
                | Value::Set(_)
                | Value::ArrayBuffer(_)
                | Value::TypedArray(_)
                | Value::StringConstructor
                | Value::TypedArrayConstructor(_)
                | Value::ArrayBufferConstructor
                | Value::PromiseConstructor
                | Value::MapConstructor
                | Value::SetConstructor
                | Value::SymbolConstructor
                | Value::RegExpConstructor
                | Value::PromiseCapability(_)
                | Value::RegExp(_)
                | Value::Date(_)
                | Value::Node(_)
                | Value::NodeList(_)
                | Value::FormData(_)
                | Value::Function(_)
        )
    }

    fn to_primitive_for_loose(&self, value: &Value) -> Value {
        match value {
            Value::Object(entries) => {
                if let Some(wrapped) = Self::string_wrapper_value_from_object(&entries.borrow()) {
                    return Value::String(wrapped);
                }
                if let Some(id) = Self::symbol_wrapper_id_from_object(&entries.borrow()) {
                    if let Some(symbol) = self.symbols_by_id.get(&id) {
                        return Value::Symbol(symbol.clone());
                    }
                }
                Value::String(value.as_string())
            }
            Value::Array(_)
            | Value::Promise(_)
            | Value::Map(_)
            | Value::Set(_)
            | Value::ArrayBuffer(_)
            | Value::TypedArray(_)
            | Value::StringConstructor
            | Value::TypedArrayConstructor(_)
            | Value::ArrayBufferConstructor
            | Value::PromiseConstructor
            | Value::MapConstructor
            | Value::SetConstructor
            | Value::SymbolConstructor
            | Value::RegExpConstructor
            | Value::PromiseCapability(_)
            | Value::RegExp(_)
            | Value::Date(_)
            | Value::Node(_)
            | Value::NodeList(_)
            | Value::FormData(_)
            | Value::Function(_) => Value::String(value.as_string()),
            _ => value.clone(),
        }
    }

    fn value_in(&self, left: &Value, right: &Value) -> bool {
        match right {
            Value::NodeList(nodes) => self
                .value_as_index(left)
                .is_some_and(|index| index < nodes.len()),
            Value::Array(values) => self
                .value_as_index(left)
                .is_some_and(|index| index < values.borrow().len()),
            Value::TypedArray(values) => self
                .value_as_index(left)
                .is_some_and(|index| index < values.borrow().observed_length()),
            Value::Object(entries) => {
                let key = self.property_key_to_storage_key(left);
                entries.borrow().iter().any(|(name, _)| name == &key)
            }
            Value::FormData(entries) => {
                let key = left.as_string();
                entries.iter().any(|(name, _)| name == &key)
            }
            _ => false,
        }
    }

    fn value_instance_of(&self, left: &Value, right: &Value) -> bool {
        match (left, right) {
            (Value::Node(left), Value::Node(right)) => left == right,
            (Value::Node(left), Value::NodeList(nodes)) => nodes.contains(left),
            (Value::Array(left), Value::Array(right)) => Rc::ptr_eq(left, right),
            (Value::Map(left), Value::Map(right)) => Rc::ptr_eq(left, right),
            (Value::Set(left), Value::Set(right)) => Rc::ptr_eq(left, right),
            (Value::Promise(left), Value::Promise(right)) => Rc::ptr_eq(left, right),
            (Value::TypedArray(left), Value::TypedArray(right)) => Rc::ptr_eq(left, right),
            (Value::ArrayBuffer(left), Value::ArrayBuffer(right)) => Rc::ptr_eq(left, right),
            (Value::Object(left), Value::Object(right)) => Rc::ptr_eq(left, right),
            (Value::RegExp(left), Value::RegExp(right)) => Rc::ptr_eq(left, right),
            (Value::Symbol(left), Value::Symbol(right)) => left.id == right.id,
            (Value::Date(left), Value::Date(right)) => Rc::ptr_eq(left, right),
            (Value::FormData(left), Value::FormData(right)) => left == right,
            (Value::Object(left), Value::StringConstructor) => {
                Self::string_wrapper_value_from_object(&left.borrow()).is_some()
            }
            _ => false,
        }
    }

    fn value_as_index(&self, value: &Value) -> Option<usize> {
        match value {
            Value::Number(v) => usize::try_from(*v).ok(),
            Value::Float(v) => {
                if !v.is_finite() || v.fract() != 0.0 || *v < 0.0 {
                    None
                } else {
                    usize::try_from(*v as i64).ok()
                }
            }
            Value::BigInt(v) => v.to_usize(),
            Value::String(s) => {
                if let Ok(int) = s.parse::<i64>() {
                    usize::try_from(int).ok()
                } else if let Ok(float) = s.parse::<f64>() {
                    if float.fract() == 0.0 && float >= 0.0 {
                        usize::try_from(float as i64).ok()
                    } else {
                        None
                    }
                } else {
                    None
                }
            }
            _ => None,
        }
    }

    fn strict_equal(&self, left: &Value, right: &Value) -> bool {
        match (left, right) {
            (Value::Bool(l), Value::Bool(r)) => l == r,
            (Value::Number(l), Value::Number(r)) => l == r,
            (Value::Float(l), Value::Float(r)) => l == r,
            (Value::Number(l), Value::Float(r)) => (*l as f64) == *r,
            (Value::Float(l), Value::Number(r)) => *l == (*r as f64),
            (Value::BigInt(l), Value::BigInt(r)) => l == r,
            (Value::Symbol(l), Value::Symbol(r)) => l.id == r.id,
            (Value::String(l), Value::String(r)) => l == r,
            (Value::Node(l), Value::Node(r)) => l == r,
            (Value::Array(l), Value::Array(r)) => Rc::ptr_eq(l, r),
            (Value::Map(l), Value::Map(r)) => Rc::ptr_eq(l, r),
            (Value::Set(l), Value::Set(r)) => Rc::ptr_eq(l, r),
            (Value::Promise(l), Value::Promise(r)) => Rc::ptr_eq(l, r),
            (Value::TypedArray(l), Value::TypedArray(r)) => Rc::ptr_eq(l, r),
            (Value::ArrayBuffer(l), Value::ArrayBuffer(r)) => Rc::ptr_eq(l, r),
            (Value::StringConstructor, Value::StringConstructor) => true,
            (Value::TypedArrayConstructor(l), Value::TypedArrayConstructor(r)) => l == r,
            (Value::ArrayBufferConstructor, Value::ArrayBufferConstructor) => true,
            (Value::PromiseConstructor, Value::PromiseConstructor) => true,
            (Value::MapConstructor, Value::MapConstructor) => true,
            (Value::SetConstructor, Value::SetConstructor) => true,
            (Value::SymbolConstructor, Value::SymbolConstructor) => true,
            (Value::RegExpConstructor, Value::RegExpConstructor) => true,
            (Value::PromiseCapability(l), Value::PromiseCapability(r)) => Rc::ptr_eq(l, r),
            (Value::Object(l), Value::Object(r)) => Rc::ptr_eq(l, r),
            (Value::RegExp(l), Value::RegExp(r)) => Rc::ptr_eq(l, r),
            (Value::Date(l), Value::Date(r)) => Rc::ptr_eq(l, r),
            (Value::Function(l), Value::Function(r)) => Rc::ptr_eq(l, r),
            (Value::FormData(l), Value::FormData(r)) => l == r,
            (Value::Null, Value::Null) => true,
            (Value::Undefined, Value::Undefined) => true,
            _ => false,
        }
    }

    fn compare<F>(&self, left: &Value, right: &Value, op: F) -> bool
    where
        F: Fn(f64, f64) -> bool,
    {
        match (left, right) {
            (Value::String(l), Value::String(r)) => {
                let ordering = l.cmp(r);
                let cmp = if ordering.is_lt() {
                    -1.0
                } else if ordering.is_gt() {
                    1.0
                } else {
                    0.0
                };
                return op(cmp, 0.0);
            }
            (Value::BigInt(l), Value::BigInt(r)) => {
                return op(
                    l.to_f64().unwrap_or_else(|| {
                        if l.sign() == Sign::Minus {
                            f64::NEG_INFINITY
                        } else {
                            f64::INFINITY
                        }
                    }),
                    r.to_f64().unwrap_or_else(|| {
                        if r.sign() == Sign::Minus {
                            f64::NEG_INFINITY
                        } else {
                            f64::INFINITY
                        }
                    }),
                );
            }
            (Value::BigInt(l), Value::Number(_) | Value::Float(_)) => {
                let r = self.numeric_value(right);
                if r.is_nan() {
                    return false;
                }
                if let Some(rb) = Self::f64_to_bigint_if_integral(r) {
                    return op(
                        l.to_f64().unwrap_or_else(|| {
                            if l.sign() == Sign::Minus {
                                f64::NEG_INFINITY
                            } else {
                                f64::INFINITY
                            }
                        }),
                        rb.to_f64().unwrap_or_else(|| {
                            if rb.sign() == Sign::Minus {
                                f64::NEG_INFINITY
                            } else {
                                f64::INFINITY
                            }
                        }),
                    );
                }
                return op(
                    l.to_f64().unwrap_or_else(|| {
                        if l.sign() == Sign::Minus {
                            f64::NEG_INFINITY
                        } else {
                            f64::INFINITY
                        }
                    }),
                    r,
                );
            }
            (Value::Number(_) | Value::Float(_), Value::BigInt(r)) => {
                let l = self.numeric_value(left);
                if l.is_nan() {
                    return false;
                }
                if let Some(lb) = Self::f64_to_bigint_if_integral(l) {
                    return op(
                        lb.to_f64().unwrap_or_else(|| {
                            if lb.sign() == Sign::Minus {
                                f64::NEG_INFINITY
                            } else {
                                f64::INFINITY
                            }
                        }),
                        r.to_f64().unwrap_or_else(|| {
                            if r.sign() == Sign::Minus {
                                f64::NEG_INFINITY
                            } else {
                                f64::INFINITY
                            }
                        }),
                    );
                }
                return op(
                    l,
                    r.to_f64().unwrap_or_else(|| {
                        if r.sign() == Sign::Minus {
                            f64::NEG_INFINITY
                        } else {
                            f64::INFINITY
                        }
                    }),
                );
            }
            _ => {}
        }
        let l = self.numeric_value(left);
        let r = self.numeric_value(right);
        op(l, r)
    }

    fn number_bigint_loose_equal(left: &Value, right: &Value) -> bool {
        match (left, right) {
            (Value::BigInt(l), Value::Number(r)) => *l == JsBigInt::from(*r),
            (Value::BigInt(l), Value::Float(r)) => {
                Self::f64_to_bigint_if_integral(*r).is_some_and(|rb| rb == *l)
            }
            (Value::Number(l), Value::BigInt(r)) => JsBigInt::from(*l) == *r,
            (Value::Float(l), Value::BigInt(r)) => {
                Self::f64_to_bigint_if_integral(*l).is_some_and(|lb| lb == *r)
            }
            _ => false,
        }
    }

    fn f64_to_bigint_if_integral(value: f64) -> Option<JsBigInt> {
        if !value.is_finite() || value.fract() != 0.0 {
            return None;
        }
        if value >= i64::MIN as f64 && value <= i64::MAX as f64 {
            return Some(JsBigInt::from(value as i64));
        }
        let rendered = format!("{value:.0}");
        JsBigInt::parse_bytes(rendered.as_bytes(), 10)
    }

    fn add_values(&self, left: &Value, right: &Value) -> Result<Value> {
        if matches!(left, Value::Symbol(_)) || matches!(right, Value::Symbol(_)) {
            return Err(Error::ScriptRuntime(
                "Cannot convert a Symbol value to a string".into(),
            ));
        }
        if matches!(left, Value::String(_)) || matches!(right, Value::String(_)) {
            return Ok(Value::String(format!(
                "{}{}",
                left.as_string(),
                right.as_string()
            )));
        }

        if matches!(left, Value::BigInt(_)) || matches!(right, Value::BigInt(_)) {
            return match (left, right) {
                (Value::BigInt(l), Value::BigInt(r)) => Ok(Value::BigInt(l + r)),
                _ => Err(Error::ScriptRuntime(
                    "cannot mix BigInt and other types in addition".into(),
                )),
            };
        }

        match (left, right) {
            (Value::Number(l), Value::Number(r)) => {
                if let Some(sum) = l.checked_add(*r) {
                    Ok(Value::Number(sum))
                } else {
                    Ok(Value::Float((*l as f64) + (*r as f64)))
                }
            }
            _ => Ok(Value::Float(
                self.numeric_value(left) + self.numeric_value(right),
            )),
        }
    }

    fn new_array_value(values: Vec<Value>) -> Value {
        Value::Array(Rc::new(RefCell::new(values)))
    }

    fn new_object_value(entries: Vec<(String, Value)>) -> Value {
        Value::Object(Rc::new(RefCell::new(entries)))
    }

    fn new_string_wrapper_value(value: String) -> Value {
        Self::new_object_value(vec![(
            INTERNAL_STRING_WRAPPER_VALUE_KEY.to_string(),
            Value::String(value),
        )])
    }

    fn object_set_entry(entries: &mut Vec<(String, Value)>, key: String, value: Value) {
        if let Some((_, existing)) = entries.iter_mut().find(|(name, _)| name == &key) {
            *existing = value;
        } else {
            entries.push((key, value));
        }
    }

    fn object_get_entry(entries: &[(String, Value)], key: &str) -> Option<Value> {
        entries
            .iter()
            .find_map(|(name, value)| (name == key).then(|| value.clone()))
    }

    fn callable_kind_from_value(value: &Value) -> Option<&str> {
        let Value::Object(entries) = value else {
            return None;
        };
        let entries = entries.borrow();
        match Self::object_get_entry(&entries, INTERNAL_CALLABLE_KIND_KEY) {
            Some(Value::String(kind)) => Some(match kind.as_str() {
                "intl_collator_compare" => "intl_collator_compare",
                "intl_date_time_format" => "intl_date_time_format",
                "intl_duration_format" => "intl_duration_format",
                "intl_list_format" => "intl_list_format",
                "intl_number_format" => "intl_number_format",
                "intl_segmenter_segments_iterator" => "intl_segmenter_segments_iterator",
                "intl_segmenter_iterator_next" => "intl_segmenter_iterator_next",
                _ => return None,
            }),
            _ => None,
        }
    }

    fn object_property_from_value(&self, value: &Value, key: &str) -> Result<Value> {
        match value {
            Value::String(text) => {
                if key == "length" {
                    Ok(Value::Number(text.chars().count() as i64))
                } else if key == "constructor" {
                    Ok(Value::StringConstructor)
                } else if let Ok(index) = key.parse::<usize>() {
                    Ok(text
                        .chars()
                        .nth(index)
                        .map(|ch| Value::String(ch.to_string()))
                        .unwrap_or(Value::Undefined))
                } else {
                    Ok(Value::Undefined)
                }
            }
            Value::Array(values) => {
                let values = values.borrow();
                if key == "length" {
                    Ok(Value::Number(values.len() as i64))
                } else if let Ok(index) = key.parse::<usize>() {
                    Ok(values.get(index).cloned().unwrap_or(Value::Undefined))
                } else {
                    Ok(Value::Undefined)
                }
            }
            Value::Object(entries) => {
                let entries = entries.borrow();
                if let Some(text) = Self::string_wrapper_value_from_object(&entries) {
                    if key == "length" {
                        return Ok(Value::Number(text.chars().count() as i64));
                    }
                    if key == "constructor" {
                        return Ok(Value::StringConstructor);
                    }
                    if let Ok(index) = key.parse::<usize>() {
                        return Ok(text
                            .chars()
                            .nth(index)
                            .map(|ch| Value::String(ch.to_string()))
                            .unwrap_or(Value::Undefined));
                    }
                }
                Ok(Self::object_get_entry(&entries, key).unwrap_or(Value::Undefined))
            }
            Value::Promise(promise) => {
                if key == "constructor" {
                    Ok(Value::PromiseConstructor)
                } else {
                    let promise = promise.borrow();
                    if key == "status" {
                        let status = match &promise.state {
                            PromiseState::Pending => "pending",
                            PromiseState::Fulfilled(_) => "fulfilled",
                            PromiseState::Rejected(_) => "rejected",
                        };
                        Ok(Value::String(status.to_string()))
                    } else {
                        Ok(Value::Undefined)
                    }
                }
            }
            Value::Map(map) => {
                let map = map.borrow();
                if key == "size" {
                    Ok(Value::Number(map.entries.len() as i64))
                } else if key == "constructor" {
                    Ok(Value::MapConstructor)
                } else {
                    Ok(Self::object_get_entry(&map.properties, key).unwrap_or(Value::Undefined))
                }
            }
            Value::Set(set) => {
                let set = set.borrow();
                if key == "size" {
                    Ok(Value::Number(set.values.len() as i64))
                } else if key == "constructor" {
                    Ok(Value::SetConstructor)
                } else {
                    Ok(Self::object_get_entry(&set.properties, key).unwrap_or(Value::Undefined))
                }
            }
            Value::ArrayBuffer(_) => {
                if key == "constructor" {
                    Ok(Value::ArrayBufferConstructor)
                } else {
                    Ok(Value::Undefined)
                }
            }
            Value::Symbol(symbol) => {
                let value = match key {
                    "description" => symbol
                        .description
                        .as_ref()
                        .map(|value| Value::String(value.clone()))
                        .unwrap_or(Value::Undefined),
                    "constructor" => Value::SymbolConstructor,
                    _ => Value::Undefined,
                };
                Ok(value)
            }
            Value::RegExp(regex) => {
                let regex = regex.borrow();
                let value = match key {
                    "source" => Value::String(regex.source.clone()),
                    "flags" => Value::String(regex.flags.clone()),
                    "global" => Value::Bool(regex.global),
                    "ignoreCase" => Value::Bool(regex.ignore_case),
                    "multiline" => Value::Bool(regex.multiline),
                    "dotAll" => Value::Bool(regex.dot_all),
                    "sticky" => Value::Bool(regex.sticky),
                    "hasIndices" => Value::Bool(regex.has_indices),
                    "unicode" => Value::Bool(regex.unicode),
                    "unicodeSets" => Value::Bool(false),
                    "lastIndex" => Value::Number(regex.last_index as i64),
                    "constructor" => Value::RegExpConstructor,
                    _ => Self::object_get_entry(&regex.properties, key).unwrap_or(Value::Undefined),
                };
                Ok(value)
            }
            Value::StringConstructor => Ok(Value::Undefined),
            _ => Err(Error::ScriptRuntime("value is not an object".into())),
        }
    }

    fn object_key_from_dom_prop(prop: &DomProp) -> Option<&'static str> {
        match prop {
            DomProp::Value => Some("value"),
            DomProp::Checked => Some("checked"),
            DomProp::Open => Some("open"),
            DomProp::ReturnValue => Some("returnValue"),
            DomProp::ClosedBy => Some("closedBy"),
            DomProp::Readonly => Some("readOnly"),
            DomProp::Required => Some("required"),
            DomProp::Disabled => Some("disabled"),
            DomProp::TextContent => Some("textContent"),
            DomProp::InnerHtml => Some("innerHTML"),
            DomProp::ClassName => Some("className"),
            DomProp::Id => Some("id"),
            DomProp::Name => Some("name"),
            DomProp::OffsetWidth => Some("offsetWidth"),
            DomProp::OffsetHeight => Some("offsetHeight"),
            DomProp::OffsetLeft => Some("offsetLeft"),
            DomProp::OffsetTop => Some("offsetTop"),
            DomProp::ScrollWidth => Some("scrollWidth"),
            DomProp::ScrollHeight => Some("scrollHeight"),
            DomProp::ScrollLeft => Some("scrollLeft"),
            DomProp::ScrollTop => Some("scrollTop"),
            DomProp::Title => Some("title"),
            DomProp::Dataset(_)
            | DomProp::Style(_)
            | DomProp::ActiveElement
            | DomProp::CharacterSet
            | DomProp::CompatMode
            | DomProp::ContentType
            | DomProp::ReadyState
            | DomProp::Referrer
            | DomProp::Url
            | DomProp::DocumentUri
            | DomProp::Location
            | DomProp::LocationHref
            | DomProp::LocationProtocol
            | DomProp::LocationHost
            | DomProp::LocationHostname
            | DomProp::LocationPort
            | DomProp::LocationPathname
            | DomProp::LocationSearch
            | DomProp::LocationHash
            | DomProp::LocationOrigin
            | DomProp::LocationAncestorOrigins
            | DomProp::History
            | DomProp::HistoryLength
            | DomProp::HistoryState
            | DomProp::HistoryScrollRestoration
            | DomProp::DefaultView
            | DomProp::Hidden
            | DomProp::VisibilityState
            | DomProp::Forms
            | DomProp::Images
            | DomProp::Links
            | DomProp::Scripts
            | DomProp::Children
            | DomProp::ChildElementCount
            | DomProp::FirstElementChild
            | DomProp::LastElementChild
            | DomProp::CurrentScript
            | DomProp::FormsLength
            | DomProp::ImagesLength
            | DomProp::LinksLength
            | DomProp::ScriptsLength
            | DomProp::ChildrenLength => None,
        }
    }

    fn parse_json_text(src: &str) -> Result<Value> {
        let bytes = src.as_bytes();
        let mut i = 0usize;
        Self::json_skip_ws(bytes, &mut i);
        let value = Self::parse_json_value(src, bytes, &mut i)?;
        Self::json_skip_ws(bytes, &mut i);
        if i != bytes.len() {
            return Err(Error::ScriptRuntime(
                "JSON.parse invalid JSON: trailing characters".into(),
            ));
        }
        Ok(value)
    }

    fn parse_json_value(src: &str, bytes: &[u8], i: &mut usize) -> Result<Value> {
        Self::json_skip_ws(bytes, i);
        let Some(&b) = bytes.get(*i) else {
            return Err(Error::ScriptRuntime(
                "JSON.parse invalid JSON: unexpected end of input".into(),
            ));
        };

        match b {
            b'{' => Self::parse_json_object(src, bytes, i),
            b'[' => Self::parse_json_array(src, bytes, i),
            b'"' => Ok(Value::String(Self::parse_json_string(src, bytes, i)?)),
            b't' => {
                if Self::json_consume_ascii(bytes, i, "true") {
                    Ok(Value::Bool(true))
                } else {
                    Err(Error::ScriptRuntime(
                        "JSON.parse invalid JSON: unexpected token".into(),
                    ))
                }
            }
            b'f' => {
                if Self::json_consume_ascii(bytes, i, "false") {
                    Ok(Value::Bool(false))
                } else {
                    Err(Error::ScriptRuntime(
                        "JSON.parse invalid JSON: unexpected token".into(),
                    ))
                }
            }
            b'n' => {
                if Self::json_consume_ascii(bytes, i, "null") {
                    Ok(Value::Null)
                } else {
                    Err(Error::ScriptRuntime(
                        "JSON.parse invalid JSON: unexpected token".into(),
                    ))
                }
            }
            b'-' | b'0'..=b'9' => Self::parse_json_number(src, bytes, i),
            _ => Err(Error::ScriptRuntime(
                "JSON.parse invalid JSON: unexpected token".into(),
            )),
        }
    }

    fn parse_json_object(src: &str, bytes: &[u8], i: &mut usize) -> Result<Value> {
        *i += 1; // consume '{'
        Self::json_skip_ws(bytes, i);
        let mut entries = Vec::new();

        if bytes.get(*i) == Some(&b'}') {
            *i += 1;
            return Ok(Self::new_object_value(entries));
        }

        loop {
            Self::json_skip_ws(bytes, i);
            if bytes.get(*i) != Some(&b'"') {
                return Err(Error::ScriptRuntime(
                    "JSON.parse invalid JSON: object key must be string".into(),
                ));
            }
            let key = Self::parse_json_string(src, bytes, i)?;
            Self::json_skip_ws(bytes, i);
            if bytes.get(*i) != Some(&b':') {
                return Err(Error::ScriptRuntime(
                    "JSON.parse invalid JSON: expected ':' after object key".into(),
                ));
            }
            *i += 1;
            let value = Self::parse_json_value(src, bytes, i)?;
            Self::object_set_entry(&mut entries, key, value);
            Self::json_skip_ws(bytes, i);

            match bytes.get(*i) {
                Some(b',') => {
                    *i += 1;
                }
                Some(b'}') => {
                    *i += 1;
                    break;
                }
                _ => {
                    return Err(Error::ScriptRuntime(
                        "JSON.parse invalid JSON: expected ',' or '}'".into(),
                    ));
                }
            }
        }

        Ok(Self::new_object_value(entries))
    }

    fn parse_json_array(src: &str, bytes: &[u8], i: &mut usize) -> Result<Value> {
        *i += 1; // consume '['
        Self::json_skip_ws(bytes, i);
        let mut items = Vec::new();

        if bytes.get(*i) == Some(&b']') {
            *i += 1;
            return Ok(Self::new_array_value(items));
        }

        loop {
            let item = Self::parse_json_value(src, bytes, i)?;
            items.push(item);
            Self::json_skip_ws(bytes, i);
            match bytes.get(*i) {
                Some(b',') => {
                    *i += 1;
                }
                Some(b']') => {
                    *i += 1;
                    break;
                }
                _ => {
                    return Err(Error::ScriptRuntime(
                        "JSON.parse invalid JSON: expected ',' or ']'".into(),
                    ));
                }
            }
        }

        Ok(Self::new_array_value(items))
    }

    fn parse_json_string(src: &str, bytes: &[u8], i: &mut usize) -> Result<String> {
        if bytes.get(*i) != Some(&b'"') {
            return Err(Error::ScriptRuntime(
                "JSON.parse invalid JSON: expected string".into(),
            ));
        }
        *i += 1;
        let mut out = String::new();

        while *i < bytes.len() {
            let b = bytes[*i];
            if b == b'"' {
                *i += 1;
                return Ok(out);
            }
            if b < 0x20 {
                return Err(Error::ScriptRuntime(
                    "JSON.parse invalid JSON: unescaped control character in string".into(),
                ));
            }
            if b == b'\\' {
                *i += 1;
                let Some(&esc) = bytes.get(*i) else {
                    return Err(Error::ScriptRuntime(
                        "JSON.parse invalid JSON: unterminated escape sequence".into(),
                    ));
                };
                match esc {
                    b'"' => out.push('"'),
                    b'\\' => out.push('\\'),
                    b'/' => out.push('/'),
                    b'b' => out.push('\u{0008}'),
                    b'f' => out.push('\u{000C}'),
                    b'n' => out.push('\n'),
                    b'r' => out.push('\r'),
                    b't' => out.push('\t'),
                    b'u' => {
                        *i += 1;
                        let first = Self::parse_json_hex4(src, i)?;
                        if (0xD800..=0xDBFF).contains(&first) {
                            let Some(b'\\') = bytes.get(*i).copied() else {
                                return Err(Error::ScriptRuntime(
                                    "JSON.parse invalid JSON: invalid unicode surrogate pair"
                                        .into(),
                                ));
                            };
                            *i += 1;
                            let Some(b'u') = bytes.get(*i).copied() else {
                                return Err(Error::ScriptRuntime(
                                    "JSON.parse invalid JSON: invalid unicode surrogate pair"
                                        .into(),
                                ));
                            };
                            *i += 1;
                            let second = Self::parse_json_hex4(src, i)?;
                            if !(0xDC00..=0xDFFF).contains(&second) {
                                return Err(Error::ScriptRuntime(
                                    "JSON.parse invalid JSON: invalid unicode surrogate pair"
                                        .into(),
                                ));
                            }
                            let codepoint = 0x10000
                                + (((first as u32 - 0xD800) << 10) | (second as u32 - 0xDC00));
                            let Some(ch) = char::from_u32(codepoint) else {
                                return Err(Error::ScriptRuntime(
                                    "JSON.parse invalid JSON: invalid unicode escape".into(),
                                ));
                            };
                            out.push(ch);
                            continue;
                        } else if (0xDC00..=0xDFFF).contains(&first) {
                            return Err(Error::ScriptRuntime(
                                "JSON.parse invalid JSON: invalid unicode surrogate pair".into(),
                            ));
                        } else {
                            let Some(ch) = char::from_u32(first as u32) else {
                                return Err(Error::ScriptRuntime(
                                    "JSON.parse invalid JSON: invalid unicode escape".into(),
                                ));
                            };
                            out.push(ch);
                            continue;
                        }
                    }
                    _ => {
                        return Err(Error::ScriptRuntime(
                            "JSON.parse invalid JSON: invalid escape sequence".into(),
                        ));
                    }
                }
                *i += 1;
                continue;
            }

            if b.is_ascii() {
                out.push(b as char);
                *i += 1;
            } else {
                let rest = src.get(*i..).ok_or_else(|| {
                    Error::ScriptRuntime("JSON.parse invalid JSON: invalid utf-8".into())
                })?;
                let Some(ch) = rest.chars().next() else {
                    return Err(Error::ScriptRuntime(
                        "JSON.parse invalid JSON: invalid utf-8".into(),
                    ));
                };
                out.push(ch);
                *i += ch.len_utf8();
            }
        }

        Err(Error::ScriptRuntime(
            "JSON.parse invalid JSON: unterminated string".into(),
        ))
    }

    fn parse_json_hex4(src: &str, i: &mut usize) -> Result<u16> {
        let end = i.saturating_add(4);
        let segment = src.get(*i..end).ok_or_else(|| {
            Error::ScriptRuntime("JSON.parse invalid JSON: invalid unicode escape".into())
        })?;
        if !segment.as_bytes().iter().all(|b| b.is_ascii_hexdigit()) {
            return Err(Error::ScriptRuntime(
                "JSON.parse invalid JSON: invalid unicode escape".into(),
            ));
        }
        *i = end;
        u16::from_str_radix(segment, 16).map_err(|_| {
            Error::ScriptRuntime("JSON.parse invalid JSON: invalid unicode escape".into())
        })
    }

    fn parse_json_number(src: &str, bytes: &[u8], i: &mut usize) -> Result<Value> {
        let start = *i;

        if bytes.get(*i) == Some(&b'-') {
            *i += 1;
        }

        match bytes.get(*i).copied() {
            Some(b'0') => {
                *i += 1;
                if bytes.get(*i).is_some_and(u8::is_ascii_digit) {
                    return Err(Error::ScriptRuntime(
                        "JSON.parse invalid JSON: invalid number".into(),
                    ));
                }
            }
            Some(b'1'..=b'9') => {
                *i += 1;
                while bytes.get(*i).is_some_and(u8::is_ascii_digit) {
                    *i += 1;
                }
            }
            _ => {
                return Err(Error::ScriptRuntime(
                    "JSON.parse invalid JSON: invalid number".into(),
                ));
            }
        }

        if bytes.get(*i) == Some(&b'.') {
            *i += 1;
            if !bytes.get(*i).is_some_and(u8::is_ascii_digit) {
                return Err(Error::ScriptRuntime(
                    "JSON.parse invalid JSON: invalid number".into(),
                ));
            }
            while bytes.get(*i).is_some_and(u8::is_ascii_digit) {
                *i += 1;
            }
        }

        if bytes.get(*i).is_some_and(|b| *b == b'e' || *b == b'E') {
            *i += 1;
            if bytes.get(*i).is_some_and(|b| *b == b'+' || *b == b'-') {
                *i += 1;
            }
            if !bytes.get(*i).is_some_and(u8::is_ascii_digit) {
                return Err(Error::ScriptRuntime(
                    "JSON.parse invalid JSON: invalid number".into(),
                ));
            }
            while bytes.get(*i).is_some_and(u8::is_ascii_digit) {
                *i += 1;
            }
        }

        let token = src.get(start..*i).ok_or_else(|| {
            Error::ScriptRuntime("JSON.parse invalid JSON: invalid number".into())
        })?;
        if !token.contains('.') && !token.contains('e') && !token.contains('E') {
            if let Ok(n) = token.parse::<i64>() {
                return Ok(Value::Number(n));
            }
        }
        let n = token
            .parse::<f64>()
            .map_err(|_| Error::ScriptRuntime("JSON.parse invalid JSON: invalid number".into()))?;
        Ok(Value::Float(n))
    }

    fn json_skip_ws(bytes: &[u8], i: &mut usize) {
        while bytes.get(*i).is_some_and(|b| b.is_ascii_whitespace()) {
            *i += 1;
        }
    }

    fn json_consume_ascii(bytes: &[u8], i: &mut usize, token: &str) -> bool {
        let token_bytes = token.as_bytes();
        let end = i.saturating_add(token_bytes.len());
        if end <= bytes.len() && &bytes[*i..end] == token_bytes {
            *i = end;
            true
        } else {
            false
        }
    }

    fn json_stringify_top_level(value: &Value) -> Result<Option<String>> {
        let mut array_stack = Vec::new();
        let mut object_stack = Vec::new();
        Self::json_stringify_value(value, &mut array_stack, &mut object_stack)
    }

    fn json_stringify_value(
        value: &Value,
        array_stack: &mut Vec<usize>,
        object_stack: &mut Vec<usize>,
    ) -> Result<Option<String>> {
        match value {
            Value::String(v) => Ok(Some(format!("\"{}\"", Self::json_escape_string(v)))),
            Value::Bool(v) => Ok(Some(if *v { "true".into() } else { "false".into() })),
            Value::Number(v) => Ok(Some(v.to_string())),
            Value::Float(v) => {
                if v.is_finite() {
                    Ok(Some(format_float(*v)))
                } else {
                    Ok(Some("null".into()))
                }
            }
            Value::BigInt(_) => Err(Error::ScriptRuntime(
                "JSON.stringify does not support BigInt values".into(),
            )),
            Value::Null => Ok(Some("null".into())),
            Value::Undefined
            | Value::Node(_)
            | Value::NodeList(_)
            | Value::FormData(_)
            | Value::StringConstructor
            | Value::TypedArrayConstructor(_)
            | Value::ArrayBufferConstructor
            | Value::PromiseConstructor
            | Value::MapConstructor
            | Value::SetConstructor
            | Value::SymbolConstructor
            | Value::RegExpConstructor
            | Value::Symbol(_)
            | Value::PromiseCapability(_)
            | Value::Function(_) => Ok(None),
            Value::RegExp(_) => Ok(Some("{}".to_string())),
            Value::Date(v) => Ok(Some(format!(
                "\"{}\"",
                Self::json_escape_string(&Self::format_iso_8601_utc(*v.borrow()))
            ))),
            Value::Promise(_)
            | Value::Map(_)
            | Value::Set(_)
            | Value::ArrayBuffer(_)
            | Value::TypedArray(_) => Ok(Some("{}".to_string())),
            Value::Array(values) => {
                let ptr = Rc::as_ptr(values) as usize;
                if array_stack.contains(&ptr) {
                    return Err(Error::ScriptRuntime(
                        "JSON.stringify circular structure".into(),
                    ));
                }
                array_stack.push(ptr);

                let items = values.borrow();
                let mut out = String::from("[");
                for (idx, item) in items.iter().enumerate() {
                    if idx > 0 {
                        out.push(',');
                    }
                    let serialized = Self::json_stringify_value(item, array_stack, object_stack)?
                        .unwrap_or_else(|| "null".to_string());
                    out.push_str(&serialized);
                }
                out.push(']');

                array_stack.pop();
                Ok(Some(out))
            }
            Value::Object(entries) => {
                let ptr = Rc::as_ptr(entries) as usize;
                if object_stack.contains(&ptr) {
                    return Err(Error::ScriptRuntime(
                        "JSON.stringify circular structure".into(),
                    ));
                }
                object_stack.push(ptr);

                let entries = entries.borrow();
                let mut out = String::from("{");
                let mut wrote = false;
                for (key, value) in entries.iter() {
                    if Self::is_internal_object_key(key) {
                        continue;
                    }
                    let Some(serialized) =
                        Self::json_stringify_value(value, array_stack, object_stack)?
                    else {
                        continue;
                    };
                    if wrote {
                        out.push(',');
                    }
                    wrote = true;
                    out.push('"');
                    out.push_str(&Self::json_escape_string(key));
                    out.push_str("\":");
                    out.push_str(&serialized);
                }
                out.push('}');

                object_stack.pop();
                Ok(Some(out))
            }
        }
    }

    fn json_escape_string(src: &str) -> String {
        let mut out = String::new();
        for ch in src.chars() {
            match ch {
                '"' => out.push_str("\\\""),
                '\\' => out.push_str("\\\\"),
                '\u{0008}' => out.push_str("\\b"),
                '\u{000C}' => out.push_str("\\f"),
                '\n' => out.push_str("\\n"),
                '\r' => out.push_str("\\r"),
                '\t' => out.push_str("\\t"),
                c if c <= '\u{001F}' => {
                    out.push_str(&format!("\\u{:04X}", c as u32));
                }
                c => out.push(c),
            }
        }
        out
    }

    fn structured_clone_value(
        value: &Value,
        array_stack: &mut Vec<usize>,
        object_stack: &mut Vec<usize>,
    ) -> Result<Value> {
        match value {
            Value::String(v) => Ok(Value::String(v.clone())),
            Value::Bool(v) => Ok(Value::Bool(*v)),
            Value::Number(v) => Ok(Value::Number(*v)),
            Value::Float(v) => Ok(Value::Float(*v)),
            Value::BigInt(v) => Ok(Value::BigInt(v.clone())),
            Value::Null => Ok(Value::Null),
            Value::Undefined => Ok(Value::Undefined),
            Value::Date(v) => Ok(Value::Date(Rc::new(RefCell::new(*v.borrow())))),
            Value::RegExp(v) => {
                let v = v.borrow();
                let cloned = Self::new_regex_value(v.source.clone(), v.flags.clone())?;
                let Value::RegExp(cloned_regex) = &cloned else {
                    unreachable!("RegExp clone must produce RegExp value");
                };
                {
                    let mut cloned_regex = cloned_regex.borrow_mut();
                    cloned_regex.last_index = v.last_index;
                    cloned_regex.properties = v.properties.clone();
                }
                Ok(cloned)
            }
            Value::ArrayBuffer(buffer) => {
                let buffer = buffer.borrow();
                Ok(Value::ArrayBuffer(Rc::new(RefCell::new(
                    ArrayBufferValue {
                        bytes: buffer.bytes.clone(),
                        max_byte_length: buffer.max_byte_length,
                        detached: buffer.detached,
                    },
                ))))
            }
            Value::TypedArray(array) => {
                let array = array.borrow();
                let buffer = array.buffer.borrow();
                let cloned_buffer = Rc::new(RefCell::new(ArrayBufferValue {
                    bytes: buffer.bytes.clone(),
                    max_byte_length: buffer.max_byte_length,
                    detached: buffer.detached,
                }));
                Ok(Value::TypedArray(Rc::new(RefCell::new(TypedArrayValue {
                    kind: array.kind,
                    buffer: cloned_buffer,
                    byte_offset: array.byte_offset,
                    fixed_length: array.fixed_length,
                }))))
            }
            Value::Map(map) => {
                let map = map.borrow();
                Ok(Value::Map(Rc::new(RefCell::new(MapValue {
                    entries: map.entries.clone(),
                    properties: map.properties.clone(),
                }))))
            }
            Value::Set(set) => {
                let set = set.borrow();
                Ok(Value::Set(Rc::new(RefCell::new(SetValue {
                    values: set.values.clone(),
                    properties: set.properties.clone(),
                }))))
            }
            Value::Array(values) => {
                let ptr = Rc::as_ptr(values) as usize;
                if array_stack.contains(&ptr) {
                    return Err(Error::ScriptRuntime(
                        "structuredClone does not support circular values".into(),
                    ));
                }
                array_stack.push(ptr);

                let items = values.borrow();
                let mut cloned = Vec::with_capacity(items.len());
                for item in items.iter() {
                    cloned.push(Self::structured_clone_value(
                        item,
                        array_stack,
                        object_stack,
                    )?);
                }
                array_stack.pop();

                Ok(Self::new_array_value(cloned))
            }
            Value::Object(entries) => {
                let ptr = Rc::as_ptr(entries) as usize;
                if object_stack.contains(&ptr) {
                    return Err(Error::ScriptRuntime(
                        "structuredClone does not support circular values".into(),
                    ));
                }
                object_stack.push(ptr);

                let entries = entries.borrow();
                let mut cloned = Vec::with_capacity(entries.len());
                for (key, value) in entries.iter() {
                    let value = Self::structured_clone_value(value, array_stack, object_stack)?;
                    cloned.push((key.clone(), value));
                }
                object_stack.pop();

                Ok(Self::new_object_value(cloned))
            }
            Value::Node(_)
            | Value::NodeList(_)
            | Value::FormData(_)
            | Value::Promise(_)
            | Value::Symbol(_)
            | Value::StringConstructor
            | Value::TypedArrayConstructor(_)
            | Value::ArrayBufferConstructor
            | Value::PromiseConstructor
            | Value::MapConstructor
            | Value::SetConstructor
            | Value::SymbolConstructor
            | Value::RegExpConstructor
            | Value::PromiseCapability(_)
            | Value::Function(_) => Err(Error::ScriptRuntime(
                "structuredClone value is not cloneable".into(),
            )),
        }
    }

    fn analyze_regex_flags(flags: &str) -> std::result::Result<RegexFlags, String> {
        let mut info = RegexFlags {
            global: false,
            ignore_case: false,
            multiline: false,
            dot_all: false,
            sticky: false,
            has_indices: false,
            unicode: false,
        };
        let mut seen = HashSet::new();
        for ch in flags.chars() {
            if !seen.insert(ch) {
                return Err(format!("invalid regular expression flags: {flags}"));
            }
            match ch {
                'g' => info.global = true,
                'i' => info.ignore_case = true,
                'm' => info.multiline = true,
                's' => info.dot_all = true,
                'y' => info.sticky = true,
                'd' => info.has_indices = true,
                'u' => info.unicode = true,
                'v' => {
                    return Err("invalid regular expression flags: v flag is not supported".into());
                }
                _ => return Err(format!("invalid regular expression flags: {flags}")),
            }
        }
        Ok(info)
    }

    fn compile_regex(pattern: &str, info: RegexFlags) -> std::result::Result<Regex, regex::Error> {
        let mut builder = RegexBuilder::new(pattern);
        builder.case_insensitive(info.ignore_case);
        builder.multi_line(info.multiline);
        builder.dot_matches_new_line(info.dot_all);
        builder.build()
    }

    fn new_regex_value(pattern: String, flags: String) -> Result<Value> {
        let info = Self::analyze_regex_flags(&flags).map_err(Error::ScriptRuntime)?;
        let compiled = Self::compile_regex(&pattern, info).map_err(|err| {
            Error::ScriptRuntime(format!(
                "invalid regular expression: /{pattern}/{flags}: {err}"
            ))
        })?;
        Ok(Value::RegExp(Rc::new(RefCell::new(RegexValue {
            source: pattern,
            flags,
            global: info.global,
            ignore_case: info.ignore_case,
            multiline: info.multiline,
            dot_all: info.dot_all,
            sticky: info.sticky,
            has_indices: info.has_indices,
            unicode: info.unicode,
            compiled,
            last_index: 0,
            properties: Vec::new(),
        }))))
    }

    fn new_regex_from_values(pattern: &Value, flags: Option<&Value>) -> Result<Value> {
        let pattern_text = match pattern {
            Value::RegExp(value) => value.borrow().source.clone(),
            _ => pattern.as_string(),
        };
        let flags_text = if let Some(flags) = flags {
            flags.as_string()
        } else if let Value::RegExp(value) = pattern {
            value.borrow().flags.clone()
        } else {
            String::new()
        };
        Self::new_regex_value(pattern_text, flags_text)
    }

    fn resolve_regex_from_value(value: &Value) -> Result<Rc<RefCell<RegexValue>>> {
        match value {
            Value::RegExp(regex) => Ok(regex.clone()),
            _ => Err(Error::ScriptRuntime("value is not a RegExp".into())),
        }
    }

    fn regex_test(regex: &Rc<RefCell<RegexValue>>, input: &str) -> Result<bool> {
        Ok(Self::regex_exec_internal(regex, input)?.is_some())
    }

    fn regex_exec(regex: &Rc<RefCell<RegexValue>>, input: &str) -> Result<Option<Vec<String>>> {
        Self::regex_exec_internal(regex, input)
    }

    fn regex_exec_internal(
        regex: &Rc<RefCell<RegexValue>>,
        input: &str,
    ) -> Result<Option<Vec<String>>> {
        let mut regex = regex.borrow_mut();
        let start = if regex.global || regex.sticky {
            regex.last_index
        } else {
            0
        };
        if start > input.len() {
            regex.last_index = 0;
            return Ok(None);
        }

        let captures = regex.compiled.captures_at(input, start);

        let Some(captures) = captures else {
            if regex.global || regex.sticky {
                regex.last_index = 0;
            }
            return Ok(None);
        };

        let Some(full_match) = captures.get(0) else {
            if regex.global || regex.sticky {
                regex.last_index = 0;
            }
            return Ok(None);
        };

        if regex.sticky && full_match.start() != start {
            regex.last_index = 0;
            return Ok(None);
        }

        if regex.global || regex.sticky {
            regex.last_index = full_match.end();
        }

        let mut out = Vec::with_capacity(captures.len());
        for idx in 0..captures.len() {
            out.push(
                captures
                    .get(idx)
                    .map(|capture| capture.as_str().to_string())
                    .unwrap_or_default(),
            );
        }
        Ok(Some(out))
    }

    fn eval_math_method(
        &mut self,
        method: MathMethod,
        args: &[Expr],
        env: &HashMap<String, Value>,
        event_param: &Option<String>,
        event: &EventState,
    ) -> Result<Value> {
        let mut values = Vec::with_capacity(args.len());
        for arg in args {
            values.push(self.eval_expr(arg, env, event_param, event)?);
        }

        let single = |values: &[Value]| Self::coerce_number_for_global(&values[0]);

        match method {
            MathMethod::Abs => Ok(Value::Float(single(&values).abs())),
            MathMethod::Acos => Ok(Value::Float(single(&values).acos())),
            MathMethod::Acosh => Ok(Value::Float(single(&values).acosh())),
            MathMethod::Asin => Ok(Value::Float(single(&values).asin())),
            MathMethod::Asinh => Ok(Value::Float(single(&values).asinh())),
            MathMethod::Atan => Ok(Value::Float(single(&values).atan())),
            MathMethod::Atan2 => Ok(Value::Float(
                Self::coerce_number_for_global(&values[0])
                    .atan2(Self::coerce_number_for_global(&values[1])),
            )),
            MathMethod::Atanh => Ok(Value::Float(single(&values).atanh())),
            MathMethod::Cbrt => Ok(Value::Float(single(&values).cbrt())),
            MathMethod::Ceil => Ok(Value::Float(single(&values).ceil())),
            MathMethod::Clz32 => Ok(Value::Number(i64::from(
                Self::to_u32_for_math(&values[0]).leading_zeros(),
            ))),
            MathMethod::Cos => Ok(Value::Float(single(&values).cos())),
            MathMethod::Cosh => Ok(Value::Float(single(&values).cosh())),
            MathMethod::Exp => Ok(Value::Float(single(&values).exp())),
            MathMethod::Expm1 => Ok(Value::Float(single(&values).exp_m1())),
            MathMethod::Floor => Ok(Value::Float(single(&values).floor())),
            MathMethod::F16Round => Ok(Value::Float(Self::math_f16round(single(&values)))),
            MathMethod::FRound => Ok(Value::Float((single(&values) as f32) as f64)),
            MathMethod::Hypot => {
                let mut sum = 0.0f64;
                for value in values {
                    let value = Self::coerce_number_for_global(&value);
                    sum += value * value;
                }
                Ok(Value::Float(sum.sqrt()))
            }
            MathMethod::Imul => {
                let left = Self::to_i32_for_math(&values[0]);
                let right = Self::to_i32_for_math(&values[1]);
                Ok(Value::Number(i64::from(left.wrapping_mul(right))))
            }
            MathMethod::Log => Ok(Value::Float(single(&values).ln())),
            MathMethod::Log10 => Ok(Value::Float(single(&values).log10())),
            MathMethod::Log1p => Ok(Value::Float(single(&values).ln_1p())),
            MathMethod::Log2 => Ok(Value::Float(single(&values).log2())),
            MathMethod::Max => {
                let mut out = f64::NEG_INFINITY;
                for value in values {
                    out = out.max(Self::coerce_number_for_global(&value));
                }
                Ok(Value::Float(out))
            }
            MathMethod::Min => {
                let mut out = f64::INFINITY;
                for value in values {
                    out = out.min(Self::coerce_number_for_global(&value));
                }
                Ok(Value::Float(out))
            }
            MathMethod::Pow => Ok(Value::Float(
                Self::coerce_number_for_global(&values[0])
                    .powf(Self::coerce_number_for_global(&values[1])),
            )),
            MathMethod::Random => Ok(Value::Float(self.next_random_f64())),
            MathMethod::Round => Ok(Value::Float(Self::js_math_round(single(&values)))),
            MathMethod::Sign => Ok(Value::Float(Self::js_math_sign(single(&values)))),
            MathMethod::Sin => Ok(Value::Float(single(&values).sin())),
            MathMethod::Sinh => Ok(Value::Float(single(&values).sinh())),
            MathMethod::Sqrt => Ok(Value::Float(single(&values).sqrt())),
            MathMethod::SumPrecise => match &values[0] {
                Value::Array(values) => Ok(Value::Float(Self::sum_precise(&values.borrow()))),
                _ => Err(Error::ScriptRuntime(
                    "Math.sumPrecise argument must be an array".into(),
                )),
            },
            MathMethod::Tan => Ok(Value::Float(single(&values).tan())),
            MathMethod::Tanh => Ok(Value::Float(single(&values).tanh())),
            MathMethod::Trunc => Ok(Value::Float(single(&values).trunc())),
        }
    }

    fn eval_number_method(
        &mut self,
        method: NumberMethod,
        args: &[Expr],
        env: &HashMap<String, Value>,
        event_param: &Option<String>,
        event: &EventState,
    ) -> Result<Value> {
        let mut values = Vec::with_capacity(args.len());
        for arg in args {
            values.push(self.eval_expr(arg, env, event_param, event)?);
        }

        match method {
            NumberMethod::IsFinite => Ok(Value::Bool(
                Self::number_primitive_value(&values[0]).is_some_and(f64::is_finite),
            )),
            NumberMethod::IsInteger => Ok(Value::Bool(
                Self::number_primitive_value(&values[0])
                    .is_some_and(|value| value.is_finite() && value.fract() == 0.0),
            )),
            NumberMethod::IsNaN => Ok(Value::Bool(matches!(
                values[0],
                Value::Float(value) if value.is_nan()
            ))),
            NumberMethod::IsSafeInteger => Ok(Value::Bool(
                Self::number_primitive_value(&values[0]).is_some_and(|value| {
                    value.is_finite()
                        && value.fract() == 0.0
                        && value.abs() <= 9_007_199_254_740_991.0
                }),
            )),
            NumberMethod::ParseFloat => {
                Ok(Value::Float(parse_js_parse_float(&values[0].as_string())))
            }
            NumberMethod::ParseInt => {
                let radix = if values.len() == 2 {
                    Some(Self::value_to_i64(&values[1]))
                } else {
                    None
                };
                Ok(Value::Float(parse_js_parse_int(
                    &values[0].as_string(),
                    radix,
                )))
            }
        }
    }

    fn eval_number_instance_method(
        &mut self,
        method: NumberInstanceMethod,
        value: &Expr,
        args: &[Expr],
        env: &HashMap<String, Value>,
        event_param: &Option<String>,
        event: &EventState,
    ) -> Result<Value> {
        let value = self.eval_expr(value, env, event_param, event)?;
        let mut args_value = Vec::with_capacity(args.len());
        for arg in args {
            args_value.push(self.eval_expr(arg, env, event_param, event)?);
        }

        if let Value::BigInt(bigint) = &value {
            return match method {
                NumberInstanceMethod::ToLocaleString => Ok(Value::String(bigint.to_string())),
                NumberInstanceMethod::ToString => {
                    let radix = if let Some(arg) = args_value.first() {
                        let radix = Self::value_to_i64(arg);
                        if !(2..=36).contains(&radix) {
                            return Err(Error::ScriptRuntime(
                                "toString radix must be between 2 and 36".into(),
                            ));
                        }
                        radix as u32
                    } else {
                        10
                    };
                    Ok(Value::String(bigint.to_str_radix(radix)))
                }
                NumberInstanceMethod::ValueOf => Ok(Value::BigInt(bigint.clone())),
                NumberInstanceMethod::ToExponential
                | NumberInstanceMethod::ToFixed
                | NumberInstanceMethod::ToPrecision => Err(Error::ScriptRuntime(
                    "number formatting methods are not supported for BigInt values".into(),
                )),
            };
        }

        if let Value::Symbol(symbol) = &value {
            return match method {
                NumberInstanceMethod::ValueOf => Ok(Value::Symbol(symbol.clone())),
                NumberInstanceMethod::ToString | NumberInstanceMethod::ToLocaleString => {
                    if !args_value.is_empty() {
                        return Err(Error::ScriptRuntime(
                            "Symbol.toString does not take arguments".into(),
                        ));
                    }
                    Ok(Value::String(Value::Symbol(symbol.clone()).as_string()))
                }
                NumberInstanceMethod::ToExponential
                | NumberInstanceMethod::ToFixed
                | NumberInstanceMethod::ToPrecision => Err(Error::ScriptRuntime(
                    "Cannot convert a Symbol value to a number".into(),
                )),
            };
        }

        let numeric = Self::coerce_number_for_number_constructor(&value);

        match method {
            NumberInstanceMethod::ToExponential => {
                let fraction_digits = if let Some(arg) = args_value.first() {
                    let fraction_digits = Self::value_to_i64(arg);
                    if !(0..=100).contains(&fraction_digits) {
                        return Err(Error::ScriptRuntime(
                            "toExponential fractionDigits must be between 0 and 100".into(),
                        ));
                    }
                    Some(fraction_digits as usize)
                } else {
                    None
                };
                Ok(Value::String(Self::number_to_exponential(
                    numeric,
                    fraction_digits,
                )))
            }
            NumberInstanceMethod::ToFixed => {
                let fraction_digits = if let Some(arg) = args_value.first() {
                    let fraction_digits = Self::value_to_i64(arg);
                    if !(0..=100).contains(&fraction_digits) {
                        return Err(Error::ScriptRuntime(
                            "toFixed fractionDigits must be between 0 and 100".into(),
                        ));
                    }
                    fraction_digits as usize
                } else {
                    0
                };
                Ok(Value::String(Self::number_to_fixed(
                    numeric,
                    fraction_digits,
                )))
            }
            NumberInstanceMethod::ToLocaleString => {
                Ok(Value::String(Self::format_number_default(numeric)))
            }
            NumberInstanceMethod::ToPrecision => {
                if let Some(arg) = args_value.first() {
                    let precision = Self::value_to_i64(arg);
                    if !(1..=100).contains(&precision) {
                        return Err(Error::ScriptRuntime(
                            "toPrecision precision must be between 1 and 100".into(),
                        ));
                    }
                    Ok(Value::String(Self::number_to_precision(
                        numeric,
                        precision as usize,
                    )))
                } else {
                    Ok(Value::String(Self::format_number_default(numeric)))
                }
            }
            NumberInstanceMethod::ToString => {
                let radix = if let Some(arg) = args_value.first() {
                    let radix = Self::value_to_i64(arg);
                    if !(2..=36).contains(&radix) {
                        return Err(Error::ScriptRuntime(
                            "toString radix must be between 2 and 36".into(),
                        ));
                    }
                    radix as u32
                } else {
                    10
                };
                Ok(Value::String(Self::number_to_string_radix(numeric, radix)))
            }
            NumberInstanceMethod::ValueOf => Ok(Self::number_value(numeric)),
        }
    }

    fn eval_bigint_method(
        &mut self,
        method: BigIntMethod,
        args: &[Expr],
        env: &HashMap<String, Value>,
        event_param: &Option<String>,
        event: &EventState,
    ) -> Result<Value> {
        let mut values = Vec::with_capacity(args.len());
        for arg in args {
            values.push(self.eval_expr(arg, env, event_param, event)?);
        }
        let bits_i64 = Self::value_to_i64(&values[0]);
        if bits_i64 < 0 {
            return Err(Error::ScriptRuntime(
                "BigInt bit width must be a non-negative integer".into(),
            ));
        }
        let bits = usize::try_from(bits_i64)
            .map_err(|_| Error::ScriptRuntime("BigInt bit width is too large".into()))?;
        let value = Self::coerce_bigint_for_builtin_op(&values[1])?;
        let out = match method {
            BigIntMethod::AsIntN => Self::bigint_as_int_n(bits, &value),
            BigIntMethod::AsUintN => Self::bigint_as_uint_n(bits, &value),
        };
        Ok(Value::BigInt(out))
    }

    fn eval_bigint_instance_method(
        &mut self,
        method: BigIntInstanceMethod,
        value: &Expr,
        args: &[Expr],
        env: &HashMap<String, Value>,
        event_param: &Option<String>,
        event: &EventState,
    ) -> Result<Value> {
        let value = self.eval_expr(value, env, event_param, event)?;
        let value = Self::coerce_bigint_for_builtin_op(&value)?;
        let mut args_value = Vec::with_capacity(args.len());
        for arg in args {
            args_value.push(self.eval_expr(arg, env, event_param, event)?);
        }

        match method {
            BigIntInstanceMethod::ToLocaleString => Ok(Value::String(value.to_string())),
            BigIntInstanceMethod::ToString => {
                let radix = if let Some(arg) = args_value.first() {
                    let radix = Self::value_to_i64(arg);
                    if !(2..=36).contains(&radix) {
                        return Err(Error::ScriptRuntime(
                            "toString radix must be between 2 and 36".into(),
                        ));
                    }
                    radix as u32
                } else {
                    10
                };
                Ok(Value::String(value.to_str_radix(radix)))
            }
            BigIntInstanceMethod::ValueOf => Ok(Value::BigInt(value)),
        }
    }

    fn bigint_as_uint_n(bits: usize, value: &JsBigInt) -> JsBigInt {
        if bits == 0 {
            return JsBigInt::zero();
        }
        let modulo = JsBigInt::one() << bits;
        let mut out = value % &modulo;
        if out.sign() == Sign::Minus {
            out += &modulo;
        }
        out
    }

    fn bigint_as_int_n(bits: usize, value: &JsBigInt) -> JsBigInt {
        if bits == 0 {
            return JsBigInt::zero();
        }
        let modulo = JsBigInt::one() << bits;
        let threshold = JsBigInt::one() << (bits - 1);
        let unsigned = Self::bigint_as_uint_n(bits, value);
        if unsigned >= threshold {
            unsigned - modulo
        } else {
            unsigned
        }
    }

    fn coerce_bigint_for_constructor(value: &Value) -> Result<JsBigInt> {
        match value {
            Value::BigInt(value) => Ok(value.clone()),
            Value::Bool(value) => Ok(if *value {
                JsBigInt::one()
            } else {
                JsBigInt::zero()
            }),
            Value::Number(value) => Ok(JsBigInt::from(*value)),
            Value::Float(value) => {
                if value.is_finite() && value.fract() == 0.0 {
                    Ok(JsBigInt::from(*value as i64))
                } else {
                    Err(Error::ScriptRuntime(
                        "cannot convert Number value to BigInt".into(),
                    ))
                }
            }
            Value::String(value) => Self::parse_js_bigint_from_string(value),
            Value::Null | Value::Undefined => Err(Error::ScriptRuntime(
                "cannot convert null or undefined to BigInt".into(),
            )),
            Value::Date(value) => Ok(JsBigInt::from(*value.borrow())),
            Value::Array(values) => {
                let rendered = Value::Array(values.clone()).as_string();
                Self::parse_js_bigint_from_string(&rendered)
            }
            Value::Object(_)
            | Value::Promise(_)
            | Value::Map(_)
            | Value::Set(_)
            | Value::ArrayBuffer(_)
            | Value::TypedArray(_)
            | Value::StringConstructor
            | Value::TypedArrayConstructor(_)
            | Value::ArrayBufferConstructor
            | Value::PromiseConstructor
            | Value::MapConstructor
            | Value::SetConstructor
            | Value::SymbolConstructor
            | Value::RegExpConstructor
            | Value::PromiseCapability(_)
            | Value::Symbol(_)
            | Value::RegExp(_)
            | Value::Node(_)
            | Value::NodeList(_)
            | Value::FormData(_)
            | Value::Function(_) => Err(Error::ScriptRuntime(
                "cannot convert object value to BigInt".into(),
            )),
        }
    }

    fn coerce_bigint_for_builtin_op(value: &Value) -> Result<JsBigInt> {
        match value {
            Value::BigInt(value) => Ok(value.clone()),
            Value::Bool(value) => Ok(if *value {
                JsBigInt::one()
            } else {
                JsBigInt::zero()
            }),
            Value::String(value) => Self::parse_js_bigint_from_string(value),
            Value::Null | Value::Undefined => Err(Error::ScriptRuntime(
                "cannot convert null or undefined to BigInt".into(),
            )),
            Value::Number(_)
            | Value::Float(_)
            | Value::Date(_)
            | Value::Object(_)
            | Value::Promise(_)
            | Value::Map(_)
            | Value::Set(_)
            | Value::ArrayBuffer(_)
            | Value::TypedArray(_)
            | Value::StringConstructor
            | Value::TypedArrayConstructor(_)
            | Value::ArrayBufferConstructor
            | Value::PromiseConstructor
            | Value::MapConstructor
            | Value::SetConstructor
            | Value::SymbolConstructor
            | Value::RegExpConstructor
            | Value::PromiseCapability(_)
            | Value::Symbol(_)
            | Value::RegExp(_)
            | Value::Node(_)
            | Value::NodeList(_)
            | Value::FormData(_)
            | Value::Function(_)
            | Value::Array(_) => Err(Error::ScriptRuntime(
                "cannot convert value to BigInt".into(),
            )),
        }
    }

    fn parse_js_bigint_from_string(src: &str) -> Result<JsBigInt> {
        let trimmed = src.trim();
        if trimmed.is_empty() {
            return Ok(JsBigInt::zero());
        }

        if let Some(rest) = trimmed.strip_prefix('+') {
            return Self::parse_signed_decimal_bigint(rest, false);
        }
        if let Some(rest) = trimmed.strip_prefix('-') {
            return Self::parse_signed_decimal_bigint(rest, true);
        }

        if let Some(rest) = trimmed
            .strip_prefix("0x")
            .or_else(|| trimmed.strip_prefix("0X"))
        {
            return Self::parse_prefixed_bigint(rest, 16, trimmed);
        }
        if let Some(rest) = trimmed
            .strip_prefix("0o")
            .or_else(|| trimmed.strip_prefix("0O"))
        {
            return Self::parse_prefixed_bigint(rest, 8, trimmed);
        }
        if let Some(rest) = trimmed
            .strip_prefix("0b")
            .or_else(|| trimmed.strip_prefix("0B"))
        {
            return Self::parse_prefixed_bigint(rest, 2, trimmed);
        }

        Self::parse_signed_decimal_bigint(trimmed, false)
    }

    fn parse_prefixed_bigint(src: &str, radix: u32, original: &str) -> Result<JsBigInt> {
        if src.is_empty() {
            return Err(Error::ScriptRuntime(format!(
                "cannot convert {} to a BigInt",
                original
            )));
        }
        JsBigInt::parse_bytes(src.as_bytes(), radix)
            .ok_or_else(|| Error::ScriptRuntime(format!("cannot convert {} to a BigInt", original)))
    }

    fn parse_signed_decimal_bigint(src: &str, negative: bool) -> Result<JsBigInt> {
        let original = format!("{}{}", if negative { "-" } else { "" }, src);
        if src.is_empty() || !src.as_bytes().iter().all(u8::is_ascii_digit) {
            return Err(Error::ScriptRuntime(format!(
                "cannot convert {} to a BigInt",
                original
            )));
        }
        let mut value = JsBigInt::parse_bytes(src.as_bytes(), 10).ok_or_else(|| {
            Error::ScriptRuntime(format!("cannot convert {} to a BigInt", original))
        })?;
        if negative {
            value = -value;
        }
        Ok(value)
    }

    fn bigint_shift_left(value: &JsBigInt, shift: &JsBigInt) -> Result<JsBigInt> {
        if shift.sign() == Sign::Minus {
            let magnitude = (-shift)
                .to_usize()
                .ok_or_else(|| Error::ScriptRuntime("BigInt shift count is too large".into()))?;
            Ok(value >> magnitude)
        } else {
            let magnitude = shift
                .to_usize()
                .ok_or_else(|| Error::ScriptRuntime("BigInt shift count is too large".into()))?;
            Ok(value << magnitude)
        }
    }

    fn bigint_shift_right(value: &JsBigInt, shift: &JsBigInt) -> Result<JsBigInt> {
        if shift.sign() == Sign::Minus {
            let magnitude = (-shift)
                .to_usize()
                .ok_or_else(|| Error::ScriptRuntime("BigInt shift count is too large".into()))?;
            Ok(value << magnitude)
        } else {
            let magnitude = shift
                .to_usize()
                .ok_or_else(|| Error::ScriptRuntime("BigInt shift count is too large".into()))?;
            Ok(value >> magnitude)
        }
    }

    fn number_primitive_value(value: &Value) -> Option<f64> {
        match value {
            Value::Number(value) => Some(*value as f64),
            Value::Float(value) => Some(*value),
            _ => None,
        }
    }

    fn number_value(value: f64) -> Value {
        if value == 0.0 && value.is_sign_negative() {
            return Value::Float(-0.0);
        }
        if value.is_finite()
            && value.fract() == 0.0
            && value >= i64::MIN as f64
            && value <= i64::MAX as f64
        {
            let integer = value as i64;
            if (integer as f64) == value {
                return Value::Number(integer);
            }
        }
        Value::Float(value)
    }

    fn coerce_number_for_number_constructor(value: &Value) -> f64 {
        match value {
            Value::Number(v) => *v as f64,
            Value::Float(v) => *v,
            Value::BigInt(v) => v.to_f64().unwrap_or_else(|| {
                if v.sign() == Sign::Minus {
                    f64::NEG_INFINITY
                } else {
                    f64::INFINITY
                }
            }),
            Value::Bool(v) => {
                if *v {
                    1.0
                } else {
                    0.0
                }
            }
            Value::Null => 0.0,
            Value::Undefined => f64::NAN,
            Value::String(v) => Self::parse_js_number_from_string(v),
            Value::Date(v) => *v.borrow() as f64,
            Value::Object(_)
            | Value::Promise(_)
            | Value::Map(_)
            | Value::Set(_)
            | Value::ArrayBuffer(_)
            | Value::TypedArray(_)
            | Value::StringConstructor
            | Value::TypedArrayConstructor(_)
            | Value::ArrayBufferConstructor
            | Value::PromiseConstructor
            | Value::MapConstructor
            | Value::SetConstructor
            | Value::SymbolConstructor
            | Value::RegExpConstructor
            | Value::PromiseCapability(_)
            | Value::Symbol(_)
            | Value::RegExp(_)
            | Value::Node(_)
            | Value::NodeList(_)
            | Value::FormData(_)
            | Value::Function(_) => f64::NAN,
            Value::Array(values) => {
                let rendered = Value::Array(values.clone()).as_string();
                Self::parse_js_number_from_string(&rendered)
            }
        }
    }

    fn parse_js_number_from_string(src: &str) -> f64 {
        let trimmed = src.trim();
        if trimmed.is_empty() {
            return 0.0;
        }
        if trimmed == "Infinity" || trimmed == "+Infinity" {
            return f64::INFINITY;
        }
        if trimmed == "-Infinity" {
            return f64::NEG_INFINITY;
        }

        if trimmed.starts_with('+') || trimmed.starts_with('-') {
            let rest = &trimmed[1..];
            if rest.starts_with("0x")
                || rest.starts_with("0X")
                || rest.starts_with("0o")
                || rest.starts_with("0O")
                || rest.starts_with("0b")
                || rest.starts_with("0B")
            {
                return f64::NAN;
            }
        }

        if let Some(digits) = trimmed
            .strip_prefix("0x")
            .or_else(|| trimmed.strip_prefix("0X"))
        {
            return Self::parse_prefixed_radix_to_f64(digits, 16);
        }
        if let Some(digits) = trimmed
            .strip_prefix("0o")
            .or_else(|| trimmed.strip_prefix("0O"))
        {
            return Self::parse_prefixed_radix_to_f64(digits, 8);
        }
        if let Some(digits) = trimmed
            .strip_prefix("0b")
            .or_else(|| trimmed.strip_prefix("0B"))
        {
            return Self::parse_prefixed_radix_to_f64(digits, 2);
        }

        trimmed.parse::<f64>().unwrap_or(f64::NAN)
    }

    fn parse_prefixed_radix_to_f64(src: &str, radix: u32) -> f64 {
        if src.is_empty() {
            return f64::NAN;
        }
        let mut out = 0.0f64;
        for ch in src.chars() {
            let Some(digit) = ch.to_digit(radix) else {
                return f64::NAN;
            };
            out = out * (radix as f64) + (digit as f64);
        }
        out
    }

    fn format_number_default(value: f64) -> String {
        if value.is_nan() {
            return "NaN".to_string();
        }
        if value == f64::INFINITY {
            return "Infinity".to_string();
        }
        if value == f64::NEG_INFINITY {
            return "-Infinity".to_string();
        }
        if value == 0.0 {
            return "0".to_string();
        }

        if value.fract() == 0.0 && value >= i64::MIN as f64 && value <= i64::MAX as f64 {
            let integer = value as i64;
            if (integer as f64) == value {
                return integer.to_string();
            }
        }

        let out = format!("{value}");
        Self::normalize_exponential_string(out, false)
    }

    fn number_to_exponential(value: f64, fraction_digits: Option<usize>) -> String {
        if !value.is_finite() {
            return Self::format_number_default(value);
        }

        let out = if let Some(fraction_digits) = fraction_digits {
            format!(
                "{:.*e}",
                fraction_digits,
                if value == 0.0 { 0.0 } else { value }
            )
        } else {
            format!("{:e}", if value == 0.0 { 0.0 } else { value })
        };
        Self::normalize_exponential_string(out, fraction_digits.is_none())
    }

    fn normalize_exponential_string(raw: String, trim_fraction_zeros: bool) -> String {
        let Some(exp_idx) = raw.find('e').or_else(|| raw.find('E')) else {
            return raw;
        };
        let mut mantissa = raw[..exp_idx].to_string();
        let exponent_src = &raw[exp_idx + 1..];

        if trim_fraction_zeros && mantissa.contains('.') {
            while mantissa.ends_with('0') {
                mantissa.pop();
            }
            if mantissa.ends_with('.') {
                mantissa.pop();
            }
        }

        let exponent = exponent_src.parse::<i32>().unwrap_or(0);
        format!("{mantissa}e{:+}", exponent)
    }

    fn number_to_fixed(value: f64, fraction_digits: usize) -> String {
        if !value.is_finite() {
            return Self::format_number_default(value);
        }
        format!(
            "{:.*}",
            fraction_digits,
            if value == 0.0 { 0.0 } else { value }
        )
    }

    fn number_to_precision(value: f64, precision: usize) -> String {
        if !value.is_finite() {
            return Self::format_number_default(value);
        }
        if value == 0.0 {
            if precision == 1 {
                return "0".to_string();
            }
            return format!("0.{}", "0".repeat(precision - 1));
        }

        let abs = value.abs();
        let exponent = abs.log10().floor() as i32;
        if exponent < -6 || exponent >= precision as i32 {
            return Self::number_to_exponential(value, Some(precision.saturating_sub(1)));
        }

        let fraction_digits = (precision as i32 - exponent - 1).max(0) as usize;
        format!(
            "{:.*}",
            fraction_digits,
            if value == 0.0 { 0.0 } else { value }
        )
    }

    fn number_to_string_radix(value: f64, radix: u32) -> String {
        if radix == 10 {
            return Self::format_number_default(value);
        }
        if !value.is_finite() {
            return Self::format_number_default(value);
        }
        if value == 0.0 {
            return "0".to_string();
        }

        let sign = if value < 0.0 { "-" } else { "" };
        let abs = value.abs();
        let int_part = abs.trunc();
        let mut int_digits = Vec::new();
        let mut n = int_part;
        let radix_f64 = radix as f64;

        while n >= 1.0 {
            let digit = (n % radix_f64).floor() as u32;
            int_digits.push(Self::radix_digit_char(digit));
            n = (n / radix_f64).floor();
        }
        if int_digits.is_empty() {
            int_digits.push('0');
        }
        int_digits.reverse();
        let int_str: String = int_digits.into_iter().collect();

        let mut frac = abs - int_part;
        if frac == 0.0 {
            return format!("{sign}{int_str}");
        }

        let mut frac_str = String::new();
        let mut digits = 0usize;
        while frac > 0.0 && digits < 16 {
            frac *= radix_f64;
            let digit = frac.floor() as u32;
            frac_str.push(Self::radix_digit_char(digit));
            frac -= digit as f64;
            digits += 1;
            if frac.abs() < f64::EPSILON {
                break;
            }
        }
        while frac_str.ends_with('0') {
            frac_str.pop();
        }

        if frac_str.is_empty() {
            format!("{sign}{int_str}")
        } else {
            format!("{sign}{int_str}.{frac_str}")
        }
    }

    fn radix_digit_char(value: u32) -> char {
        if value < 10 {
            char::from(b'0' + value as u8)
        } else {
            char::from(b'a' + (value - 10) as u8)
        }
    }

    fn sum_precise(values: &[Value]) -> f64 {
        let mut sum = 0.0f64;
        let mut compensation = 0.0f64;
        for value in values {
            let value = Self::coerce_number_for_global(value);
            let adjusted = value - compensation;
            let next = sum + adjusted;
            compensation = (next - sum) - adjusted;
            sum = next;
        }
        sum
    }

    fn js_math_round(value: f64) -> f64 {
        if !value.is_finite() || value == 0.0 {
            return value;
        }
        if (-0.5..0.0).contains(&value) {
            return -0.0;
        }
        let floor = value.floor();
        let frac = value - floor;
        if frac < 0.5 { floor } else { floor + 1.0 }
    }

    fn js_math_sign(value: f64) -> f64 {
        if value.is_nan() {
            f64::NAN
        } else if value == 0.0 {
            value
        } else if value > 0.0 {
            1.0
        } else {
            -1.0
        }
    }

    fn to_i32_for_math(value: &Value) -> i32 {
        let numeric = Self::coerce_number_for_global(value);
        if !numeric.is_finite() {
            return 0;
        }
        let unsigned = numeric.trunc().rem_euclid(4_294_967_296.0);
        if unsigned >= 2_147_483_648.0 {
            (unsigned - 4_294_967_296.0) as i32
        } else {
            unsigned as i32
        }
    }

    fn to_u32_for_math(value: &Value) -> u32 {
        let numeric = Self::coerce_number_for_global(value);
        if !numeric.is_finite() {
            return 0;
        }
        numeric.trunc().rem_euclid(4_294_967_296.0) as u32
    }

    fn math_f16round(value: f64) -> f64 {
        let half = Self::f32_to_f16_bits(value as f32);
        Self::f16_bits_to_f32(half) as f64
    }

    fn f32_to_f16_bits(value: f32) -> u16 {
        let bits = value.to_bits();
        let sign = ((bits >> 16) & 0x8000) as u16;
        let exp = ((bits >> 23) & 0xff) as i32;
        let mant = bits & 0x007f_ffff;

        if exp == 0xff {
            if mant == 0 {
                return sign | 0x7c00;
            }
            return sign | 0x7e00;
        }

        let exp16 = exp - 127 + 15;
        if exp16 >= 0x1f {
            return sign | 0x7c00;
        }

        if exp16 <= 0 {
            if exp16 < -10 {
                return sign;
            }
            let mantissa = mant | 0x0080_0000;
            let shift = (14 - exp16) as u32;
            let mut half_mant = mantissa >> shift;
            let round_bit = 1u32 << (shift - 1);
            if (mantissa & round_bit) != 0
                && ((mantissa & (round_bit - 1)) != 0 || (half_mant & 1) != 0)
            {
                half_mant += 1;
            }
            return sign | (half_mant as u16);
        }

        let mut half_exp = (exp16 as u16) << 10;
        let mut half_mant = (mant >> 13) as u16;
        let round_bits = mant & 0x1fff;
        if round_bits > 0x1000 || (round_bits == 0x1000 && (half_mant & 1) != 0) {
            half_mant = half_mant.wrapping_add(1);
            if half_mant == 0x0400 {
                half_mant = 0;
                half_exp = half_exp.wrapping_add(0x0400);
                if half_exp >= 0x7c00 {
                    return sign | 0x7c00;
                }
            }
        }
        sign | half_exp | half_mant
    }

    fn f16_bits_to_f32(bits: u16) -> f32 {
        let sign = ((bits & 0x8000) as u32) << 16;
        let exp = ((bits >> 10) & 0x1f) as u32;
        let mant = (bits & 0x03ff) as u32;

        let out_bits = if exp == 0 {
            if mant == 0 {
                sign
            } else {
                let mut mantissa = mant;
                let mut exp_val = -14i32;
                while (mantissa & 0x0400) == 0 {
                    mantissa <<= 1;
                    exp_val -= 1;
                }
                mantissa &= 0x03ff;
                let exp32 = ((exp_val + 127) as u32) << 23;
                sign | exp32 | (mantissa << 13)
            }
        } else if exp == 0x1f {
            sign | 0x7f80_0000 | (mant << 13)
        } else {
            let exp32 = (((exp as i32) - 15 + 127) as u32) << 23;
            sign | exp32 | (mant << 13)
        };

        f32::from_bits(out_bits)
    }

    fn new_date_value(timestamp_ms: i64) -> Value {
        Value::Date(Rc::new(RefCell::new(timestamp_ms)))
    }

    fn resolve_date_from_env(
        &self,
        env: &HashMap<String, Value>,
        target: &str,
    ) -> Result<Rc<RefCell<i64>>> {
        match env.get(target) {
            Some(Value::Date(value)) => Ok(value.clone()),
            Some(_) => Err(Error::ScriptRuntime(format!(
                "variable '{}' is not a Date",
                target
            ))),
            None => Err(Error::ScriptRuntime(format!(
                "unknown variable: {}",
                target
            ))),
        }
    }

    fn coerce_date_timestamp_ms(&self, value: &Value) -> i64 {
        match value {
            Value::Date(value) => *value.borrow(),
            Value::String(value) => Self::parse_date_string_to_epoch_ms(value).unwrap_or(0),
            _ => Self::value_to_i64(value),
        }
    }

    fn resolve_array_from_env(
        &self,
        env: &HashMap<String, Value>,
        target: &str,
    ) -> Result<Rc<RefCell<Vec<Value>>>> {
        match env.get(target) {
            Some(Value::Array(values)) => Ok(values.clone()),
            Some(_) => Err(Error::ScriptRuntime(format!(
                "variable '{}' is not an array",
                target
            ))),
            None => Err(Error::ScriptRuntime(format!(
                "unknown variable: {}",
                target
            ))),
        }
    }

    fn resolve_array_buffer_from_env(
        &self,
        env: &HashMap<String, Value>,
        target: &str,
    ) -> Result<Rc<RefCell<ArrayBufferValue>>> {
        match env.get(target) {
            Some(Value::ArrayBuffer(buffer)) => Ok(buffer.clone()),
            Some(_) => Err(Error::ScriptRuntime(format!(
                "variable '{}' is not an ArrayBuffer",
                target
            ))),
            None => Err(Error::ScriptRuntime(format!(
                "unknown variable: {}",
                target
            ))),
        }
    }

    fn resolve_typed_array_from_env(
        &self,
        env: &HashMap<String, Value>,
        target: &str,
    ) -> Result<Rc<RefCell<TypedArrayValue>>> {
        match env.get(target) {
            Some(Value::TypedArray(array)) => Ok(array.clone()),
            Some(_) => Err(Error::ScriptRuntime(format!(
                "variable '{}' is not a TypedArray",
                target
            ))),
            None => Err(Error::ScriptRuntime(format!(
                "unknown variable: {}",
                target
            ))),
        }
    }

    fn to_non_negative_usize(value: &Value, label: &str) -> Result<usize> {
        let n = Self::value_to_i64(value);
        if n < 0 {
            return Err(Error::ScriptRuntime(format!(
                "{label} must be a non-negative integer"
            )));
        }
        usize::try_from(n).map_err(|_| Error::ScriptRuntime(format!("{label} is too large")))
    }

    fn array_like_values_from_value(&self, value: &Value) -> Result<Vec<Value>> {
        match value {
            Value::Array(values) => Ok(values.borrow().clone()),
            Value::TypedArray(values) => self.typed_array_snapshot(values),
            Value::Map(map) => {
                let map = map.borrow();
                Ok(map
                    .entries
                    .iter()
                    .map(|(key, value)| Self::new_array_value(vec![key.clone(), value.clone()]))
                    .collect::<Vec<_>>())
            }
            Value::Set(set) => Ok(set.borrow().values.clone()),
            Value::String(text) => Ok(text
                .chars()
                .map(|ch| Value::String(ch.to_string()))
                .collect::<Vec<_>>()),
            Value::NodeList(nodes) => Ok(nodes.iter().copied().map(Value::Node).collect()),
            Value::Object(entries) => {
                let entries = entries.borrow();
                let length_value =
                    Self::object_get_entry(&entries, "length").unwrap_or(Value::Number(0));
                let length = Self::to_non_negative_usize(&length_value, "array-like length")?;
                let mut out = Vec::with_capacity(length);
                for index in 0..length {
                    let key = index.to_string();
                    out.push(Self::object_get_entry(&entries, &key).unwrap_or(Value::Undefined));
                }
                Ok(out)
            }
            _ => Err(Error::ScriptRuntime(
                "expected an array-like or iterable source".into(),
            )),
        }
    }

    fn new_array_buffer_value(byte_length: usize, max_byte_length: Option<usize>) -> Value {
        Value::ArrayBuffer(Rc::new(RefCell::new(ArrayBufferValue {
            bytes: vec![0; byte_length],
            max_byte_length,
            detached: false,
        })))
    }

    fn new_typed_array_with_length(
        &mut self,
        kind: TypedArrayKind,
        length: usize,
    ) -> Result<Value> {
        let byte_length = length.saturating_mul(kind.bytes_per_element());
        let buffer = Rc::new(RefCell::new(ArrayBufferValue {
            bytes: vec![0; byte_length],
            max_byte_length: None,
            detached: false,
        }));
        Ok(Value::TypedArray(Rc::new(RefCell::new(TypedArrayValue {
            kind,
            buffer,
            byte_offset: 0,
            fixed_length: Some(length),
        }))))
    }

    fn new_typed_array_view(
        &self,
        kind: TypedArrayKind,
        buffer: Rc<RefCell<ArrayBufferValue>>,
        byte_offset: usize,
        length: Option<usize>,
    ) -> Result<Value> {
        let bytes_per_element = kind.bytes_per_element();
        if byte_offset % bytes_per_element != 0 {
            return Err(Error::ScriptRuntime(format!(
                "start offset of {} should be a multiple of {}",
                kind.name(),
                bytes_per_element
            )));
        }

        let buffer_len = buffer.borrow().byte_length();
        if byte_offset > buffer_len {
            return Err(Error::ScriptRuntime(
                "typed array view bounds are outside the buffer".into(),
            ));
        }

        if let Some(length) = length {
            let required = byte_offset.saturating_add(length.saturating_mul(bytes_per_element));
            if required > buffer_len {
                return Err(Error::ScriptRuntime(
                    "typed array view bounds are outside the buffer".into(),
                ));
            }
        } else {
            let remaining = buffer_len.saturating_sub(byte_offset);
            if remaining % bytes_per_element != 0 {
                return Err(Error::ScriptRuntime(format!(
                    "byte length of {} should be a multiple of {}",
                    kind.name(),
                    bytes_per_element
                )));
            }
        }

        Ok(Value::TypedArray(Rc::new(RefCell::new(TypedArrayValue {
            kind,
            buffer,
            byte_offset,
            fixed_length: length,
        }))))
    }

    fn new_typed_array_from_values(
        &mut self,
        kind: TypedArrayKind,
        values: &[Value],
    ) -> Result<Value> {
        let array = self.new_typed_array_with_length(kind, values.len())?;
        let Value::TypedArray(array) = array else {
            unreachable!();
        };
        for (index, value) in values.iter().enumerate() {
            self.typed_array_set_index(&array, index, value.clone())?;
        }
        Ok(Value::TypedArray(array))
    }

    fn typed_array_snapshot(&self, array: &Rc<RefCell<TypedArrayValue>>) -> Result<Vec<Value>> {
        let length = array.borrow().observed_length();
        let mut out = Vec::with_capacity(length);
        for index in 0..length {
            out.push(self.typed_array_get_index(array, index)?);
        }
        Ok(out)
    }

    fn typed_array_get_index(
        &self,
        array: &Rc<RefCell<TypedArrayValue>>,
        index: usize,
    ) -> Result<Value> {
        let (kind, buffer, byte_offset, length) = {
            let array = array.borrow();
            (
                array.kind,
                array.buffer.clone(),
                array.byte_offset,
                array.observed_length(),
            )
        };
        if index >= length {
            return Ok(Value::Undefined);
        }

        let bytes_per_element = kind.bytes_per_element();
        let start = byte_offset.saturating_add(index.saturating_mul(bytes_per_element));
        let buffer = buffer.borrow();
        if start.saturating_add(bytes_per_element) > buffer.byte_length() {
            return Ok(Value::Undefined);
        }
        let bytes = &buffer.bytes[start..start + bytes_per_element];
        let value = match kind {
            TypedArrayKind::Int8 => Value::Number(i64::from(i8::from_le_bytes([bytes[0]]))),
            TypedArrayKind::Uint8 | TypedArrayKind::Uint8Clamped => {
                Value::Number(i64::from(u8::from_le_bytes([bytes[0]])))
            }
            TypedArrayKind::Int16 => {
                Value::Number(i64::from(i16::from_le_bytes([bytes[0], bytes[1]])))
            }
            TypedArrayKind::Uint16 => {
                Value::Number(i64::from(u16::from_le_bytes([bytes[0], bytes[1]])))
            }
            TypedArrayKind::Int32 => Value::Number(i64::from(i32::from_le_bytes([
                bytes[0], bytes[1], bytes[2], bytes[3],
            ]))),
            TypedArrayKind::Uint32 => Value::Number(i64::from(u32::from_le_bytes([
                bytes[0], bytes[1], bytes[2], bytes[3],
            ]))),
            TypedArrayKind::Float16 => {
                let bits = u16::from_le_bytes([bytes[0], bytes[1]]);
                Self::number_value(Self::f16_bits_to_f32(bits) as f64)
            }
            TypedArrayKind::Float32 => Self::number_value(f64::from(f32::from_le_bytes([
                bytes[0], bytes[1], bytes[2], bytes[3],
            ]))),
            TypedArrayKind::Float64 => Self::number_value(f64::from_le_bytes([
                bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7],
            ])),
            TypedArrayKind::BigInt64 => Value::BigInt(JsBigInt::from(i64::from_le_bytes([
                bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7],
            ]))),
            TypedArrayKind::BigUint64 => Value::BigInt(JsBigInt::from(u64::from_le_bytes([
                bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7],
            ]))),
        };
        Ok(value)
    }

    fn typed_array_number_to_i128(value: f64) -> i128 {
        if !value.is_finite() {
            return 0;
        }
        let value = value.trunc();
        if value >= i128::MAX as f64 {
            i128::MAX
        } else if value <= i128::MIN as f64 {
            i128::MIN
        } else {
            value as i128
        }
    }

    fn typed_array_round_half_even(value: f64) -> f64 {
        let floor = value.floor();
        let frac = value - floor;
        if frac < 0.5 {
            floor
        } else if frac > 0.5 {
            floor + 1.0
        } else if (floor as i64) % 2 == 0 {
            floor
        } else {
            floor + 1.0
        }
    }

    fn typed_array_bytes_for_value(kind: TypedArrayKind, value: &Value) -> Result<Vec<u8>> {
        if kind.is_bigint() {
            let Value::BigInt(value) = value else {
                return Err(Error::ScriptRuntime(
                    "Cannot convert number to BigInt typed array element".into(),
                ));
            };
            let modulus = JsBigInt::one() << 64usize;
            let mut unsigned = value % &modulus;
            if unsigned.sign() == Sign::Minus {
                unsigned += &modulus;
            }
            return match kind {
                TypedArrayKind::BigInt64 => {
                    let cutoff = JsBigInt::one() << 63usize;
                    let signed = if unsigned >= cutoff {
                        unsigned - &modulus
                    } else {
                        unsigned
                    };
                    let value = signed.to_i64().unwrap_or(0);
                    Ok(value.to_le_bytes().to_vec())
                }
                TypedArrayKind::BigUint64 => {
                    let value = unsigned.to_u64().unwrap_or(0);
                    Ok(value.to_le_bytes().to_vec())
                }
                _ => unreachable!(),
            };
        }

        if matches!(value, Value::BigInt(_)) {
            return Err(Error::ScriptRuntime(
                "Cannot convert a BigInt value to a number".into(),
            ));
        }

        let number = Self::coerce_number_for_global(value);
        let bytes = match kind {
            TypedArrayKind::Int8 => {
                let modulus = 1i128 << 8;
                let mut out = Self::typed_array_number_to_i128(number).rem_euclid(modulus);
                if out >= (1i128 << 7) {
                    out -= modulus;
                }
                (out as i8).to_le_bytes().to_vec()
            }
            TypedArrayKind::Uint8 => {
                let out = Self::typed_array_number_to_i128(number).rem_euclid(1i128 << 8);
                (out as u8).to_le_bytes().to_vec()
            }
            TypedArrayKind::Uint8Clamped => {
                let clamped = if number.is_nan() {
                    0.0
                } else {
                    number.clamp(0.0, 255.0)
                };
                let rounded = Self::typed_array_round_half_even(clamped);
                (rounded as u8).to_le_bytes().to_vec()
            }
            TypedArrayKind::Int16 => {
                let modulus = 1i128 << 16;
                let mut out = Self::typed_array_number_to_i128(number).rem_euclid(modulus);
                if out >= (1i128 << 15) {
                    out -= modulus;
                }
                (out as i16).to_le_bytes().to_vec()
            }
            TypedArrayKind::Uint16 => {
                let out = Self::typed_array_number_to_i128(number).rem_euclid(1i128 << 16);
                (out as u16).to_le_bytes().to_vec()
            }
            TypedArrayKind::Int32 => {
                let modulus = 1i128 << 32;
                let mut out = Self::typed_array_number_to_i128(number).rem_euclid(modulus);
                if out >= (1i128 << 31) {
                    out -= modulus;
                }
                (out as i32).to_le_bytes().to_vec()
            }
            TypedArrayKind::Uint32 => {
                let out = Self::typed_array_number_to_i128(number).rem_euclid(1i128 << 32);
                (out as u32).to_le_bytes().to_vec()
            }
            TypedArrayKind::Float16 => {
                let rounded = Self::math_f16round(number);
                let bits = Self::f32_to_f16_bits(rounded as f32);
                bits.to_le_bytes().to_vec()
            }
            TypedArrayKind::Float32 => (number as f32).to_le_bytes().to_vec(),
            TypedArrayKind::Float64 => number.to_le_bytes().to_vec(),
            TypedArrayKind::BigInt64 | TypedArrayKind::BigUint64 => unreachable!(),
        };
        Ok(bytes)
    }

    fn typed_array_set_index(
        &mut self,
        array: &Rc<RefCell<TypedArrayValue>>,
        index: usize,
        value: Value,
    ) -> Result<()> {
        let (kind, buffer, byte_offset, length) = {
            let array = array.borrow();
            (
                array.kind,
                array.buffer.clone(),
                array.byte_offset,
                array.observed_length(),
            )
        };
        if index >= length {
            return Ok(());
        }
        let bytes_per_element = kind.bytes_per_element();
        let start = byte_offset.saturating_add(index.saturating_mul(bytes_per_element));
        let bytes = Self::typed_array_bytes_for_value(kind, &value)?;
        if bytes.len() != bytes_per_element {
            return Err(Error::ScriptRuntime(
                "typed array element size mismatch".into(),
            ));
        }
        let mut buffer = buffer.borrow_mut();
        if start.saturating_add(bytes_per_element) > buffer.byte_length() {
            return Ok(());
        }
        buffer.bytes[start..start + bytes_per_element].copy_from_slice(&bytes);
        Ok(())
    }

    fn eval_array_buffer_construct(
        &mut self,
        byte_length: &Option<Box<Expr>>,
        options: &Option<Box<Expr>>,
        called_with_new: bool,
        env: &HashMap<String, Value>,
        event_param: &Option<String>,
        event: &EventState,
    ) -> Result<Value> {
        if !called_with_new {
            return Err(Error::ScriptRuntime(
                "ArrayBuffer constructor must be called with new".into(),
            ));
        }
        let byte_length = if let Some(byte_length) = byte_length {
            let value = self.eval_expr(byte_length, env, event_param, event)?;
            Self::to_non_negative_usize(&value, "ArrayBuffer byteLength")?
        } else {
            0
        };
        let max_byte_length = if let Some(options) = options {
            let options = self.eval_expr(options, env, event_param, event)?;
            match options {
                Value::Undefined | Value::Null => None,
                Value::Object(entries) => {
                    let entries = entries.borrow();
                    if let Some(value) = Self::object_get_entry(&entries, "maxByteLength") {
                        Some(Self::to_non_negative_usize(
                            &value,
                            "ArrayBuffer maxByteLength",
                        )?)
                    } else {
                        None
                    }
                }
                _ => {
                    return Err(Error::ScriptRuntime(
                        "ArrayBuffer options must be an object".into(),
                    ));
                }
            }
        } else {
            None
        };
        if max_byte_length.is_some_and(|max| byte_length > max) {
            return Err(Error::ScriptRuntime(
                "ArrayBuffer byteLength exceeds maxByteLength".into(),
            ));
        }
        Ok(Self::new_array_buffer_value(byte_length, max_byte_length))
    }

    fn resize_array_buffer(
        &mut self,
        buffer: &Rc<RefCell<ArrayBufferValue>>,
        new_byte_length: i64,
    ) -> Result<()> {
        Self::ensure_array_buffer_not_detached(buffer, "resize")?;
        if new_byte_length < 0 {
            return Err(Error::ScriptRuntime(
                "ArrayBuffer resize length must be non-negative".into(),
            ));
        }
        let new_byte_length = usize::try_from(new_byte_length)
            .map_err(|_| Error::ScriptRuntime("ArrayBuffer resize length is too large".into()))?;
        let max_byte_length = buffer.borrow().max_byte_length;
        let Some(max_byte_length) = max_byte_length else {
            return Err(Error::ScriptRuntime("ArrayBuffer is not resizable".into()));
        };
        if new_byte_length > max_byte_length {
            return Err(Error::ScriptRuntime(
                "ArrayBuffer resize exceeds maxByteLength".into(),
            ));
        }
        buffer.borrow_mut().bytes.resize(new_byte_length, 0);
        Ok(())
    }

    fn ensure_array_buffer_not_detached(
        buffer: &Rc<RefCell<ArrayBufferValue>>,
        method: &str,
    ) -> Result<()> {
        if buffer.borrow().detached {
            return Err(Error::ScriptRuntime(format!(
                "Cannot perform ArrayBuffer.prototype.{method} on a detached ArrayBuffer"
            )));
        }
        Ok(())
    }

    fn transfer_array_buffer(
        &mut self,
        buffer: &Rc<RefCell<ArrayBufferValue>>,
        to_fixed_length: bool,
    ) -> Result<Value> {
        Self::ensure_array_buffer_not_detached(
            buffer,
            if to_fixed_length {
                "transferToFixedLength"
            } else {
                "transfer"
            },
        )?;
        let mut source = buffer.borrow_mut();
        let bytes = source.bytes.clone();
        let max_byte_length = if to_fixed_length {
            None
        } else {
            source.max_byte_length
        };
        source.bytes.clear();
        source.max_byte_length = None;
        source.detached = true;
        drop(source);
        Ok(Value::ArrayBuffer(Rc::new(RefCell::new(
            ArrayBufferValue {
                bytes,
                max_byte_length,
                detached: false,
            },
        ))))
    }

    fn resize_array_buffer_in_env(
        &mut self,
        env: &HashMap<String, Value>,
        target: &str,
        new_byte_length: i64,
    ) -> Result<()> {
        let buffer = self.resolve_array_buffer_from_env(env, target)?;
        self.resize_array_buffer(&buffer, new_byte_length)
    }

    fn eval_typed_array_construct(
        &mut self,
        kind: TypedArrayKind,
        args: &[Expr],
        called_with_new: bool,
        env: &HashMap<String, Value>,
        event_param: &Option<String>,
        event: &EventState,
    ) -> Result<Value> {
        if !called_with_new {
            return Err(Error::ScriptRuntime(format!(
                "{} constructor must be called with new",
                kind.name()
            )));
        }
        if args.len() > 3 {
            return Err(Error::ScriptRuntime(format!(
                "{} supports up to three arguments",
                kind.name()
            )));
        }

        if args.is_empty() {
            return self.new_typed_array_with_length(kind, 0);
        }

        let first = self.eval_expr(&args[0], env, event_param, event)?;
        match (&first, args.len()) {
            (Value::ArrayBuffer(buffer), 1) => {
                self.new_typed_array_view(kind, buffer.clone(), 0, None)
            }
            (Value::TypedArray(source), 1) => {
                let source_kind = source.borrow().kind;
                if kind.is_bigint() != source_kind.is_bigint() {
                    return Err(Error::ScriptRuntime(
                        "cannot mix BigInt and Number typed arrays".into(),
                    ));
                }
                let values = self.typed_array_snapshot(source)?;
                self.new_typed_array_from_values(kind, &values)
            }
            (Value::Array(_), 1) | (Value::Object(_), 1) | (Value::String(_), 1) => {
                let values = self.array_like_values_from_value(&first)?;
                self.new_typed_array_from_values(kind, &values)
            }
            (Value::ArrayBuffer(buffer), _) => {
                let byte_offset = if args.len() >= 2 {
                    let offset = self.eval_expr(&args[1], env, event_param, event)?;
                    Self::to_non_negative_usize(&offset, "typed array byteOffset")?
                } else {
                    0
                };
                let length = if args.len() == 3 {
                    let length = self.eval_expr(&args[2], env, event_param, event)?;
                    if matches!(length, Value::Undefined) {
                        None
                    } else {
                        Some(Self::to_non_negative_usize(&length, "typed array length")?)
                    }
                } else {
                    None
                };
                self.new_typed_array_view(kind, buffer.clone(), byte_offset, length)
            }
            _ => {
                if args.len() != 1 {
                    return Err(Error::ScriptRuntime(
                        "typed array buffer view requires an ArrayBuffer first argument".into(),
                    ));
                }
                let length = Self::to_non_negative_usize(&first, "typed array length")?;
                self.new_typed_array_with_length(kind, length)
            }
        }
    }

    fn eval_typed_array_construct_with_callee(
        &mut self,
        callee: &Expr,
        args: &[Expr],
        called_with_new: bool,
        env: &HashMap<String, Value>,
        event_param: &Option<String>,
        event: &EventState,
    ) -> Result<Value> {
        if !called_with_new {
            return Err(Error::ScriptRuntime(
                "constructor must be called with new".into(),
            ));
        }
        let callee = self.eval_expr(callee, env, event_param, event)?;
        match callee {
            Value::TypedArrayConstructor(TypedArrayConstructorKind::Concrete(kind)) => {
                self.eval_typed_array_construct(kind, args, true, env, event_param, event)
            }
            Value::TypedArrayConstructor(TypedArrayConstructorKind::Abstract) => Err(
                Error::ScriptRuntime("Abstract class TypedArray not directly constructable".into()),
            ),
            _ => Err(Error::ScriptRuntime("value is not a constructor".into())),
        }
    }

    fn eval_typed_array_static_method(
        &mut self,
        kind: TypedArrayKind,
        method: TypedArrayStaticMethod,
        args: &[Expr],
        env: &HashMap<String, Value>,
        event_param: &Option<String>,
        event: &EventState,
    ) -> Result<Value> {
        match method {
            TypedArrayStaticMethod::From => {
                if args.len() != 1 {
                    return Err(Error::ScriptRuntime(format!(
                        "{}.from requires exactly one argument",
                        kind.name()
                    )));
                }
                let source = self.eval_expr(&args[0], env, event_param, event)?;
                if let Value::TypedArray(source_array) = &source {
                    if kind.is_bigint() != source_array.borrow().kind.is_bigint() {
                        return Err(Error::ScriptRuntime(
                            "cannot mix BigInt and Number typed arrays".into(),
                        ));
                    }
                }
                let values = self.array_like_values_from_value(&source)?;
                self.new_typed_array_from_values(kind, &values)
            }
            TypedArrayStaticMethod::Of => {
                let mut values = Vec::with_capacity(args.len());
                for arg in args {
                    values.push(self.eval_expr(arg, env, event_param, event)?);
                }
                self.new_typed_array_from_values(kind, &values)
            }
        }
    }

    fn same_value_zero(&self, left: &Value, right: &Value) -> bool {
        if let (Some(left_num), Some(right_num)) = (
            Self::number_primitive_value(left),
            Self::number_primitive_value(right),
        ) {
            if left_num.is_nan() && right_num.is_nan() {
                return true;
            }
        }
        self.strict_equal(left, right)
    }

    fn map_entry_index(&self, map: &MapValue, key: &Value) -> Option<usize> {
        map.entries
            .iter()
            .position(|(existing_key, _)| self.same_value_zero(existing_key, key))
    }

    fn map_set_entry(&self, map: &mut MapValue, key: Value, value: Value) {
        if let Some(index) = self.map_entry_index(map, &key) {
            map.entries[index].1 = value;
        } else {
            map.entries.push((key, value));
        }
    }

    fn map_entries_array(&self, map: &Rc<RefCell<MapValue>>) -> Vec<Value> {
        map.borrow()
            .entries
            .iter()
            .map(|(key, value)| Self::new_array_value(vec![key.clone(), value.clone()]))
            .collect::<Vec<_>>()
    }

    fn set_value_index(&self, set: &SetValue, value: &Value) -> Option<usize> {
        set.values
            .iter()
            .position(|existing_value| self.same_value_zero(existing_value, value))
    }

    fn set_add_value(&self, set: &mut SetValue, value: Value) {
        if self.set_value_index(set, &value).is_none() {
            set.values.push(value);
        }
    }

    fn set_values_array(&self, set: &Rc<RefCell<SetValue>>) -> Vec<Value> {
        set.borrow().values.clone()
    }

    fn set_entries_array(&self, set: &Rc<RefCell<SetValue>>) -> Vec<Value> {
        set.borrow()
            .values
            .iter()
            .map(|value| Self::new_array_value(vec![value.clone(), value.clone()]))
            .collect::<Vec<_>>()
    }

    fn set_like_keys_snapshot(&self, value: &Value) -> Result<Vec<Value>> {
        match value {
            Value::Set(set) => Ok(set.borrow().values.clone()),
            Value::Map(map) => Ok(map
                .borrow()
                .entries
                .iter()
                .map(|(key, _)| key.clone())
                .collect::<Vec<_>>()),
            _ => Err(Error::ScriptRuntime(
                "Set composition argument must be set-like (Set or Map)".into(),
            )),
        }
    }

    fn set_like_has_value(&self, value: &Value, candidate: &Value) -> Result<bool> {
        match value {
            Value::Set(set) => Ok(self.set_value_index(&set.borrow(), candidate).is_some()),
            Value::Map(map) => Ok(self.map_entry_index(&map.borrow(), candidate).is_some()),
            _ => Err(Error::ScriptRuntime(
                "Set composition argument must be set-like (Set or Map)".into(),
            )),
        }
    }

    fn eval_map_construct(
        &mut self,
        iterable: &Option<Box<Expr>>,
        called_with_new: bool,
        env: &HashMap<String, Value>,
        event_param: &Option<String>,
        event: &EventState,
    ) -> Result<Value> {
        if !called_with_new {
            return Err(Error::ScriptRuntime(
                "Map constructor must be called with new".into(),
            ));
        }

        let map = Rc::new(RefCell::new(MapValue {
            entries: Vec::new(),
            properties: Vec::new(),
        }));

        let Some(iterable) = iterable else {
            return Ok(Value::Map(map));
        };

        let iterable = self.eval_expr(iterable, env, event_param, event)?;
        if matches!(iterable, Value::Undefined | Value::Null) {
            return Ok(Value::Map(map));
        }

        match iterable {
            Value::Map(source) => {
                let source = source.borrow();
                map.borrow_mut().entries = source.entries.clone();
            }
            other => {
                let entries = self.array_like_values_from_value(&other)?;
                for entry in entries {
                    let pair = self.array_like_values_from_value(&entry).map_err(|_| {
                        Error::ScriptRuntime(
                            "Map constructor iterable values must be [key, value] pairs".into(),
                        )
                    })?;
                    if pair.len() < 2 {
                        return Err(Error::ScriptRuntime(
                            "Map constructor iterable values must be [key, value] pairs".into(),
                        ));
                    }
                    self.map_set_entry(&mut map.borrow_mut(), pair[0].clone(), pair[1].clone());
                }
            }
        }

        Ok(Value::Map(map))
    }

    fn eval_map_static_method(
        &mut self,
        method: MapStaticMethod,
        args: &[Expr],
        env: &HashMap<String, Value>,
        event_param: &Option<String>,
        event: &EventState,
    ) -> Result<Value> {
        match method {
            MapStaticMethod::GroupBy => {
                if args.len() != 2 {
                    return Err(Error::ScriptRuntime(
                        "Map.groupBy requires exactly two arguments".into(),
                    ));
                }
                let iterable = self.eval_expr(&args[0], env, event_param, event)?;
                let callback = self.eval_expr(&args[1], env, event_param, event)?;
                let values = self.array_like_values_from_value(&iterable)?;
                let map = Rc::new(RefCell::new(MapValue {
                    entries: Vec::new(),
                    properties: Vec::new(),
                }));
                for (index, item) in values.into_iter().enumerate() {
                    let group_key = self.execute_callback_value(
                        &callback,
                        &[item.clone(), Value::Number(index as i64)],
                        event,
                    )?;
                    let mut map_ref = map.borrow_mut();
                    if let Some(entry_index) = self.map_entry_index(&map_ref, &group_key) {
                        match &mut map_ref.entries[entry_index].1 {
                            Value::Array(group_values) => group_values.borrow_mut().push(item),
                            _ => {
                                map_ref.entries[entry_index].1 = Self::new_array_value(vec![item]);
                            }
                        }
                    } else {
                        map_ref
                            .entries
                            .push((group_key, Self::new_array_value(vec![item])));
                    }
                }
                Ok(Value::Map(map))
            }
        }
    }

    fn eval_map_method(
        &mut self,
        target: &str,
        method: MapInstanceMethod,
        args: &[Expr],
        env: &HashMap<String, Value>,
        event_param: &Option<String>,
        event: &EventState,
    ) -> Result<Value> {
        let target_value = env
            .get(target)
            .ok_or_else(|| Error::ScriptRuntime(format!("unknown variable: {}", target)))?;

        if let Value::Set(set) = target_value {
            let set = set.clone();
            return match method {
                MapInstanceMethod::Has => {
                    if args.len() != 1 {
                        return Err(Error::ScriptRuntime(
                            "Map.has requires exactly one argument".into(),
                        ));
                    }
                    let key = self.eval_expr(&args[0], env, event_param, event)?;
                    Ok(Value::Bool(
                        self.set_value_index(&set.borrow(), &key).is_some(),
                    ))
                }
                MapInstanceMethod::Delete => {
                    if args.len() != 1 {
                        return Err(Error::ScriptRuntime(
                            "Map.delete requires exactly one argument".into(),
                        ));
                    }
                    let key = self.eval_expr(&args[0], env, event_param, event)?;
                    let mut set_ref = set.borrow_mut();
                    if let Some(index) = self.set_value_index(&set_ref, &key) {
                        set_ref.values.remove(index);
                        Ok(Value::Bool(true))
                    } else {
                        Ok(Value::Bool(false))
                    }
                }
                MapInstanceMethod::Clear => {
                    if !args.is_empty() {
                        return Err(Error::ScriptRuntime(
                            "Map.clear does not take arguments".into(),
                        ));
                    }
                    set.borrow_mut().values.clear();
                    Ok(Value::Undefined)
                }
                MapInstanceMethod::ForEach => {
                    if args.is_empty() || args.len() > 2 {
                        return Err(Error::ScriptRuntime(
                            "Map.forEach requires a callback and optional thisArg".into(),
                        ));
                    }
                    let callback = self.eval_expr(&args[0], env, event_param, event)?;
                    if args.len() == 2 {
                        let _ = self.eval_expr(&args[1], env, event_param, event)?;
                    }
                    let snapshot = set.borrow().values.clone();
                    for value in snapshot {
                        let _ = self.execute_callback_value(
                            &callback,
                            &[value.clone(), value, Value::Set(set.clone())],
                            event,
                        )?;
                    }
                    Ok(Value::Undefined)
                }
                _ => Err(Error::ScriptRuntime(format!(
                    "variable '{}' is not a Map",
                    target
                ))),
            };
        }

        if let Value::FormData(entries) = target_value {
            let entries = entries.clone();
            return match method {
                MapInstanceMethod::Get => {
                    if args.len() != 1 {
                        return Err(Error::ScriptRuntime(
                            "Map.get requires exactly one argument".into(),
                        ));
                    }
                    let key = self
                        .eval_expr(&args[0], env, event_param, event)?
                        .as_string();
                    let value = entries
                        .iter()
                        .find_map(|(entry_name, value)| (entry_name == &key).then(|| value.clone()))
                        .unwrap_or_default();
                    Ok(Value::String(value))
                }
                MapInstanceMethod::Has => {
                    if args.len() != 1 {
                        return Err(Error::ScriptRuntime(
                            "Map.has requires exactly one argument".into(),
                        ));
                    }
                    let key = self
                        .eval_expr(&args[0], env, event_param, event)?
                        .as_string();
                    let has = entries.iter().any(|(entry_name, _)| entry_name == &key);
                    Ok(Value::Bool(has))
                }
                _ => Err(Error::ScriptRuntime(format!(
                    "variable '{}' is not a Map",
                    target
                ))),
            };
        }

        let Value::Map(map) = target_value else {
            if matches!(method, MapInstanceMethod::Get | MapInstanceMethod::Has) {
                return Err(Error::ScriptRuntime(format!(
                    "variable '{}' is not a FormData instance",
                    target
                )));
            }
            return Err(Error::ScriptRuntime(format!(
                "variable '{}' is not a Map",
                target
            )));
        };
        let map = map.clone();
        match method {
            MapInstanceMethod::Get => {
                if args.len() != 1 {
                    return Err(Error::ScriptRuntime(
                        "Map.get requires exactly one argument".into(),
                    ));
                }
                let key = self.eval_expr(&args[0], env, event_param, event)?;
                let map_ref = map.borrow();
                if let Some(index) = self.map_entry_index(&map_ref, &key) {
                    Ok(map_ref.entries[index].1.clone())
                } else {
                    Ok(Value::Undefined)
                }
            }
            MapInstanceMethod::Has => {
                if args.len() != 1 {
                    return Err(Error::ScriptRuntime(
                        "Map.has requires exactly one argument".into(),
                    ));
                }
                let key = self.eval_expr(&args[0], env, event_param, event)?;
                let has = self.map_entry_index(&map.borrow(), &key).is_some();
                Ok(Value::Bool(has))
            }
            MapInstanceMethod::Delete => {
                if args.len() != 1 {
                    return Err(Error::ScriptRuntime(
                        "Map.delete requires exactly one argument".into(),
                    ));
                }
                let key = self.eval_expr(&args[0], env, event_param, event)?;
                let mut map_ref = map.borrow_mut();
                if let Some(index) = self.map_entry_index(&map_ref, &key) {
                    map_ref.entries.remove(index);
                    Ok(Value::Bool(true))
                } else {
                    Ok(Value::Bool(false))
                }
            }
            MapInstanceMethod::Clear => {
                if !args.is_empty() {
                    return Err(Error::ScriptRuntime(
                        "Map.clear does not take arguments".into(),
                    ));
                }
                map.borrow_mut().entries.clear();
                Ok(Value::Undefined)
            }
            MapInstanceMethod::ForEach => {
                if args.is_empty() || args.len() > 2 {
                    return Err(Error::ScriptRuntime(
                        "Map.forEach requires a callback and optional thisArg".into(),
                    ));
                }
                let callback = self.eval_expr(&args[0], env, event_param, event)?;
                if args.len() == 2 {
                    let _ = self.eval_expr(&args[1], env, event_param, event)?;
                }
                let snapshot = map.borrow().entries.clone();
                for (key, value) in snapshot {
                    let _ = self.execute_callback_value(
                        &callback,
                        &[value, key, Value::Map(map.clone())],
                        event,
                    )?;
                }
                Ok(Value::Undefined)
            }
            MapInstanceMethod::GetOrInsert => {
                if args.len() != 2 {
                    return Err(Error::ScriptRuntime(
                        "Map.getOrInsert requires exactly two arguments".into(),
                    ));
                }
                let key = self.eval_expr(&args[0], env, event_param, event)?;
                let default_value = self.eval_expr(&args[1], env, event_param, event)?;
                let mut map_ref = map.borrow_mut();
                if let Some(index) = self.map_entry_index(&map_ref, &key) {
                    Ok(map_ref.entries[index].1.clone())
                } else {
                    map_ref.entries.push((key, default_value.clone()));
                    Ok(default_value)
                }
            }
            MapInstanceMethod::GetOrInsertComputed => {
                if args.len() != 2 {
                    return Err(Error::ScriptRuntime(
                        "Map.getOrInsertComputed requires exactly two arguments".into(),
                    ));
                }
                let key = self.eval_expr(&args[0], env, event_param, event)?;
                {
                    let map_ref = map.borrow();
                    if let Some(index) = self.map_entry_index(&map_ref, &key) {
                        return Ok(map_ref.entries[index].1.clone());
                    }
                }
                let callback = self.eval_expr(&args[1], env, event_param, event)?;
                let computed =
                    self.execute_callback_value(&callback, std::slice::from_ref(&key), event)?;
                map.borrow_mut().entries.push((key, computed.clone()));
                Ok(computed)
            }
        }
    }

    fn eval_set_construct(
        &mut self,
        iterable: &Option<Box<Expr>>,
        called_with_new: bool,
        env: &HashMap<String, Value>,
        event_param: &Option<String>,
        event: &EventState,
    ) -> Result<Value> {
        if !called_with_new {
            return Err(Error::ScriptRuntime(
                "Set constructor must be called with new".into(),
            ));
        }

        let set = Rc::new(RefCell::new(SetValue {
            values: Vec::new(),
            properties: Vec::new(),
        }));

        let Some(iterable) = iterable else {
            return Ok(Value::Set(set));
        };

        let iterable = self.eval_expr(iterable, env, event_param, event)?;
        if matches!(iterable, Value::Undefined | Value::Null) {
            return Ok(Value::Set(set));
        }

        let values = self.array_like_values_from_value(&iterable)?;
        for value in values {
            self.set_add_value(&mut set.borrow_mut(), value);
        }
        Ok(Value::Set(set))
    }

    fn eval_set_method(
        &mut self,
        target: &str,
        method: SetInstanceMethod,
        args: &[Expr],
        env: &HashMap<String, Value>,
        event_param: &Option<String>,
        event: &EventState,
    ) -> Result<Value> {
        let target_value = env
            .get(target)
            .ok_or_else(|| Error::ScriptRuntime(format!("unknown variable: {}", target)))?;
        let Value::Set(set) = target_value else {
            return Err(Error::ScriptRuntime(format!(
                "variable '{}' is not a Set",
                target
            )));
        };
        let set = set.clone();

        match method {
            SetInstanceMethod::Add => {
                if args.len() != 1 {
                    return Err(Error::ScriptRuntime(
                        "Set.add requires exactly one argument".into(),
                    ));
                }
                let value = self.eval_expr(&args[0], env, event_param, event)?;
                self.set_add_value(&mut set.borrow_mut(), value);
                Ok(Value::Set(set))
            }
            SetInstanceMethod::Union => {
                if args.len() != 1 {
                    return Err(Error::ScriptRuntime(
                        "Set.union requires exactly one argument".into(),
                    ));
                }
                let other = self.eval_expr(&args[0], env, event_param, event)?;
                let other_keys = self.set_like_keys_snapshot(&other)?;
                let mut out = SetValue {
                    values: set.borrow().values.clone(),
                    properties: Vec::new(),
                };
                for key in other_keys {
                    self.set_add_value(&mut out, key);
                }
                Ok(Value::Set(Rc::new(RefCell::new(out))))
            }
            SetInstanceMethod::Intersection => {
                if args.len() != 1 {
                    return Err(Error::ScriptRuntime(
                        "Set.intersection requires exactly one argument".into(),
                    ));
                }
                let other = self.eval_expr(&args[0], env, event_param, event)?;
                let snapshot = set.borrow().values.clone();
                let mut out = SetValue {
                    values: Vec::new(),
                    properties: Vec::new(),
                };
                for value in snapshot {
                    if self.set_like_has_value(&other, &value)? {
                        self.set_add_value(&mut out, value);
                    }
                }
                Ok(Value::Set(Rc::new(RefCell::new(out))))
            }
            SetInstanceMethod::Difference => {
                if args.len() != 1 {
                    return Err(Error::ScriptRuntime(
                        "Set.difference requires exactly one argument".into(),
                    ));
                }
                let other = self.eval_expr(&args[0], env, event_param, event)?;
                let snapshot = set.borrow().values.clone();
                let mut out = SetValue {
                    values: Vec::new(),
                    properties: Vec::new(),
                };
                for value in snapshot {
                    if !self.set_like_has_value(&other, &value)? {
                        self.set_add_value(&mut out, value);
                    }
                }
                Ok(Value::Set(Rc::new(RefCell::new(out))))
            }
            SetInstanceMethod::SymmetricDifference => {
                if args.len() != 1 {
                    return Err(Error::ScriptRuntime(
                        "Set.symmetricDifference requires exactly one argument".into(),
                    ));
                }
                let other = self.eval_expr(&args[0], env, event_param, event)?;
                let other_keys = self.set_like_keys_snapshot(&other)?;
                let mut out = SetValue {
                    values: set.borrow().values.clone(),
                    properties: Vec::new(),
                };
                for key in other_keys {
                    if let Some(index) = self.set_value_index(&out, &key) {
                        out.values.remove(index);
                    } else {
                        out.values.push(key);
                    }
                }
                Ok(Value::Set(Rc::new(RefCell::new(out))))
            }
            SetInstanceMethod::IsDisjointFrom => {
                if args.len() != 1 {
                    return Err(Error::ScriptRuntime(
                        "Set.isDisjointFrom requires exactly one argument".into(),
                    ));
                }
                let other = self.eval_expr(&args[0], env, event_param, event)?;
                for value in &set.borrow().values {
                    if self.set_like_has_value(&other, value)? {
                        return Ok(Value::Bool(false));
                    }
                }
                Ok(Value::Bool(true))
            }
            SetInstanceMethod::IsSubsetOf => {
                if args.len() != 1 {
                    return Err(Error::ScriptRuntime(
                        "Set.isSubsetOf requires exactly one argument".into(),
                    ));
                }
                let other = self.eval_expr(&args[0], env, event_param, event)?;
                for value in &set.borrow().values {
                    if !self.set_like_has_value(&other, value)? {
                        return Ok(Value::Bool(false));
                    }
                }
                Ok(Value::Bool(true))
            }
            SetInstanceMethod::IsSupersetOf => {
                if args.len() != 1 {
                    return Err(Error::ScriptRuntime(
                        "Set.isSupersetOf requires exactly one argument".into(),
                    ));
                }
                let other = self.eval_expr(&args[0], env, event_param, event)?;
                for value in self.set_like_keys_snapshot(&other)? {
                    if self.set_value_index(&set.borrow(), &value).is_none() {
                        return Ok(Value::Bool(false));
                    }
                }
                Ok(Value::Bool(true))
            }
        }
    }

    fn new_symbol_value(
        &mut self,
        description: Option<String>,
        registry_key: Option<String>,
    ) -> Value {
        let id = self.next_symbol_id;
        self.next_symbol_id = self.next_symbol_id.saturating_add(1);
        let symbol = Rc::new(SymbolValue {
            id,
            description,
            registry_key,
        });
        self.symbols_by_id.insert(id, symbol.clone());
        Value::Symbol(symbol)
    }

    fn symbol_storage_key(id: usize) -> String {
        format!("{INTERNAL_SYMBOL_KEY_PREFIX}{id}")
    }

    fn symbol_id_from_storage_key(key: &str) -> Option<usize> {
        key.strip_prefix(INTERNAL_SYMBOL_KEY_PREFIX)
            .and_then(|value| value.parse::<usize>().ok())
    }

    fn is_symbol_storage_key(key: &str) -> bool {
        key.starts_with(INTERNAL_SYMBOL_KEY_PREFIX)
    }

    fn is_internal_object_key(key: &str) -> bool {
        Self::is_symbol_storage_key(key)
            || key == INTERNAL_SYMBOL_WRAPPER_KEY
            || key == INTERNAL_STRING_WRAPPER_VALUE_KEY
            || key.starts_with(INTERNAL_INTL_KEY_PREFIX)
            || key.starts_with(INTERNAL_CALLABLE_KEY_PREFIX)
    }

    fn symbol_wrapper_id_from_object(entries: &[(String, Value)]) -> Option<usize> {
        let value = Self::object_get_entry(entries, INTERNAL_SYMBOL_WRAPPER_KEY)?;
        match value {
            Value::Number(value) if value >= 0 => Some(value as usize),
            _ => None,
        }
    }

    fn string_wrapper_value_from_object(entries: &[(String, Value)]) -> Option<String> {
        match Self::object_get_entry(entries, INTERNAL_STRING_WRAPPER_VALUE_KEY) {
            Some(Value::String(value)) => Some(value),
            _ => None,
        }
    }

    fn symbol_id_from_property_key(&self, value: &Value) -> Option<usize> {
        match value {
            Value::Symbol(symbol) => Some(symbol.id),
            Value::Object(entries) => {
                let entries = entries.borrow();
                Self::symbol_wrapper_id_from_object(&entries)
            }
            _ => None,
        }
    }

    fn property_key_to_storage_key(&self, value: &Value) -> String {
        if let Some(symbol_id) = self.symbol_id_from_property_key(value) {
            Self::symbol_storage_key(symbol_id)
        } else {
            value.as_string()
        }
    }

    fn eval_symbol_construct(
        &mut self,
        description: &Option<Box<Expr>>,
        called_with_new: bool,
        env: &HashMap<String, Value>,
        event_param: &Option<String>,
        event: &EventState,
    ) -> Result<Value> {
        if called_with_new {
            return Err(Error::ScriptRuntime("Symbol is not a constructor".into()));
        }
        let description = if let Some(description) = description {
            let value = self.eval_expr(description, env, event_param, event)?;
            if matches!(value, Value::Undefined) {
                None
            } else {
                Some(value.as_string())
            }
        } else {
            None
        };
        Ok(self.new_symbol_value(description, None))
    }

    fn eval_symbol_static_method(
        &mut self,
        method: SymbolStaticMethod,
        args: &[Expr],
        env: &HashMap<String, Value>,
        event_param: &Option<String>,
        event: &EventState,
    ) -> Result<Value> {
        match method {
            SymbolStaticMethod::For => {
                if args.len() != 1 {
                    return Err(Error::ScriptRuntime(
                        "Symbol.for requires exactly one argument".into(),
                    ));
                }
                let key = self
                    .eval_expr(&args[0], env, event_param, event)?
                    .as_string();
                if let Some(symbol) = self.symbol_registry.get(&key) {
                    return Ok(Value::Symbol(symbol.clone()));
                }
                let symbol = match self.new_symbol_value(Some(key.clone()), Some(key.clone())) {
                    Value::Symbol(symbol) => symbol,
                    _ => unreachable!("new_symbol_value must create Symbol"),
                };
                self.symbol_registry.insert(key, symbol.clone());
                Ok(Value::Symbol(symbol))
            }
            SymbolStaticMethod::KeyFor => {
                if args.len() != 1 {
                    return Err(Error::ScriptRuntime(
                        "Symbol.keyFor requires exactly one argument".into(),
                    ));
                }
                let symbol = self.eval_expr(&args[0], env, event_param, event)?;
                let Value::Symbol(symbol) = symbol else {
                    return Err(Error::ScriptRuntime(
                        "Symbol.keyFor argument must be a Symbol".into(),
                    ));
                };
                if let Some(key) = &symbol.registry_key {
                    Ok(Value::String(key.clone()))
                } else {
                    Ok(Value::Undefined)
                }
            }
        }
    }

    fn symbol_static_property_name(property: SymbolStaticProperty) -> &'static str {
        match property {
            SymbolStaticProperty::AsyncDispose => "Symbol.asyncDispose",
            SymbolStaticProperty::AsyncIterator => "Symbol.asyncIterator",
            SymbolStaticProperty::Dispose => "Symbol.dispose",
            SymbolStaticProperty::HasInstance => "Symbol.hasInstance",
            SymbolStaticProperty::IsConcatSpreadable => "Symbol.isConcatSpreadable",
            SymbolStaticProperty::Iterator => "Symbol.iterator",
            SymbolStaticProperty::Match => "Symbol.match",
            SymbolStaticProperty::MatchAll => "Symbol.matchAll",
            SymbolStaticProperty::Replace => "Symbol.replace",
            SymbolStaticProperty::Search => "Symbol.search",
            SymbolStaticProperty::Species => "Symbol.species",
            SymbolStaticProperty::Split => "Symbol.split",
            SymbolStaticProperty::ToPrimitive => "Symbol.toPrimitive",
            SymbolStaticProperty::ToStringTag => "Symbol.toStringTag",
            SymbolStaticProperty::Unscopables => "Symbol.unscopables",
        }
    }

    fn eval_symbol_static_property(&mut self, property: SymbolStaticProperty) -> Value {
        let name = Self::symbol_static_property_name(property).to_string();
        if let Some(symbol) = self.well_known_symbols.get(&name) {
            return Value::Symbol(symbol.clone());
        }
        let symbol = match self.new_symbol_value(Some(name.clone()), None) {
            Value::Symbol(symbol) => symbol,
            _ => unreachable!("new_symbol_value must create Symbol"),
        };
        self.well_known_symbols.insert(name, symbol.clone());
        Value::Symbol(symbol)
    }

    fn eval_string_static_method(
        &mut self,
        method: StringStaticMethod,
        args: &[Expr],
        env: &HashMap<String, Value>,
        event_param: &Option<String>,
        event: &EventState,
    ) -> Result<Value> {
        match method {
            StringStaticMethod::FromCharCode => {
                let mut units = Vec::with_capacity(args.len());
                for arg in args {
                    let value = self.eval_expr(arg, env, event_param, event)?;
                    let unit = (Self::value_to_i64(&value) as i128).rem_euclid(1 << 16) as u16;
                    units.push(unit);
                }
                Ok(Value::String(String::from_utf16_lossy(&units)))
            }
            StringStaticMethod::FromCodePoint => {
                let mut out = String::new();
                for arg in args {
                    let value = self.eval_expr(arg, env, event_param, event)?;
                    let n = Self::coerce_number_for_global(&value);
                    if !n.is_finite() || n.fract() != 0.0 || !(0.0..=0x10_FFFF as f64).contains(&n)
                    {
                        return Err(Error::ScriptRuntime(
                            "Invalid code point for String.fromCodePoint".into(),
                        ));
                    }
                    let cp = n as u32;
                    if (0xD800..=0xDFFF).contains(&cp) {
                        return Err(Error::ScriptRuntime(
                            "Invalid code point for String.fromCodePoint".into(),
                        ));
                    }
                    let ch = char::from_u32(cp).ok_or_else(|| {
                        Error::ScriptRuntime("Invalid code point for String.fromCodePoint".into())
                    })?;
                    out.push(ch);
                }
                Ok(Value::String(out))
            }
            StringStaticMethod::Raw => {
                if args.is_empty() {
                    return Err(Error::ScriptRuntime(
                        "String.raw requires at least one argument".into(),
                    ));
                }
                let template = self.eval_expr(&args[0], env, event_param, event)?;
                let raw = match template {
                    Value::Object(entries) => {
                        let entries = entries.borrow();
                        Self::object_get_entry(&entries, "raw").unwrap_or(Value::Undefined)
                    }
                    other => other,
                };
                let raw_segments = self.array_like_values_from_value(&raw)?;
                let mut substitutions = Vec::with_capacity(args.len().saturating_sub(1));
                for arg in args.iter().skip(1) {
                    substitutions.push(self.eval_expr(arg, env, event_param, event)?.as_string());
                }
                if raw_segments.is_empty() {
                    return Ok(Value::String(String::new()));
                }
                let mut out = String::new();
                for (idx, segment) in raw_segments.iter().enumerate() {
                    out.push_str(&segment.as_string());
                    if let Some(substitution) = substitutions.get(idx) {
                        out.push_str(substitution);
                    }
                }
                Ok(Value::String(out))
            }
        }
    }

    fn eval_regexp_static_method(
        &mut self,
        method: RegExpStaticMethod,
        args: &[Expr],
        env: &HashMap<String, Value>,
        event_param: &Option<String>,
        event: &EventState,
    ) -> Result<Value> {
        match method {
            RegExpStaticMethod::Escape => {
                if args.len() != 1 {
                    return Err(Error::ScriptRuntime(
                        "RegExp.escape requires exactly one argument".into(),
                    ));
                }
                let value = self.eval_expr(&args[0], env, event_param, event)?;
                Ok(Value::String(regex::escape(&value.as_string())))
            }
        }
    }

    fn eval_string_match(&mut self, value: &str, pattern: Value) -> Result<Value> {
        let regex = if let Value::RegExp(regex) = pattern {
            regex
        } else {
            let compiled = Self::new_regex_from_values(&pattern, None)?;
            match compiled {
                Value::RegExp(regex) => regex,
                _ => unreachable!("RegExp constructor must return a RegExp"),
            }
        };

        let global = regex.borrow().global;
        if global {
            let compiled = regex.borrow().compiled.clone();
            let matches = compiled
                .find_iter(value)
                .map(|m| Value::String(m.as_str().to_string()))
                .collect::<Vec<_>>();
            regex.borrow_mut().last_index = 0;
            if matches.is_empty() {
                Ok(Value::Null)
            } else {
                Ok(Self::new_array_value(matches))
            }
        } else {
            let Some(captures) = Self::regex_exec(&regex, value)? else {
                return Ok(Value::Null);
            };
            Ok(Self::new_array_value(
                captures.into_iter().map(Value::String).collect::<Vec<_>>(),
            ))
        }
    }

    fn promise_error_reason(err: Error) -> Value {
        Value::String(format!("{err}"))
    }

    fn new_pending_promise(&mut self) -> Rc<RefCell<PromiseValue>> {
        let id = self.next_promise_id;
        self.next_promise_id = self.next_promise_id.saturating_add(1);
        Rc::new(RefCell::new(PromiseValue {
            id,
            state: PromiseState::Pending,
            reactions: Vec::new(),
        }))
    }

    fn new_promise_capability_functions(
        &self,
        promise: Rc<RefCell<PromiseValue>>,
    ) -> (Value, Value) {
        let already_called = Rc::new(RefCell::new(false));
        let resolve = Value::PromiseCapability(Rc::new(PromiseCapabilityFunction {
            promise: promise.clone(),
            reject: false,
            already_called: already_called.clone(),
        }));
        let reject = Value::PromiseCapability(Rc::new(PromiseCapabilityFunction {
            promise,
            reject: true,
            already_called,
        }));
        (resolve, reject)
    }

    fn promise_add_reaction(
        &mut self,
        promise: &Rc<RefCell<PromiseValue>>,
        kind: PromiseReactionKind,
    ) {
        let settled = {
            let mut promise_ref = promise.borrow_mut();
            match &promise_ref.state {
                PromiseState::Pending => {
                    promise_ref.reactions.push(PromiseReaction { kind });
                    return;
                }
                PromiseState::Fulfilled(value) => PromiseSettledValue::Fulfilled(value.clone()),
                PromiseState::Rejected(reason) => PromiseSettledValue::Rejected(reason.clone()),
            }
        };
        self.queue_promise_reaction_microtask(kind, settled);
    }

    fn promise_fulfill(&mut self, promise: &Rc<RefCell<PromiseValue>>, value: Value) {
        let reactions = {
            let mut promise_ref = promise.borrow_mut();
            if !matches!(promise_ref.state, PromiseState::Pending) {
                return;
            }
            promise_ref.state = PromiseState::Fulfilled(value.clone());
            std::mem::take(&mut promise_ref.reactions)
        };
        for reaction in reactions {
            self.queue_promise_reaction_microtask(
                reaction.kind,
                PromiseSettledValue::Fulfilled(value.clone()),
            );
        }
    }

    fn promise_reject(&mut self, promise: &Rc<RefCell<PromiseValue>>, reason: Value) {
        let reactions = {
            let mut promise_ref = promise.borrow_mut();
            if !matches!(promise_ref.state, PromiseState::Pending) {
                return;
            }
            promise_ref.state = PromiseState::Rejected(reason.clone());
            std::mem::take(&mut promise_ref.reactions)
        };
        for reaction in reactions {
            self.queue_promise_reaction_microtask(
                reaction.kind,
                PromiseSettledValue::Rejected(reason.clone()),
            );
        }
    }

    fn promise_resolve(&mut self, promise: &Rc<RefCell<PromiseValue>>, value: Value) -> Result<()> {
        if !matches!(promise.borrow().state, PromiseState::Pending) {
            return Ok(());
        }

        if let Value::Promise(other) = &value {
            if Rc::ptr_eq(other, promise) {
                self.promise_reject(
                    promise,
                    Value::String("TypeError: Cannot resolve promise with itself".into()),
                );
                return Ok(());
            }

            let settled = {
                let other_ref = other.borrow();
                match &other_ref.state {
                    PromiseState::Pending => None,
                    PromiseState::Fulfilled(value) => {
                        Some(PromiseSettledValue::Fulfilled(value.clone()))
                    }
                    PromiseState::Rejected(reason) => {
                        Some(PromiseSettledValue::Rejected(reason.clone()))
                    }
                }
            };

            if let Some(settled) = settled {
                match settled {
                    PromiseSettledValue::Fulfilled(value) => self.promise_fulfill(promise, value),
                    PromiseSettledValue::Rejected(reason) => self.promise_reject(promise, reason),
                }
            } else {
                self.promise_add_reaction(
                    other,
                    PromiseReactionKind::ResolveTo {
                        target: promise.clone(),
                    },
                );
            }
            return Ok(());
        }

        if let Value::Object(entries) = &value {
            let then = {
                let entries = entries.borrow();
                Self::object_get_entry(&entries, "then")
            };

            if let Some(then) = then {
                if self.is_callable_value(&then) {
                    let (resolve, reject) = self.new_promise_capability_functions(promise.clone());
                    let event = EventState::new("microtask", self.dom.root, self.now_ms);
                    match self.execute_callable_value(&then, &[resolve, reject], &event) {
                        Ok(_) => {}
                        Err(err) => self.promise_reject(promise, Self::promise_error_reason(err)),
                    }
                    return Ok(());
                }
            }
        }

        self.promise_fulfill(promise, value);
        Ok(())
    }

    fn promise_resolve_value_as_promise(
        &mut self,
        value: Value,
    ) -> Result<Rc<RefCell<PromiseValue>>> {
        if let Value::Promise(promise) = value {
            return Ok(promise);
        }
        let promise = self.new_pending_promise();
        self.promise_resolve(&promise, value)?;
        Ok(promise)
    }

    fn promise_then_internal(
        &mut self,
        promise: &Rc<RefCell<PromiseValue>>,
        on_fulfilled: Option<Value>,
        on_rejected: Option<Value>,
    ) -> Rc<RefCell<PromiseValue>> {
        let result = self.new_pending_promise();
        self.promise_add_reaction(
            promise,
            PromiseReactionKind::Then {
                on_fulfilled,
                on_rejected,
                result: result.clone(),
            },
        );
        result
    }

    fn eval_promise_construct(
        &mut self,
        executor: &Option<Box<Expr>>,
        called_with_new: bool,
        env: &HashMap<String, Value>,
        event_param: &Option<String>,
        event: &EventState,
    ) -> Result<Value> {
        if !called_with_new {
            return Err(Error::ScriptRuntime(
                "Promise constructor must be called with new".into(),
            ));
        }
        let Some(executor) = executor else {
            return Err(Error::ScriptRuntime(
                "Promise constructor requires exactly one executor".into(),
            ));
        };
        let executor = self.eval_expr(executor, env, event_param, event)?;
        if !self.is_callable_value(&executor) {
            return Err(Error::ScriptRuntime(
                "Promise constructor executor must be a function".into(),
            ));
        }

        let promise = self.new_pending_promise();
        let (resolve, reject) = self.new_promise_capability_functions(promise.clone());
        if let Err(err) = self.execute_callable_value(&executor, &[resolve, reject], event) {
            self.promise_reject(&promise, Self::promise_error_reason(err));
        }
        Ok(Value::Promise(promise))
    }

    fn eval_promise_static_method(
        &mut self,
        method: PromiseStaticMethod,
        args: &[Expr],
        env: &HashMap<String, Value>,
        event_param: &Option<String>,
        event: &EventState,
    ) -> Result<Value> {
        match method {
            PromiseStaticMethod::Resolve => {
                if args.len() > 1 {
                    return Err(Error::ScriptRuntime(
                        "Promise.resolve supports zero or one argument".into(),
                    ));
                }
                let value = if let Some(value) = args.first() {
                    self.eval_expr(value, env, event_param, event)?
                } else {
                    Value::Undefined
                };
                if let Value::Promise(promise) = value {
                    return Ok(Value::Promise(promise));
                }
                let promise = self.new_pending_promise();
                self.promise_resolve(&promise, value)?;
                Ok(Value::Promise(promise))
            }
            PromiseStaticMethod::Reject => {
                if args.len() > 1 {
                    return Err(Error::ScriptRuntime(
                        "Promise.reject supports zero or one argument".into(),
                    ));
                }
                let reason = if let Some(reason) = args.first() {
                    self.eval_expr(reason, env, event_param, event)?
                } else {
                    Value::Undefined
                };
                let promise = self.new_pending_promise();
                self.promise_reject(&promise, reason);
                Ok(Value::Promise(promise))
            }
            PromiseStaticMethod::All => {
                if args.len() != 1 {
                    return Err(Error::ScriptRuntime(
                        "Promise.all requires exactly one argument".into(),
                    ));
                }
                let iterable = self.eval_expr(&args[0], env, event_param, event)?;
                self.eval_promise_all(iterable)
            }
            PromiseStaticMethod::AllSettled => {
                if args.len() != 1 {
                    return Err(Error::ScriptRuntime(
                        "Promise.allSettled requires exactly one argument".into(),
                    ));
                }
                let iterable = self.eval_expr(&args[0], env, event_param, event)?;
                self.eval_promise_all_settled(iterable)
            }
            PromiseStaticMethod::Any => {
                if args.len() != 1 {
                    return Err(Error::ScriptRuntime(
                        "Promise.any requires exactly one argument".into(),
                    ));
                }
                let iterable = self.eval_expr(&args[0], env, event_param, event)?;
                self.eval_promise_any(iterable)
            }
            PromiseStaticMethod::Race => {
                if args.len() != 1 {
                    return Err(Error::ScriptRuntime(
                        "Promise.race requires exactly one argument".into(),
                    ));
                }
                let iterable = self.eval_expr(&args[0], env, event_param, event)?;
                self.eval_promise_race(iterable)
            }
            PromiseStaticMethod::Try => {
                if args.is_empty() {
                    return Err(Error::ScriptRuntime(
                        "Promise.try requires at least one argument".into(),
                    ));
                }
                let callback = self.eval_expr(&args[0], env, event_param, event)?;
                let mut callback_args = Vec::with_capacity(args.len().saturating_sub(1));
                for arg in args.iter().skip(1) {
                    callback_args.push(self.eval_expr(arg, env, event_param, event)?);
                }
                let promise = self.new_pending_promise();
                match self.execute_callable_value(&callback, &callback_args, event) {
                    Ok(value) => {
                        self.promise_resolve(&promise, value)?;
                    }
                    Err(err) => {
                        self.promise_reject(&promise, Self::promise_error_reason(err));
                    }
                }
                Ok(Value::Promise(promise))
            }
            PromiseStaticMethod::WithResolvers => {
                if !args.is_empty() {
                    return Err(Error::ScriptRuntime(
                        "Promise.withResolvers does not take arguments".into(),
                    ));
                }
                let promise = self.new_pending_promise();
                let (resolve, reject) = self.new_promise_capability_functions(promise.clone());
                Ok(Self::new_object_value(vec![
                    ("promise".into(), Value::Promise(promise)),
                    ("resolve".into(), resolve),
                    ("reject".into(), reject),
                ]))
            }
        }
    }

    fn eval_promise_method(
        &mut self,
        target: &Expr,
        method: PromiseInstanceMethod,
        args: &[Expr],
        env: &HashMap<String, Value>,
        event_param: &Option<String>,
        event: &EventState,
    ) -> Result<Value> {
        let target = self.eval_expr(target, env, event_param, event)?;
        let Value::Promise(promise) = target else {
            return Err(Error::ScriptRuntime(
                "Promise instance method target must be a Promise".into(),
            ));
        };

        match method {
            PromiseInstanceMethod::Then => {
                if args.len() > 2 {
                    return Err(Error::ScriptRuntime(
                        "Promise.then supports up to two arguments".into(),
                    ));
                }
                let on_fulfilled = if let Some(arg) = args.first() {
                    let value = self.eval_expr(arg, env, event_param, event)?;
                    if self.is_callable_value(&value) {
                        Some(value)
                    } else {
                        None
                    }
                } else {
                    None
                };
                let on_rejected = if args.len() >= 2 {
                    let value = self.eval_expr(&args[1], env, event_param, event)?;
                    if self.is_callable_value(&value) {
                        Some(value)
                    } else {
                        None
                    }
                } else {
                    None
                };

                Ok(Value::Promise(self.promise_then_internal(
                    &promise,
                    on_fulfilled,
                    on_rejected,
                )))
            }
            PromiseInstanceMethod::Catch => {
                if args.len() > 1 {
                    return Err(Error::ScriptRuntime(
                        "Promise.catch supports at most one argument".into(),
                    ));
                }
                let on_rejected = if let Some(arg) = args.first() {
                    let value = self.eval_expr(arg, env, event_param, event)?;
                    if self.is_callable_value(&value) {
                        Some(value)
                    } else {
                        None
                    }
                } else {
                    None
                };

                Ok(Value::Promise(self.promise_then_internal(
                    &promise,
                    None,
                    on_rejected,
                )))
            }
            PromiseInstanceMethod::Finally => {
                if args.len() > 1 {
                    return Err(Error::ScriptRuntime(
                        "Promise.finally supports at most one argument".into(),
                    ));
                }
                let callback = if let Some(arg) = args.first() {
                    let value = self.eval_expr(arg, env, event_param, event)?;
                    if self.is_callable_value(&value) {
                        Some(value)
                    } else {
                        None
                    }
                } else {
                    None
                };
                let result = self.new_pending_promise();
                self.promise_add_reaction(
                    &promise,
                    PromiseReactionKind::Finally {
                        callback,
                        result: result.clone(),
                    },
                );
                Ok(Value::Promise(result))
            }
        }
    }

    fn eval_promise_all(&mut self, iterable: Value) -> Result<Value> {
        let values = self.array_like_values_from_value(&iterable)?;
        let result = self.new_pending_promise();
        if values.is_empty() {
            self.promise_fulfill(&result, Self::new_array_value(Vec::new()));
            return Ok(Value::Promise(result));
        }

        let state = Rc::new(RefCell::new(PromiseAllState {
            result: result.clone(),
            remaining: values.len(),
            values: vec![None; values.len()],
            settled: false,
        }));

        for (index, value) in values.into_iter().enumerate() {
            let promise = self.promise_resolve_value_as_promise(value)?;
            self.promise_add_reaction(
                &promise,
                PromiseReactionKind::All {
                    state: state.clone(),
                    index,
                },
            );
        }

        Ok(Value::Promise(result))
    }

    fn eval_promise_all_settled(&mut self, iterable: Value) -> Result<Value> {
        let values = self.array_like_values_from_value(&iterable)?;
        let result = self.new_pending_promise();
        if values.is_empty() {
            self.promise_fulfill(&result, Self::new_array_value(Vec::new()));
            return Ok(Value::Promise(result));
        }

        let state = Rc::new(RefCell::new(PromiseAllSettledState {
            result: result.clone(),
            remaining: values.len(),
            values: vec![None; values.len()],
        }));

        for (index, value) in values.into_iter().enumerate() {
            let promise = self.promise_resolve_value_as_promise(value)?;
            self.promise_add_reaction(
                &promise,
                PromiseReactionKind::AllSettled {
                    state: state.clone(),
                    index,
                },
            );
        }

        Ok(Value::Promise(result))
    }

    fn eval_promise_any(&mut self, iterable: Value) -> Result<Value> {
        let values = self.array_like_values_from_value(&iterable)?;
        let result = self.new_pending_promise();
        if values.is_empty() {
            self.promise_reject(&result, Self::new_aggregate_error_value(Vec::new()));
            return Ok(Value::Promise(result));
        }

        let state = Rc::new(RefCell::new(PromiseAnyState {
            result: result.clone(),
            remaining: values.len(),
            reasons: vec![None; values.len()],
            settled: false,
        }));

        for (index, value) in values.into_iter().enumerate() {
            let promise = self.promise_resolve_value_as_promise(value)?;
            self.promise_add_reaction(
                &promise,
                PromiseReactionKind::Any {
                    state: state.clone(),
                    index,
                },
            );
        }

        Ok(Value::Promise(result))
    }

    fn eval_promise_race(&mut self, iterable: Value) -> Result<Value> {
        let values = self.array_like_values_from_value(&iterable)?;
        let result = self.new_pending_promise();
        if values.is_empty() {
            return Ok(Value::Promise(result));
        }

        let state = Rc::new(RefCell::new(PromiseRaceState {
            result: result.clone(),
            settled: false,
        }));

        for value in values {
            let promise = self.promise_resolve_value_as_promise(value)?;
            self.promise_add_reaction(
                &promise,
                PromiseReactionKind::Race {
                    state: state.clone(),
                },
            );
        }

        Ok(Value::Promise(result))
    }

    fn new_aggregate_error_value(reasons: Vec<Value>) -> Value {
        Self::new_object_value(vec![
            ("name".into(), Value::String("AggregateError".into())),
            (
                "message".into(),
                Value::String("All promises were rejected".into()),
            ),
            ("errors".into(), Self::new_array_value(reasons)),
        ])
    }

    fn run_promise_reaction_task(
        &mut self,
        reaction: PromiseReactionKind,
        settled: PromiseSettledValue,
    ) -> Result<()> {
        let event = EventState::new("microtask", self.dom.root, self.now_ms);
        match reaction {
            PromiseReactionKind::Then {
                on_fulfilled,
                on_rejected,
                result,
            } => match settled {
                PromiseSettledValue::Fulfilled(value) => {
                    if let Some(callback) = on_fulfilled {
                        match self.execute_callable_value(
                            &callback,
                            std::slice::from_ref(&value),
                            &event,
                        ) {
                            Ok(next) => self.promise_resolve(&result, next)?,
                            Err(err) => {
                                self.promise_reject(&result, Self::promise_error_reason(err))
                            }
                        }
                    } else {
                        self.promise_fulfill(&result, value);
                    }
                }
                PromiseSettledValue::Rejected(reason) => {
                    if let Some(callback) = on_rejected {
                        match self.execute_callable_value(
                            &callback,
                            std::slice::from_ref(&reason),
                            &event,
                        ) {
                            Ok(next) => self.promise_resolve(&result, next)?,
                            Err(err) => {
                                self.promise_reject(&result, Self::promise_error_reason(err))
                            }
                        }
                    } else {
                        self.promise_reject(&result, reason);
                    }
                }
            },
            PromiseReactionKind::Finally { callback, result } => {
                if let Some(callback) = callback {
                    match self.execute_callable_value(&callback, &[], &event) {
                        Ok(next) => {
                            let continuation = self.promise_resolve_value_as_promise(next)?;
                            self.promise_add_reaction(
                                &continuation,
                                PromiseReactionKind::FinallyContinuation {
                                    original: settled,
                                    result,
                                },
                            );
                        }
                        Err(err) => self.promise_reject(&result, Self::promise_error_reason(err)),
                    }
                } else {
                    match settled {
                        PromiseSettledValue::Fulfilled(value) => {
                            self.promise_fulfill(&result, value)
                        }
                        PromiseSettledValue::Rejected(reason) => {
                            self.promise_reject(&result, reason)
                        }
                    }
                }
            }
            PromiseReactionKind::FinallyContinuation { original, result } => match settled {
                PromiseSettledValue::Fulfilled(_) => match original {
                    PromiseSettledValue::Fulfilled(value) => self.promise_fulfill(&result, value),
                    PromiseSettledValue::Rejected(reason) => self.promise_reject(&result, reason),
                },
                PromiseSettledValue::Rejected(reason) => self.promise_reject(&result, reason),
            },
            PromiseReactionKind::ResolveTo { target } => match settled {
                PromiseSettledValue::Fulfilled(value) => self.promise_resolve(&target, value)?,
                PromiseSettledValue::Rejected(reason) => self.promise_reject(&target, reason),
            },
            PromiseReactionKind::All { state, index } => {
                let mut state_ref = state.borrow_mut();
                if state_ref.settled {
                    return Ok(());
                }
                match settled {
                    PromiseSettledValue::Fulfilled(value) => {
                        if state_ref.values[index].is_none() {
                            state_ref.values[index] = Some(value);
                            state_ref.remaining = state_ref.remaining.saturating_sub(1);
                        }
                        if state_ref.remaining == 0 {
                            state_ref.settled = true;
                            let result = state_ref.result.clone();
                            let values = state_ref
                                .values
                                .iter()
                                .map(|value| value.clone().unwrap_or(Value::Undefined))
                                .collect::<Vec<_>>();
                            drop(state_ref);
                            self.promise_fulfill(&result, Self::new_array_value(values));
                        }
                    }
                    PromiseSettledValue::Rejected(reason) => {
                        state_ref.settled = true;
                        let result = state_ref.result.clone();
                        drop(state_ref);
                        self.promise_reject(&result, reason);
                    }
                }
            }
            PromiseReactionKind::AllSettled { state, index } => {
                let mut state_ref = state.borrow_mut();
                if state_ref.remaining == 0 {
                    return Ok(());
                }
                if state_ref.values[index].is_none() {
                    let entry = match settled {
                        PromiseSettledValue::Fulfilled(value) => Self::new_object_value(vec![
                            ("status".into(), Value::String("fulfilled".into())),
                            ("value".into(), value),
                        ]),
                        PromiseSettledValue::Rejected(reason) => Self::new_object_value(vec![
                            ("status".into(), Value::String("rejected".into())),
                            ("reason".into(), reason),
                        ]),
                    };
                    state_ref.values[index] = Some(entry);
                    state_ref.remaining = state_ref.remaining.saturating_sub(1);
                }
                if state_ref.remaining == 0 {
                    let result = state_ref.result.clone();
                    let values = state_ref
                        .values
                        .iter()
                        .map(|value| value.clone().unwrap_or(Value::Undefined))
                        .collect::<Vec<_>>();
                    drop(state_ref);
                    self.promise_fulfill(&result, Self::new_array_value(values));
                }
            }
            PromiseReactionKind::Any { state, index } => {
                let mut state_ref = state.borrow_mut();
                if state_ref.settled {
                    return Ok(());
                }
                match settled {
                    PromiseSettledValue::Fulfilled(value) => {
                        state_ref.settled = true;
                        let result = state_ref.result.clone();
                        drop(state_ref);
                        self.promise_fulfill(&result, value);
                    }
                    PromiseSettledValue::Rejected(reason) => {
                        if state_ref.reasons[index].is_none() {
                            state_ref.reasons[index] = Some(reason);
                            state_ref.remaining = state_ref.remaining.saturating_sub(1);
                        }
                        if state_ref.remaining == 0 {
                            state_ref.settled = true;
                            let result = state_ref.result.clone();
                            let reasons = state_ref
                                .reasons
                                .iter()
                                .map(|reason| reason.clone().unwrap_or(Value::Undefined))
                                .collect::<Vec<_>>();
                            drop(state_ref);
                            self.promise_reject(&result, Self::new_aggregate_error_value(reasons));
                        }
                    }
                }
            }
            PromiseReactionKind::Race { state } => {
                let mut state_ref = state.borrow_mut();
                if state_ref.settled {
                    return Ok(());
                }
                state_ref.settled = true;
                let result = state_ref.result.clone();
                drop(state_ref);
                match settled {
                    PromiseSettledValue::Fulfilled(value) => self.promise_fulfill(&result, value),
                    PromiseSettledValue::Rejected(reason) => self.promise_reject(&result, reason),
                }
            }
        }
        Ok(())
    }

    fn execute_callback_value(
        &mut self,
        callback: &Value,
        args: &[Value],
        event: &EventState,
    ) -> Result<Value> {
        self.execute_callable_value(callback, args, event)
    }

    fn eval_typed_array_method(
        &mut self,
        target: &str,
        method: TypedArrayInstanceMethod,
        args: &[Expr],
        env: &HashMap<String, Value>,
        event_param: &Option<String>,
        event: &EventState,
    ) -> Result<Value> {
        if !matches!(env.get(target), Some(Value::TypedArray(_))) {
            let Some(target_value) = env.get(target) else {
                return Err(Error::ScriptRuntime(format!(
                    "unknown variable: {}",
                    target
                )));
            };

            if let Value::Map(map) = target_value {
                return match method {
                    TypedArrayInstanceMethod::Set => {
                        if args.len() != 2 {
                            return Err(Error::ScriptRuntime(
                                "Map.set requires exactly two arguments".into(),
                            ));
                        }
                        let key = self.eval_expr(&args[0], env, event_param, event)?;
                        let value = self.eval_expr(&args[1], env, event_param, event)?;
                        self.map_set_entry(&mut map.borrow_mut(), key, value);
                        Ok(Value::Map(map.clone()))
                    }
                    TypedArrayInstanceMethod::Entries => {
                        if !args.is_empty() {
                            return Err(Error::ScriptRuntime(
                                "Map.entries does not take arguments".into(),
                            ));
                        }
                        Ok(Self::new_array_value(self.map_entries_array(map)))
                    }
                    TypedArrayInstanceMethod::Keys => {
                        if !args.is_empty() {
                            return Err(Error::ScriptRuntime(
                                "Map.keys does not take arguments".into(),
                            ));
                        }
                        Ok(Self::new_array_value(
                            map.borrow()
                                .entries
                                .iter()
                                .map(|(key, _)| key.clone())
                                .collect(),
                        ))
                    }
                    TypedArrayInstanceMethod::Values => {
                        if !args.is_empty() {
                            return Err(Error::ScriptRuntime(
                                "Map.values does not take arguments".into(),
                            ));
                        }
                        Ok(Self::new_array_value(
                            map.borrow()
                                .entries
                                .iter()
                                .map(|(_, value)| value.clone())
                                .collect(),
                        ))
                    }
                    _ => Err(Error::ScriptRuntime(format!(
                        "variable '{}' is not a TypedArray",
                        target
                    ))),
                };
            }

            if let Value::Set(set) = target_value {
                return match method {
                    TypedArrayInstanceMethod::Entries => {
                        if !args.is_empty() {
                            return Err(Error::ScriptRuntime(
                                "Set.entries does not take arguments".into(),
                            ));
                        }
                        Ok(Self::new_array_value(self.set_entries_array(set)))
                    }
                    TypedArrayInstanceMethod::Keys | TypedArrayInstanceMethod::Values => {
                        if !args.is_empty() {
                            return Err(Error::ScriptRuntime(
                                "Set.keys/values does not take arguments".into(),
                            ));
                        }
                        Ok(Self::new_array_value(self.set_values_array(set)))
                    }
                    _ => Err(Error::ScriptRuntime(format!(
                        "variable '{}' is not a TypedArray",
                        target
                    ))),
                };
            }

            if matches!(method, TypedArrayInstanceMethod::At) {
                if args.len() > 1 {
                    return Err(Error::ScriptRuntime(
                        "at supports zero or one argument".into(),
                    ));
                }
                let index = if let Some(index) = args.first() {
                    Self::value_to_i64(&self.eval_expr(index, env, event_param, event)?)
                } else {
                    0
                };

                return match target_value {
                    Value::String(value) => {
                        let len = value.chars().count() as i64;
                        let index = if index < 0 { len + index } else { index };
                        if index < 0 || index >= len {
                            Ok(Value::Undefined)
                        } else {
                            Ok(value
                                .chars()
                                .nth(index as usize)
                                .map(|ch| Value::String(ch.to_string()))
                                .unwrap_or(Value::Undefined))
                        }
                    }
                    Value::Object(entries) => {
                        let entries = entries.borrow();
                        if let Some(value) = Self::string_wrapper_value_from_object(&entries) {
                            let len = value.chars().count() as i64;
                            let index = if index < 0 { len + index } else { index };
                            if index < 0 || index >= len {
                                Ok(Value::Undefined)
                            } else {
                                Ok(value
                                    .chars()
                                    .nth(index as usize)
                                    .map(|ch| Value::String(ch.to_string()))
                                    .unwrap_or(Value::Undefined))
                            }
                        } else {
                            Err(Error::ScriptRuntime(format!(
                                "variable '{}' is not a TypedArray",
                                target
                            )))
                        }
                    }
                    _ => Err(Error::ScriptRuntime(format!(
                        "variable '{}' is not a TypedArray",
                        target
                    ))),
                };
            }

            if matches!(
                method,
                TypedArrayInstanceMethod::IndexOf | TypedArrayInstanceMethod::LastIndexOf
            ) {
                if args.is_empty() || args.len() > 2 {
                    return Err(Error::ScriptRuntime(
                        "indexOf requires one or two arguments".into(),
                    ));
                }
                let search = self.eval_expr(&args[0], env, event_param, event)?;

                return match target_value {
                    Value::String(value) => {
                        let len = value.chars().count() as i64;
                        if matches!(method, TypedArrayInstanceMethod::IndexOf) {
                            let mut start = if args.len() == 2 {
                                Self::value_to_i64(&self.eval_expr(
                                    &args[1],
                                    env,
                                    event_param,
                                    event,
                                )?)
                            } else {
                                0
                            };
                            if start < 0 {
                                start = 0;
                            }
                            if start > len {
                                start = len;
                            }
                            let index =
                                Self::string_index_of(value, &search.as_string(), start as usize)
                                    .map(|idx| idx as i64)
                                    .unwrap_or(-1);
                            Ok(Value::Number(index))
                        } else {
                            let mut from = if args.len() == 2 {
                                Self::value_to_i64(&self.eval_expr(
                                    &args[1],
                                    env,
                                    event_param,
                                    event,
                                )?)
                            } else {
                                len
                            };
                            if from < 0 {
                                from = 0;
                            }
                            if from > len {
                                from = len;
                            }
                            let from = from as usize;
                            let search = search.as_string();
                            if search.is_empty() {
                                return Ok(Value::Number(from as i64));
                            }
                            for idx in (0..=from).rev() {
                                let byte_idx = Self::char_index_to_byte(value, idx);
                                if value[byte_idx..].starts_with(&search) {
                                    return Ok(Value::Number(idx as i64));
                                }
                            }
                            Ok(Value::Number(-1))
                        }
                    }
                    Value::Array(values) => {
                        let from = if matches!(method, TypedArrayInstanceMethod::IndexOf) {
                            let len = values.borrow().len() as i64;
                            let mut from = if args.len() == 2 {
                                Self::value_to_i64(&self.eval_expr(
                                    &args[1],
                                    env,
                                    event_param,
                                    event,
                                )?)
                            } else {
                                0
                            };
                            if from < 0 {
                                from = (len + from).max(0);
                            }
                            if from > len {
                                from = len;
                            }
                            from
                        } else {
                            let len = values.borrow().len() as i64;
                            let from = if args.len() == 2 {
                                Self::value_to_i64(&self.eval_expr(
                                    &args[1],
                                    env,
                                    event_param,
                                    event,
                                )?)
                            } else {
                                len - 1
                            };
                            if from < 0 {
                                (len + from).max(-1)
                            } else {
                                from.min(len - 1)
                            }
                        };

                        let values = values.borrow();
                        if matches!(method, TypedArrayInstanceMethod::IndexOf) {
                            for (index, value) in values.iter().enumerate().skip(from as usize) {
                                if self.strict_equal(value, &search) {
                                    return Ok(Value::Number(index as i64));
                                }
                            }
                            Ok(Value::Number(-1))
                        } else {
                            if from < 0 {
                                return Ok(Value::Number(-1));
                            }
                            for index in (0..=from as usize).rev() {
                                if self.strict_equal(&values[index], &search) {
                                    return Ok(Value::Number(index as i64));
                                }
                            }
                            Ok(Value::Number(-1))
                        }
                    }
                    _ => Err(Error::ScriptRuntime(format!(
                        "variable '{}' is not a TypedArray",
                        target
                    ))),
                };
            }

            return Err(Error::ScriptRuntime(format!(
                "variable '{}' is not a TypedArray",
                target
            )));
        }

        let array = self.resolve_typed_array_from_env(env, target)?;
        if array.borrow().buffer.borrow().detached {
            return Err(Error::ScriptRuntime(
                "Cannot perform TypedArray method on a detached ArrayBuffer".into(),
            ));
        }
        let kind = array.borrow().kind;
        let len = array.borrow().observed_length();
        let this_value = Value::TypedArray(array.clone());

        match method {
            TypedArrayInstanceMethod::At => {
                if args.len() != 1 {
                    return Err(Error::ScriptRuntime(
                        "TypedArray.at requires exactly one argument".into(),
                    ));
                }
                let index = self.eval_expr(&args[0], env, event_param, event)?;
                let mut index = Self::value_to_i64(&index);
                let len_i64 = len as i64;
                if index < 0 {
                    index += len_i64;
                }
                if index < 0 || index >= len_i64 {
                    return Ok(Value::Undefined);
                }
                self.typed_array_get_index(&array, index as usize)
            }
            TypedArrayInstanceMethod::CopyWithin => {
                if args.len() < 2 || args.len() > 3 {
                    return Err(Error::ScriptRuntime(
                        "TypedArray.copyWithin requires 2 or 3 arguments".into(),
                    ));
                }
                let target_index =
                    Self::value_to_i64(&self.eval_expr(&args[0], env, event_param, event)?);
                let start_index =
                    Self::value_to_i64(&self.eval_expr(&args[1], env, event_param, event)?);
                let end_index = if args.len() == 3 {
                    Self::value_to_i64(&self.eval_expr(&args[2], env, event_param, event)?)
                } else {
                    len as i64
                };
                let target_index = Self::normalize_slice_index(len, target_index);
                let start_index = Self::normalize_slice_index(len, start_index);
                let end_index = Self::normalize_slice_index(len, end_index);
                let end_index = end_index.max(start_index);
                let count = end_index
                    .saturating_sub(start_index)
                    .min(len.saturating_sub(target_index));
                let snapshot = self.typed_array_snapshot(&array)?;
                for offset in 0..count {
                    self.typed_array_set_index(
                        &array,
                        target_index + offset,
                        snapshot[start_index + offset].clone(),
                    )?;
                }
                Ok(this_value)
            }
            TypedArrayInstanceMethod::Entries => {
                if !args.is_empty() {
                    return Err(Error::ScriptRuntime(
                        "TypedArray.entries does not take arguments".into(),
                    ));
                }
                let snapshot = self.typed_array_snapshot(&array)?;
                let out = snapshot
                    .into_iter()
                    .enumerate()
                    .map(|(index, value)| {
                        Self::new_array_value(vec![Value::Number(index as i64), value])
                    })
                    .collect::<Vec<_>>();
                Ok(Self::new_array_value(out))
            }
            TypedArrayInstanceMethod::Fill => {
                if args.is_empty() || args.len() > 3 {
                    return Err(Error::ScriptRuntime(
                        "TypedArray.fill requires 1 to 3 arguments".into(),
                    ));
                }
                let value = self.eval_expr(&args[0], env, event_param, event)?;
                let start = if args.len() >= 2 {
                    Self::value_to_i64(&self.eval_expr(&args[1], env, event_param, event)?)
                } else {
                    0
                };
                let end = if args.len() == 3 {
                    Self::value_to_i64(&self.eval_expr(&args[2], env, event_param, event)?)
                } else {
                    len as i64
                };
                let start = Self::normalize_slice_index(len, start);
                let end = Self::normalize_slice_index(len, end).max(start);
                for index in start..end {
                    self.typed_array_set_index(&array, index, value.clone())?;
                }
                Ok(this_value)
            }
            TypedArrayInstanceMethod::FindIndex
            | TypedArrayInstanceMethod::FindLast
            | TypedArrayInstanceMethod::FindLastIndex => {
                if args.len() != 1 {
                    return Err(Error::ScriptRuntime(
                        "TypedArray find callback methods require exactly one argument".into(),
                    ));
                }
                let callback = self.eval_expr(&args[0], env, event_param, event)?;
                let snapshot = self.typed_array_snapshot(&array)?;
                let iter: Box<dyn Iterator<Item = (usize, Value)>> = match method {
                    TypedArrayInstanceMethod::FindLast
                    | TypedArrayInstanceMethod::FindLastIndex => {
                        Box::new(snapshot.into_iter().enumerate().rev())
                    }
                    _ => Box::new(snapshot.into_iter().enumerate()),
                };
                for (index, value) in iter {
                    let matched = self.execute_callback_value(
                        &callback,
                        &[
                            value.clone(),
                            Value::Number(index as i64),
                            this_value.clone(),
                        ],
                        event,
                    )?;
                    if matched.truthy() {
                        return if matches!(
                            method,
                            TypedArrayInstanceMethod::FindLastIndex
                                | TypedArrayInstanceMethod::FindIndex
                        ) {
                            Ok(Value::Number(index as i64))
                        } else {
                            Ok(value)
                        };
                    }
                }
                if matches!(
                    method,
                    TypedArrayInstanceMethod::FindLastIndex | TypedArrayInstanceMethod::FindIndex
                ) {
                    Ok(Value::Number(-1))
                } else {
                    Ok(Value::Undefined)
                }
            }
            TypedArrayInstanceMethod::IndexOf | TypedArrayInstanceMethod::LastIndexOf => {
                if args.is_empty() || args.len() > 2 {
                    return Err(Error::ScriptRuntime(
                        "TypedArray indexOf methods require one or two arguments".into(),
                    ));
                }
                let search = self.eval_expr(&args[0], env, event_param, event)?;
                let snapshot = self.typed_array_snapshot(&array)?;
                if matches!(method, TypedArrayInstanceMethod::IndexOf) {
                    let from = if args.len() == 2 {
                        Self::value_to_i64(&self.eval_expr(&args[1], env, event_param, event)?)
                    } else {
                        0
                    };
                    let mut from = if from < 0 {
                        (len as i64 + from).max(0)
                    } else {
                        from
                    };
                    if from > len as i64 {
                        from = len as i64;
                    }
                    for (index, value) in snapshot.iter().enumerate().skip(from as usize) {
                        if self.strict_equal(value, &search) {
                            return Ok(Value::Number(index as i64));
                        }
                    }
                    Ok(Value::Number(-1))
                } else {
                    let from = if args.len() == 2 {
                        Self::value_to_i64(&self.eval_expr(&args[1], env, event_param, event)?)
                    } else {
                        (len as i64) - 1
                    };
                    let from = if from < 0 {
                        (len as i64 + from).max(-1)
                    } else {
                        from.min((len as i64) - 1)
                    };
                    if from < 0 {
                        return Ok(Value::Number(-1));
                    }
                    for index in (0..=from as usize).rev() {
                        if self.strict_equal(&snapshot[index], &search) {
                            return Ok(Value::Number(index as i64));
                        }
                    }
                    Ok(Value::Number(-1))
                }
            }
            TypedArrayInstanceMethod::Keys => {
                if !args.is_empty() {
                    return Err(Error::ScriptRuntime(
                        "TypedArray.keys does not take arguments".into(),
                    ));
                }
                Ok(Self::new_array_value(
                    (0..len).map(|index| Value::Number(index as i64)).collect(),
                ))
            }
            TypedArrayInstanceMethod::ReduceRight => {
                if args.is_empty() || args.len() > 2 {
                    return Err(Error::ScriptRuntime(
                        "TypedArray.reduceRight requires callback and optional initial value"
                            .into(),
                    ));
                }
                let callback = self.eval_expr(&args[0], env, event_param, event)?;
                let snapshot = self.typed_array_snapshot(&array)?;
                let mut iter = snapshot.into_iter().enumerate().rev();
                let mut acc = if args.len() == 2 {
                    self.eval_expr(&args[1], env, event_param, event)?
                } else {
                    let Some((_, first)) = iter.next() else {
                        return Err(Error::ScriptRuntime(
                            "reduce of empty array with no initial value".into(),
                        ));
                    };
                    first
                };
                for (index, value) in iter {
                    acc = self.execute_callback_value(
                        &callback,
                        &[acc, value, Value::Number(index as i64), this_value.clone()],
                        event,
                    )?;
                }
                Ok(acc)
            }
            TypedArrayInstanceMethod::Reverse => {
                if !args.is_empty() {
                    return Err(Error::ScriptRuntime(
                        "TypedArray.reverse does not take arguments".into(),
                    ));
                }
                let mut snapshot = self.typed_array_snapshot(&array)?;
                snapshot.reverse();
                for (index, value) in snapshot.into_iter().enumerate() {
                    self.typed_array_set_index(&array, index, value)?;
                }
                Ok(this_value)
            }
            TypedArrayInstanceMethod::Set => {
                if args.is_empty() || args.len() > 2 {
                    return Err(Error::ScriptRuntime(
                        "TypedArray.set requires source and optional offset".into(),
                    ));
                }
                let source = self.eval_expr(&args[0], env, event_param, event)?;
                let source_values = self.array_like_values_from_value(&source)?;
                let offset = if args.len() == 2 {
                    Self::to_non_negative_usize(
                        &self.eval_expr(&args[1], env, event_param, event)?,
                        "TypedArray.set offset",
                    )?
                } else {
                    0
                };
                if offset > len || source_values.len() > len.saturating_sub(offset) {
                    return Err(Error::ScriptRuntime(
                        "source array is too large for target TypedArray".into(),
                    ));
                }
                for (index, value) in source_values.into_iter().enumerate() {
                    self.typed_array_set_index(&array, offset + index, value)?;
                }
                Ok(Value::Undefined)
            }
            TypedArrayInstanceMethod::Sort => {
                if args.len() > 1 {
                    return Err(Error::ScriptRuntime(
                        "TypedArray.sort supports at most one argument".into(),
                    ));
                }
                if args.len() == 1 {
                    return Err(Error::ScriptRuntime(
                        "custom comparator for TypedArray.sort is not supported".into(),
                    ));
                }
                let mut snapshot = self.typed_array_snapshot(&array)?;
                if kind.is_bigint() {
                    snapshot.sort_by(|left, right| {
                        let left = match left {
                            Value::BigInt(value) => value.clone(),
                            _ => JsBigInt::zero(),
                        };
                        let right = match right {
                            Value::BigInt(value) => value.clone(),
                            _ => JsBigInt::zero(),
                        };
                        left.cmp(&right)
                    });
                } else {
                    snapshot.sort_by(|left, right| {
                        let left = Self::coerce_number_for_global(left);
                        let right = Self::coerce_number_for_global(right);
                        match (left.is_nan(), right.is_nan()) {
                            (true, true) => std::cmp::Ordering::Equal,
                            (true, false) => std::cmp::Ordering::Greater,
                            (false, true) => std::cmp::Ordering::Less,
                            (false, false) => left
                                .partial_cmp(&right)
                                .unwrap_or(std::cmp::Ordering::Equal),
                        }
                    });
                }
                for (index, value) in snapshot.into_iter().enumerate() {
                    self.typed_array_set_index(&array, index, value)?;
                }
                Ok(this_value)
            }
            TypedArrayInstanceMethod::Subarray => {
                if args.len() > 2 {
                    return Err(Error::ScriptRuntime(
                        "TypedArray.subarray supports at most two arguments".into(),
                    ));
                }
                let begin = if !args.is_empty() {
                    Self::value_to_i64(&self.eval_expr(&args[0], env, event_param, event)?)
                } else {
                    0
                };
                let end = if args.len() == 2 {
                    Self::value_to_i64(&self.eval_expr(&args[1], env, event_param, event)?)
                } else {
                    len as i64
                };
                let begin = Self::normalize_slice_index(len, begin);
                let end = Self::normalize_slice_index(len, end).max(begin);
                let byte_offset = array
                    .borrow()
                    .byte_offset
                    .saturating_add(begin.saturating_mul(kind.bytes_per_element()));
                self.new_typed_array_view(
                    kind,
                    array.borrow().buffer.clone(),
                    byte_offset,
                    Some(end.saturating_sub(begin)),
                )
            }
            TypedArrayInstanceMethod::ToReversed => {
                if !args.is_empty() {
                    return Err(Error::ScriptRuntime(
                        "TypedArray.toReversed does not take arguments".into(),
                    ));
                }
                let mut snapshot = self.typed_array_snapshot(&array)?;
                snapshot.reverse();
                self.new_typed_array_from_values(kind, &snapshot)
            }
            TypedArrayInstanceMethod::ToSorted => {
                if args.len() > 1 {
                    return Err(Error::ScriptRuntime(
                        "TypedArray.toSorted supports at most one argument".into(),
                    ));
                }
                if args.len() == 1 {
                    return Err(Error::ScriptRuntime(
                        "custom comparator for TypedArray.toSorted is not supported".into(),
                    ));
                }
                let mut snapshot = self.typed_array_snapshot(&array)?;
                if kind.is_bigint() {
                    snapshot.sort_by(|left, right| {
                        let left = match left {
                            Value::BigInt(value) => value.clone(),
                            _ => JsBigInt::zero(),
                        };
                        let right = match right {
                            Value::BigInt(value) => value.clone(),
                            _ => JsBigInt::zero(),
                        };
                        left.cmp(&right)
                    });
                } else {
                    snapshot.sort_by(|left, right| {
                        let left = Self::coerce_number_for_global(left);
                        let right = Self::coerce_number_for_global(right);
                        match (left.is_nan(), right.is_nan()) {
                            (true, true) => std::cmp::Ordering::Equal,
                            (true, false) => std::cmp::Ordering::Greater,
                            (false, true) => std::cmp::Ordering::Less,
                            (false, false) => left
                                .partial_cmp(&right)
                                .unwrap_or(std::cmp::Ordering::Equal),
                        }
                    });
                }
                self.new_typed_array_from_values(kind, &snapshot)
            }
            TypedArrayInstanceMethod::Values => {
                if !args.is_empty() {
                    return Err(Error::ScriptRuntime(
                        "TypedArray.values does not take arguments".into(),
                    ));
                }
                Ok(Self::new_array_value(self.typed_array_snapshot(&array)?))
            }
            TypedArrayInstanceMethod::With => {
                if args.len() != 2 {
                    return Err(Error::ScriptRuntime(
                        "TypedArray.with requires exactly two arguments".into(),
                    ));
                }
                let index =
                    Self::value_to_i64(&self.eval_expr(&args[0], env, event_param, event)?);
                let value = self.eval_expr(&args[1], env, event_param, event)?;
                let index = if index < 0 {
                    (len as i64) + index
                } else {
                    index
                };
                if index < 0 || index >= len as i64 {
                    return Err(Error::ScriptRuntime(
                        "TypedArray.with index out of range".into(),
                    ));
                }
                let mut snapshot = self.typed_array_snapshot(&array)?;
                snapshot[index as usize] = value;
                self.new_typed_array_from_values(kind, &snapshot)
            }
        }
    }

    fn execute_array_callback(
        &mut self,
        callback: &ScriptHandler,
        args: &[Value],
        env: &HashMap<String, Value>,
        event: &EventState,
    ) -> Result<Value> {
        let mut callback_env = env.clone();
        callback_env.remove(INTERNAL_RETURN_SLOT);
        let mut callback_event = event.clone();
        let event_param = None;
        self.bind_handler_params(
            callback,
            args,
            &mut callback_env,
            &event_param,
            &callback_event,
        )?;
        match self.execute_stmts(
            &callback.stmts,
            &event_param,
            &mut callback_event,
            &mut callback_env,
        )? {
            ExecFlow::Continue | ExecFlow::Return => {}
            ExecFlow::Break => {
                return Err(Error::ScriptRuntime(
                    "break statement outside of loop".into(),
                ));
            }
            ExecFlow::ContinueLoop => {
                return Err(Error::ScriptRuntime(
                    "continue statement outside of loop".into(),
                ));
            }
        }

        Ok(callback_env
            .remove(INTERNAL_RETURN_SLOT)
            .unwrap_or(Value::Undefined))
    }

    fn execute_array_callback_in_env(
        &mut self,
        callback: &ScriptHandler,
        args: &[Value],
        env: &mut HashMap<String, Value>,
        event: &EventState,
    ) -> Result<()> {
        let mut previous_values = Vec::with_capacity(callback.params.len());
        for param in &callback.params {
            previous_values.push((param.name.clone(), env.get(&param.name).cloned()));
        }

        let mut callback_event = event.clone();
        let event_param = None;
        self.bind_handler_params(callback, args, env, &event_param, &callback_event)?;
        let result = self.execute_stmts(&callback.stmts, &event_param, &mut callback_event, env);
        env.remove(INTERNAL_RETURN_SLOT);

        for (name, previous) in previous_values {
            if let Some(previous) = previous {
                env.insert(name, previous);
            } else {
                env.remove(&name);
            }
        }

        match result? {
            ExecFlow::Continue | ExecFlow::Return => Ok(()),
            ExecFlow::Break => Err(Error::ScriptRuntime(
                "break statement outside of loop".into(),
            )),
            ExecFlow::ContinueLoop => Err(Error::ScriptRuntime(
                "continue statement outside of loop".into(),
            )),
        }
    }

    fn normalize_slice_index(len: usize, index: i64) -> usize {
        if index < 0 {
            len.saturating_sub(index.unsigned_abs() as usize)
        } else {
            (index as usize).min(len)
        }
    }

    fn normalize_splice_start_index(len: usize, start: i64) -> usize {
        if start < 0 {
            len.saturating_sub(start.unsigned_abs() as usize)
        } else {
            (start as usize).min(len)
        }
    }

    fn normalize_substring_index(len: usize, index: i64) -> usize {
        if index < 0 {
            0
        } else {
            (index as usize).min(len)
        }
    }

    fn char_index_to_byte(value: &str, char_index: usize) -> usize {
        value
            .char_indices()
            .nth(char_index)
            .map(|(idx, _)| idx)
            .unwrap_or(value.len())
    }

    fn substring_chars(value: &str, start: usize, end: usize) -> String {
        if start >= end {
            return String::new();
        }
        value.chars().skip(start).take(end - start).collect()
    }

    fn split_string(value: &str, separator: Option<String>, limit: Option<i64>) -> Vec<Value> {
        let mut parts = match separator {
            None => vec![Value::String(value.to_string())],
            Some(separator) => {
                if separator.is_empty() {
                    value
                        .chars()
                        .map(|ch| Value::String(ch.to_string()))
                        .collect::<Vec<_>>()
                } else {
                    value
                        .split(&separator)
                        .map(|part| Value::String(part.to_string()))
                        .collect::<Vec<_>>()
                }
            }
        };

        if let Some(limit) = limit {
            if limit == 0 {
                parts.clear();
            } else if limit > 0 {
                parts.truncate(limit as usize);
            }
        }

        parts
    }

    fn split_string_with_regex(
        value: &str,
        regex: &Rc<RefCell<RegexValue>>,
        limit: Option<i64>,
    ) -> Vec<Value> {
        let compiled = regex.borrow().compiled.clone();
        let mut parts = compiled
            .split(value)
            .map(|part| Value::String(part.to_string()))
            .collect::<Vec<_>>();
        if let Some(limit) = limit {
            if limit == 0 {
                parts.clear();
            } else if limit > 0 {
                parts.truncate(limit as usize);
            }
        }
        parts
    }

    fn expand_regex_replacement(template: &str, captures: &Captures<'_>) -> String {
        let chars = template.chars().collect::<Vec<_>>();
        let mut i = 0usize;
        let mut out = String::new();
        while i < chars.len() {
            if chars[i] != '$' {
                out.push(chars[i]);
                i += 1;
                continue;
            }
            if i + 1 >= chars.len() {
                out.push('$');
                i += 1;
                continue;
            }
            let next = chars[i + 1];
            match next {
                '$' => {
                    out.push('$');
                    i += 2;
                }
                '&' => {
                    if let Some(full) = captures.get(0) {
                        out.push_str(full.as_str());
                    }
                    i += 2;
                }
                '0'..='9' => {
                    let mut idx = (next as u8 - b'0') as usize;
                    let mut consumed = 2usize;
                    if i + 2 < chars.len() && chars[i + 2].is_ascii_digit() {
                        let candidate = idx * 10 + (chars[i + 2] as u8 - b'0') as usize;
                        if captures.get(candidate).is_some() {
                            idx = candidate;
                            consumed = 3;
                        }
                    }
                    if idx > 0 {
                        if let Some(group) = captures.get(idx) {
                            out.push_str(group.as_str());
                        }
                    } else {
                        out.push('$');
                        out.push('0');
                    }
                    i += consumed;
                }
                _ => {
                    out.push('$');
                    out.push(next);
                    i += 2;
                }
            }
        }
        out
    }

    fn replace_string_with_regex(
        value: &str,
        regex: &Rc<RefCell<RegexValue>>,
        replacement: &str,
    ) -> String {
        let (compiled, global) = {
            let regex = regex.borrow();
            (regex.compiled.clone(), regex.global)
        };

        if global {
            let mut out = String::new();
            let mut last_end = 0usize;
            for captures in compiled.captures_iter(value) {
                let Some(full) = captures.get(0) else {
                    continue;
                };
                out.push_str(&value[last_end..full.start()]);
                out.push_str(&Self::expand_regex_replacement(replacement, &captures));
                last_end = full.end();
            }
            out.push_str(&value[last_end..]);
            out
        } else if let Some(captures) = compiled.captures(value) {
            if let Some(full) = captures.get(0) {
                let mut out = String::new();
                out.push_str(&value[..full.start()]);
                out.push_str(&Self::expand_regex_replacement(replacement, &captures));
                out.push_str(&value[full.end()..]);
                out
            } else {
                value.to_string()
            }
        } else {
            value.to_string()
        }
    }

    fn string_index_of(value: &str, search: &str, start_char_idx: usize) -> Option<usize> {
        let start_byte = Self::char_index_to_byte(value, start_char_idx);
        let pos = value.get(start_byte..)?.find(search)?;
        Some(value[..start_byte + pos].chars().count())
    }

    fn parse_date_string_to_epoch_ms(src: &str) -> Option<i64> {
        let src = src.trim();
        if src.is_empty() {
            return None;
        }

        let bytes = src.as_bytes();
        let mut i = 0usize;

        let mut sign = 1i64;
        if i < bytes.len() && (bytes[i] == b'+' || bytes[i] == b'-') {
            if bytes[i] == b'-' {
                sign = -1;
            }
            i += 1;
        }

        let year_start = i;
        while i < bytes.len() && bytes[i].is_ascii_digit() {
            i += 1;
        }
        if i <= year_start || (i - year_start) < 4 {
            return None;
        }
        let year = sign * src.get(year_start..i)?.parse::<i64>().ok()?;

        if i >= bytes.len() || bytes[i] != b'-' {
            return None;
        }
        i += 1;
        let month = Self::parse_fixed_digits_i64(src, &mut i, 2)?;
        if i >= bytes.len() || bytes[i] != b'-' {
            return None;
        }
        i += 1;
        let day = Self::parse_fixed_digits_i64(src, &mut i, 2)?;

        let month = u32::try_from(month).ok()?;
        if !(1..=12).contains(&month) {
            return None;
        }
        let day = u32::try_from(day).ok()?;
        if day == 0 || day > Self::days_in_month(year, month) {
            return None;
        }

        let mut hour = 0i64;
        let mut minute = 0i64;
        let mut second = 0i64;
        let mut millisecond = 0i64;
        let mut offset_minutes = 0i64;

        if i < bytes.len() {
            if bytes[i] != b'T' && bytes[i] != b' ' {
                return None;
            }
            i += 1;

            hour = Self::parse_fixed_digits_i64(src, &mut i, 2)?;
            if i >= bytes.len() || bytes[i] != b':' {
                return None;
            }
            i += 1;
            minute = Self::parse_fixed_digits_i64(src, &mut i, 2)?;

            if i < bytes.len() && bytes[i] == b':' {
                i += 1;
                second = Self::parse_fixed_digits_i64(src, &mut i, 2)?;
            }

            if i < bytes.len() && bytes[i] == b'.' {
                i += 1;
                let frac_start = i;
                while i < bytes.len() && bytes[i].is_ascii_digit() {
                    i += 1;
                }
                if i == frac_start {
                    return None;
                }

                let frac = src.get(frac_start..i)?;
                let mut parsed = 0i64;
                let mut digits = 0usize;
                for ch in frac.chars().take(3) {
                    parsed = parsed * 10 + i64::from(ch.to_digit(10)?);
                    digits += 1;
                }
                while digits < 3 {
                    parsed *= 10;
                    digits += 1;
                }
                millisecond = parsed;
            }

            if i < bytes.len() {
                match bytes[i] {
                    b'Z' | b'z' => {
                        i += 1;
                    }
                    b'+' | b'-' => {
                        let tz_sign = if bytes[i] == b'+' { 1 } else { -1 };
                        i += 1;
                        let tz_hour = Self::parse_fixed_digits_i64(src, &mut i, 2)?;
                        let tz_minute = if i < bytes.len() && bytes[i] == b':' {
                            i += 1;
                            Self::parse_fixed_digits_i64(src, &mut i, 2)?
                        } else {
                            Self::parse_fixed_digits_i64(src, &mut i, 2)?
                        };
                        if tz_hour > 23 || tz_minute > 59 {
                            return None;
                        }
                        offset_minutes = tz_sign * (tz_hour * 60 + tz_minute);
                    }
                    _ => return None,
                }
            }
        }

        if i != bytes.len() {
            return None;
        }
        if hour > 23 || minute > 59 || second > 59 {
            return None;
        }

        let timestamp_ms = Self::utc_timestamp_ms_from_components(
            year,
            i64::from(month) - 1,
            i64::from(day),
            hour,
            minute,
            second,
            millisecond,
        );
        Some(timestamp_ms - offset_minutes * 60_000)
    }

    fn parse_fixed_digits_i64(src: &str, i: &mut usize, width: usize) -> Option<i64> {
        let end = i.checked_add(width)?;
        let segment = src.get(*i..end)?;
        if !segment.as_bytes().iter().all(|b| b.is_ascii_digit()) {
            return None;
        }
        *i = end;
        segment.parse::<i64>().ok()
    }

    fn format_iso_8601_utc(timestamp_ms: i64) -> String {
        let (year, month, day, hour, minute, second, millisecond) =
            Self::date_components_utc(timestamp_ms);
        let year_str = if (0..=9999).contains(&year) {
            format!("{year:04}")
        } else if year < 0 {
            format!("-{:06}", -(year as i128))
        } else {
            format!("+{:06}", year)
        };
        format!(
            "{year_str}-{month:02}-{day:02}T{hour:02}:{minute:02}:{second:02}.{millisecond:03}Z"
        )
    }

    fn date_components_utc(timestamp_ms: i64) -> (i64, u32, u32, u32, u32, u32, u32) {
        let days = timestamp_ms.div_euclid(86_400_000);
        let rem = timestamp_ms.rem_euclid(86_400_000);
        let hour = (rem / 3_600_000) as u32;
        let minute = ((rem % 3_600_000) / 60_000) as u32;
        let second = ((rem % 60_000) / 1_000) as u32;
        let millisecond = (rem % 1_000) as u32;
        let (year, month, day) = Self::civil_from_days(days);
        (year, month, day, hour, minute, second, millisecond)
    }

    fn utc_timestamp_ms_from_components(
        year: i64,
        month_zero_based: i64,
        day: i64,
        hour: i64,
        minute: i64,
        second: i64,
        millisecond: i64,
    ) -> i64 {
        let (norm_year, norm_month) = Self::normalize_year_month(year, month_zero_based);
        let mut days = Self::days_from_civil(norm_year, norm_month, 1) + (day - 1);
        let mut time_ms = ((hour * 60 + minute) * 60 + second) * 1_000 + millisecond;
        days += time_ms.div_euclid(86_400_000);
        time_ms = time_ms.rem_euclid(86_400_000);

        let out = (days as i128) * 86_400_000i128 + (time_ms as i128);
        out.clamp(i128::from(i64::MIN), i128::from(i64::MAX)) as i64
    }

    fn normalize_year_month(year: i64, month_zero_based: i64) -> (i64, u32) {
        let total_month = year.saturating_mul(12).saturating_add(month_zero_based);
        let norm_year = total_month.div_euclid(12);
        let norm_month = total_month.rem_euclid(12) as u32 + 1;
        (norm_year, norm_month)
    }

    fn days_from_civil(year: i64, month: u32, day: u32) -> i64 {
        let adjusted_year = year - if month <= 2 { 1 } else { 0 };
        let era = adjusted_year.div_euclid(400);
        let yoe = adjusted_year - era * 400;
        let month = i64::from(month);
        let day = i64::from(day);
        let doy = (153 * (month + if month > 2 { -3 } else { 9 }) + 2) / 5 + day - 1;
        let doe = yoe * 365 + yoe / 4 - yoe / 100 + doy;
        era * 146_097 + doe - 719_468
    }

    fn civil_from_days(days: i64) -> (i64, u32, u32) {
        let z = days + 719_468;
        let era = z.div_euclid(146_097);
        let doe = z - era * 146_097;
        let yoe = (doe - doe / 1_460 + doe / 36_524 - doe / 146_096).div_euclid(365);
        let mut year = yoe + era * 400;
        let doy = doe - (365 * yoe + yoe / 4 - yoe / 100);
        let mp = (5 * doy + 2).div_euclid(153);
        let day = (doy - (153 * mp + 2).div_euclid(5) + 1) as u32;
        let month = (mp + if mp < 10 { 3 } else { -9 }) as u32;
        if month <= 2 {
            year += 1;
        }
        (year, month, day)
    }

    fn days_in_month(year: i64, month: u32) -> u32 {
        match month {
            1 | 3 | 5 | 7 | 8 | 10 | 12 => 31,
            4 | 6 | 9 | 11 => 30,
            2 => {
                if Self::is_leap_year(year) {
                    29
                } else {
                    28
                }
            }
            _ => 0,
        }
    }

    fn is_leap_year(year: i64) -> bool {
        (year % 4 == 0 && year % 100 != 0) || year % 400 == 0
    }

    fn numeric_value(&self, value: &Value) -> f64 {
        match value {
            Value::Number(v) => *v as f64,
            Value::Float(v) => *v,
            Value::BigInt(v) => v.to_f64().unwrap_or_else(|| {
                if v.sign() == Sign::Minus {
                    f64::NEG_INFINITY
                } else {
                    f64::INFINITY
                }
            }),
            Value::Date(v) => *v.borrow() as f64,
            Value::Null => 0.0,
            Value::Undefined => f64::NAN,
            _ => value.as_string().parse::<f64>().unwrap_or(0.0),
        }
    }

    fn coerce_number_for_global(value: &Value) -> f64 {
        match value {
            Value::Number(v) => *v as f64,
            Value::Float(v) => *v,
            Value::BigInt(v) => v.to_f64().unwrap_or_else(|| {
                if v.sign() == Sign::Minus {
                    f64::NEG_INFINITY
                } else {
                    f64::INFINITY
                }
            }),
            Value::Bool(v) => {
                if *v {
                    1.0
                } else {
                    0.0
                }
            }
            Value::Null => 0.0,
            Value::Undefined => f64::NAN,
            Value::String(v) => Self::parse_js_number_from_string(v),
            Value::Date(v) => *v.borrow() as f64,
            Value::Object(_)
            | Value::Promise(_)
            | Value::Map(_)
            | Value::Set(_)
            | Value::ArrayBuffer(_)
            | Value::TypedArray(_)
            | Value::StringConstructor
            | Value::TypedArrayConstructor(_)
            | Value::ArrayBufferConstructor
            | Value::PromiseConstructor
            | Value::MapConstructor
            | Value::SetConstructor
            | Value::SymbolConstructor
            | Value::RegExpConstructor
            | Value::PromiseCapability(_)
            | Value::Symbol(_)
            | Value::RegExp(_)
            | Value::Node(_)
            | Value::NodeList(_)
            | Value::FormData(_)
            | Value::Function(_) => f64::NAN,
            Value::Array(values) => {
                let rendered = Value::Array(values.clone()).as_string();
                Self::parse_js_number_from_string(&rendered)
            }
        }
    }

    fn to_i32_for_bitwise(&self, value: &Value) -> i32 {
        let numeric = self.numeric_value(value);
        if !numeric.is_finite() {
            return 0;
        }
        let unsigned = numeric.trunc().rem_euclid(4_294_967_296.0);
        if unsigned >= 2_147_483_648.0 {
            (unsigned - 4_294_967_296.0) as i32
        } else {
            unsigned as i32
        }
    }

    fn to_u32_for_bitwise(&self, value: &Value) -> u32 {
        let numeric = self.numeric_value(value);
        if !numeric.is_finite() {
            return 0;
        }
        numeric.trunc().rem_euclid(4_294_967_296.0) as u32
    }

    fn resolve_dom_query_var_path_value(
        &self,
        base: &str,
        path: &[String],
        env: &HashMap<String, Value>,
    ) -> Result<Option<Value>> {
        let Some(mut value) = env.get(base).cloned() else {
            return Err(Error::ScriptRuntime(format!(
                "unknown element variable: {}",
                base
            )));
        };

        for key in path {
            let next = match self.object_property_from_value(&value, key) {
                Ok(next) => next,
                Err(_) => return Ok(None),
            };
            if matches!(next, Value::Null | Value::Undefined) {
                return Ok(None);
            }
            value = next;
        }

        Ok(Some(value))
    }

    fn resolve_dom_query_list_static(&mut self, target: &DomQuery) -> Result<Option<Vec<NodeId>>> {
        match target {
            DomQuery::BySelectorAll { selector } => {
                Ok(Some(self.dom.query_selector_all(selector)?))
            }
            DomQuery::QuerySelectorAll { target, selector } => {
                let Some(target_node) = self.resolve_dom_query_static(target)? else {
                    return Ok(None);
                };
                Ok(Some(
                    self.dom.query_selector_all_from(&target_node, selector)?,
                ))
            }
            DomQuery::Index { target, index } => {
                let Some(list) = self.resolve_dom_query_list_static(target)? else {
                    return Ok(None);
                };
                let index = self.resolve_runtime_dom_index(index, None)?;
                Ok(list.get(index).copied().map(|node| vec![node]))
            }
            DomQuery::BySelectorAllIndex { selector, index } => {
                let index = index.static_index().ok_or_else(|| {
                    Error::ScriptRuntime("dynamic index in static context".into())
                })?;
                Ok(self
                    .dom
                    .query_selector_all(selector)?
                    .get(index)
                    .copied()
                    .map(|node| vec![node]))
            }
            DomQuery::QuerySelectorAllIndex {
                target,
                selector,
                index,
            } => {
                let Some(target_node) = self.resolve_dom_query_static(target)? else {
                    return Ok(None);
                };
                let index = index.static_index().ok_or_else(|| {
                    Error::ScriptRuntime("dynamic index in static context".into())
                })?;
                let list = self.dom.query_selector_all_from(&target_node, selector)?;
                Ok(list.get(index).copied().map(|node| vec![node]))
            }
            DomQuery::Var(_) | DomQuery::VarPath { .. } => Err(Error::ScriptRuntime(
                "element variable cannot be resolved in static context".into(),
            )),
            _ => Ok(None),
        }
    }

    fn resolve_dom_query_list_runtime(
        &mut self,
        target: &DomQuery,
        env: &HashMap<String, Value>,
    ) -> Result<Option<Vec<NodeId>>> {
        match target {
            DomQuery::Var(name) => match env.get(name) {
                Some(Value::NodeList(nodes)) => Ok(Some(nodes.clone())),
                Some(Value::Node(_)) => Err(Error::ScriptRuntime(format!(
                    "variable '{}' is not a node list",
                    name
                ))),
                Some(_) => Err(Error::ScriptRuntime(format!(
                    "variable '{}' is not a node list",
                    name
                ))),
                None => Err(Error::ScriptRuntime(format!(
                    "unknown element variable: {}",
                    name
                ))),
            },
            DomQuery::VarPath { base, path } => {
                let Some(value) = self.resolve_dom_query_var_path_value(base, path, env)? else {
                    return Ok(None);
                };
                match value {
                    Value::NodeList(nodes) => Ok(Some(nodes)),
                    _ => Err(Error::ScriptRuntime(format!(
                        "variable '{}' is not a node list",
                        target.describe_call()
                    ))),
                }
            }
            _ => self.resolve_dom_query_list_static(target),
        }
    }

    fn resolve_dom_query_static(&mut self, target: &DomQuery) -> Result<Option<NodeId>> {
        match target {
            DomQuery::DocumentRoot => Ok(Some(self.dom.root)),
            DomQuery::DocumentBody => Ok(self.dom.body()),
            DomQuery::DocumentHead => Ok(self.dom.head()),
            DomQuery::DocumentElement => Ok(self.dom.document_element()),
            DomQuery::ById(id) => Ok(self.dom.by_id(id)),
            DomQuery::BySelector(selector) => self.dom.query_selector(selector),
            DomQuery::BySelectorAll { .. } => Err(Error::ScriptRuntime(
                "cannot use querySelectorAll result as single element".into(),
            )),
            DomQuery::BySelectorAllIndex { selector, index } => {
                let index = index.static_index().ok_or_else(|| {
                    Error::ScriptRuntime("dynamic index in static context".into())
                })?;
                let all = self.dom.query_selector_all(selector)?;
                Ok(all.get(index).copied())
            }
            DomQuery::Index { target, index } => {
                let Some(list) = self.resolve_dom_query_list_static(target)? else {
                    return Ok(None);
                };
                let index = self.resolve_runtime_dom_index(index, None)?;
                Ok(list.get(index).copied())
            }
            DomQuery::QuerySelector { target, selector } => {
                let Some(target_node) = self.resolve_dom_query_static(target)? else {
                    return Ok(None);
                };
                self.dom.query_selector_from(&target_node, selector)
            }
            DomQuery::QuerySelectorAll { .. } => Err(Error::ScriptRuntime(
                "cannot use querySelectorAll result as single element".into(),
            )),
            DomQuery::QuerySelectorAllIndex {
                target,
                selector,
                index,
            } => {
                let Some(target_node) = self.resolve_dom_query_static(target)? else {
                    return Ok(None);
                };
                let index = index.static_index().ok_or_else(|| {
                    Error::ScriptRuntime("dynamic index in static context".into())
                })?;
                let all = self.dom.query_selector_all_from(&target_node, selector)?;
                Ok(all.get(index).copied())
            }
            DomQuery::FormElementsIndex { form, index } => {
                let Some(form_node) = self.resolve_dom_query_static(form)? else {
                    return Ok(None);
                };
                let all = self.form_elements(form_node)?;
                let index = self.resolve_runtime_dom_index(index, None)?;
                Ok(all.get(index).copied())
            }
            DomQuery::Var(_) | DomQuery::VarPath { .. } => Err(Error::ScriptRuntime(
                "element variable cannot be resolved in static context".into(),
            )),
        }
    }

    fn resolve_dom_query_runtime(
        &mut self,
        target: &DomQuery,
        env: &HashMap<String, Value>,
    ) -> Result<Option<NodeId>> {
        match target {
            DomQuery::DocumentRoot => Ok(Some(self.dom.root)),
            DomQuery::DocumentBody => Ok(self.dom.body()),
            DomQuery::DocumentHead => Ok(self.dom.head()),
            DomQuery::DocumentElement => Ok(self.dom.document_element()),
            DomQuery::Var(name) => match env.get(name) {
                Some(Value::Node(node)) => Ok(Some(*node)),
                Some(Value::NodeList(_)) => Err(Error::ScriptRuntime(format!(
                    "variable '{}' is not a single element",
                    name
                ))),
                Some(_) => Err(Error::ScriptRuntime(format!(
                    "variable '{}' is not a single element",
                    name
                ))),
                None => Err(Error::ScriptRuntime(format!(
                    "unknown element variable: {}",
                    name
                ))),
            },
            DomQuery::VarPath { base, path } => {
                let Some(value) = self.resolve_dom_query_var_path_value(base, path, env)? else {
                    return Ok(None);
                };
                match value {
                    Value::Node(node) => Ok(Some(node)),
                    _ => Err(Error::ScriptRuntime(format!(
                        "variable '{}' is not a single element",
                        target.describe_call()
                    ))),
                }
            }
            DomQuery::BySelectorAll { .. } => Err(Error::ScriptRuntime(
                "cannot use querySelectorAll result as single element".into(),
            )),
            DomQuery::QuerySelectorAll { .. } => Err(Error::ScriptRuntime(
                "cannot use querySelectorAll result as single element".into(),
            )),
            DomQuery::Index { target, index } => {
                let Some(list) = self.resolve_dom_query_list_runtime(target, env)? else {
                    return Ok(None);
                };
                let index = self.resolve_runtime_dom_index(index, Some(env))?;
                Ok(list.get(index).copied())
            }
            DomQuery::QuerySelector { target, selector } => {
                let Some(target_node) = self.resolve_dom_query_runtime(target, env)? else {
                    return Ok(None);
                };
                self.dom.query_selector_from(&target_node, selector)
            }
            DomQuery::QuerySelectorAllIndex {
                target,
                selector,
                index,
            } => {
                let Some(target_node) = self.resolve_dom_query_runtime(target, env)? else {
                    return Ok(None);
                };
                let index = self.resolve_runtime_dom_index(index, Some(env))?;
                let all = self.dom.query_selector_all_from(&target_node, selector)?;
                Ok(all.get(index).copied())
            }
            DomQuery::FormElementsIndex { form, index } => {
                let Some(form_node) = self.resolve_dom_query_runtime(form, env)? else {
                    return Ok(None);
                };
                let all = self.form_elements(form_node)?;
                let index = self.resolve_runtime_dom_index(index, Some(env))?;
                Ok(all.get(index).copied())
            }
            _ => self.resolve_dom_query_static(target),
        }
    }

    fn resolve_dom_query_required_runtime(
        &mut self,
        target: &DomQuery,
        env: &HashMap<String, Value>,
    ) -> Result<NodeId> {
        self.resolve_dom_query_runtime(target, env)?.ok_or_else(|| {
            Error::ScriptRuntime(format!("{} returned null", target.describe_call()))
        })
    }

    fn resolve_runtime_dom_index(
        &mut self,
        index: &DomIndex,
        env: Option<&HashMap<String, Value>>,
    ) -> Result<usize> {
        match index {
            DomIndex::Static(index) => Ok(*index),
            DomIndex::Dynamic(expr_src) => {
                let expr = parse_expr(expr_src)?;
                let event = EventState::new("script", self.dom.root, self.now_ms);
                let value = self.eval_expr(
                    &expr,
                    env.ok_or_else(|| {
                        Error::ScriptRuntime("dynamic index requires runtime context".into())
                    })?,
                    &None,
                    &event,
                )?;
                self.value_as_index(&value).ok_or_else(|| {
                    Error::ScriptRuntime(format!("invalid index expression: {expr_src}"))
                })
            }
        }
    }

    fn describe_dom_prop(&self, prop: &DomProp) -> String {
        match prop {
            DomProp::Value => "value".into(),
            DomProp::Checked => "checked".into(),
            DomProp::Open => "open".into(),
            DomProp::ReturnValue => "returnValue".into(),
            DomProp::ClosedBy => "closedBy".into(),
            DomProp::Readonly => "readonly".into(),
            DomProp::Required => "required".into(),
            DomProp::Disabled => "disabled".into(),
            DomProp::TextContent => "textContent".into(),
            DomProp::InnerHtml => "innerHTML".into(),
            DomProp::ClassName => "className".into(),
            DomProp::Id => "id".into(),
            DomProp::Name => "name".into(),
            DomProp::OffsetWidth => "offsetWidth".into(),
            DomProp::OffsetHeight => "offsetHeight".into(),
            DomProp::OffsetLeft => "offsetLeft".into(),
            DomProp::OffsetTop => "offsetTop".into(),
            DomProp::ScrollWidth => "scrollWidth".into(),
            DomProp::ScrollHeight => "scrollHeight".into(),
            DomProp::ScrollLeft => "scrollLeft".into(),
            DomProp::ScrollTop => "scrollTop".into(),
            DomProp::Dataset(_) => "dataset".into(),
            DomProp::Style(_) => "style".into(),
            DomProp::ActiveElement => "activeElement".into(),
            DomProp::CharacterSet => "characterSet".into(),
            DomProp::CompatMode => "compatMode".into(),
            DomProp::ContentType => "contentType".into(),
            DomProp::ReadyState => "readyState".into(),
            DomProp::Referrer => "referrer".into(),
            DomProp::Title => "title".into(),
            DomProp::Url => "URL".into(),
            DomProp::DocumentUri => "documentURI".into(),
            DomProp::Location => "location".into(),
            DomProp::LocationHref => "location.href".into(),
            DomProp::LocationProtocol => "location.protocol".into(),
            DomProp::LocationHost => "location.host".into(),
            DomProp::LocationHostname => "location.hostname".into(),
            DomProp::LocationPort => "location.port".into(),
            DomProp::LocationPathname => "location.pathname".into(),
            DomProp::LocationSearch => "location.search".into(),
            DomProp::LocationHash => "location.hash".into(),
            DomProp::LocationOrigin => "location.origin".into(),
            DomProp::LocationAncestorOrigins => "location.ancestorOrigins".into(),
            DomProp::History => "history".into(),
            DomProp::HistoryLength => "history.length".into(),
            DomProp::HistoryState => "history.state".into(),
            DomProp::HistoryScrollRestoration => "history.scrollRestoration".into(),
            DomProp::DefaultView => "defaultView".into(),
            DomProp::Hidden => "hidden".into(),
            DomProp::VisibilityState => "visibilityState".into(),
            DomProp::Forms => "forms".into(),
            DomProp::Images => "images".into(),
            DomProp::Links => "links".into(),
            DomProp::Scripts => "scripts".into(),
            DomProp::Children => "children".into(),
            DomProp::ChildElementCount => "childElementCount".into(),
            DomProp::FirstElementChild => "firstElementChild".into(),
            DomProp::LastElementChild => "lastElementChild".into(),
            DomProp::CurrentScript => "currentScript".into(),
            DomProp::FormsLength => "forms.length".into(),
            DomProp::ImagesLength => "images.length".into(),
            DomProp::LinksLength => "links.length".into(),
            DomProp::ScriptsLength => "scripts.length".into(),
            DomProp::ChildrenLength => "children.length".into(),
        }
    }

    fn event_node_label(&self, node: NodeId) -> String {
        if let Some(id) = self.dom.attr(node, "id") {
            if !id.is_empty() {
                return id;
            }
        }
        self.dom
            .tag_name(node)
            .map(ToOwned::to_owned)
            .unwrap_or_else(|| format!("node-{}", node.0))
    }

    fn trace_node_label(&self, node: NodeId) -> String {
        if let Some(id) = self.dom.attr(node, "id") {
            if !id.is_empty() {
                return format!("#{id}");
            }
        }
        self.dom
            .tag_name(node)
            .map(ToOwned::to_owned)
            .unwrap_or_else(|| format!("node-{}", node.0))
    }

    fn value_to_i64(value: &Value) -> i64 {
        match value {
            Value::Number(v) => *v,
            Value::Float(v) => *v as i64,
            Value::BigInt(v) => v.to_i64().unwrap_or_else(|| {
                if v.sign() == Sign::Minus {
                    i64::MIN
                } else {
                    i64::MAX
                }
            }),
            Value::Bool(v) => {
                if *v {
                    1
                } else {
                    0
                }
            }
            Value::String(v) => v
                .parse::<i64>()
                .ok()
                .or_else(|| v.parse::<f64>().ok().map(|n| n as i64))
                .unwrap_or(0),
            Value::Array(values) => Value::Array(values.clone())
                .as_string()
                .parse::<i64>()
                .ok()
                .or_else(|| {
                    Value::Array(values.clone())
                        .as_string()
                        .parse::<f64>()
                        .ok()
                        .map(|n| n as i64)
                })
                .unwrap_or(0),
            Value::Date(value) => *value.borrow(),
            Value::Object(_) => 0,
            Value::Promise(_) => 0,
            Value::Map(_) => 0,
            Value::Set(_) => 0,
            Value::ArrayBuffer(_) => 0,
            Value::TypedArray(_) => 0,
            Value::StringConstructor => 0,
            Value::TypedArrayConstructor(_) => 0,
            Value::ArrayBufferConstructor => 0,
            Value::PromiseConstructor => 0,
            Value::MapConstructor => 0,
            Value::SetConstructor => 0,
            Value::SymbolConstructor => 0,
            Value::RegExpConstructor => 0,
            Value::PromiseCapability(_) => 0,
            Value::Symbol(_) => 0,
            Value::RegExp(_) => 0,
            Value::Node(_) => 0,
            Value::NodeList(_) => 0,
            Value::FormData(_) => 0,
            Value::Function(_) => 0,
            Value::Null => 0,
            Value::Undefined => 0,
        }
    }

    fn next_random_f64(&mut self) -> f64 {
        // xorshift64*: simple deterministic PRNG for test runtime.
        let mut x = self.rng_state;
        x ^= x >> 12;
        x ^= x << 25;
        x ^= x >> 27;
        self.rng_state = if x == 0 { 0xA5A5_A5A5_A5A5_A5A5 } else { x };
        let out = x.wrapping_mul(0x2545_F491_4F6C_DD1D);
        // Convert top 53 bits to [0.0, 1.0).
        let mantissa = out >> 11;
        (mantissa as f64) * (1.0 / ((1u64 << 53) as f64))
    }

    fn schedule_timeout(
        &mut self,
        callback: TimerCallback,
        delay_ms: i64,
        callback_args: Vec<Value>,
        env: &HashMap<String, Value>,
    ) -> i64 {
        let delay_ms = delay_ms.max(0);
        let due_at = self.now_ms + delay_ms;
        let id = self.next_timer_id;
        self.next_timer_id += 1;
        let order = self.next_task_order;
        self.next_task_order += 1;
        self.task_queue.push(ScheduledTask {
            id,
            due_at,
            order,
            interval_ms: None,
            callback,
            callback_args,
            env: env.clone(),
        });
        self.trace_timer_line(format!(
            "[timer] schedule timeout id={} due_at={} delay_ms={}",
            id, due_at, delay_ms
        ));
        id
    }

    fn schedule_interval(
        &mut self,
        callback: TimerCallback,
        interval_ms: i64,
        callback_args: Vec<Value>,
        env: &HashMap<String, Value>,
    ) -> i64 {
        let interval_ms = interval_ms.max(0);
        let due_at = self.now_ms + interval_ms;
        let id = self.next_timer_id;
        self.next_timer_id += 1;
        let order = self.next_task_order;
        self.next_task_order += 1;
        self.task_queue.push(ScheduledTask {
            id,
            due_at,
            order,
            interval_ms: Some(interval_ms),
            callback,
            callback_args,
            env: env.clone(),
        });
        self.trace_timer_line(format!(
            "[timer] schedule interval id={} due_at={} interval_ms={}",
            id, due_at, interval_ms
        ));
        id
    }

    fn clear_timeout(&mut self, id: i64) {
        let before = self.task_queue.len();
        self.task_queue.retain(|task| task.id != id);
        let removed = before.saturating_sub(self.task_queue.len());
        let mut running_canceled = false;
        if self.running_timer_id == Some(id) {
            self.running_timer_canceled = true;
            running_canceled = true;
        }
        self.trace_timer_line(format!(
            "[timer] clear id={} removed={} running_canceled={}",
            id, removed, running_canceled
        ));
    }

    fn compile_and_register_script(&mut self, script: &str) -> Result<()> {
        let stmts = parse_block_statements(script)?;
        let mut event = EventState::new("script", self.dom.root, self.now_ms);
        let mut env = self.script_env.clone();
        self.run_in_task_context(|this| {
            this.execute_stmts(&stmts, &None, &mut event, &mut env)
                .map(|_| ())
        })?;
        self.script_env = env;

        Ok(())
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum ListenerRegistrationOp {
    Add,
    Remove,
}

fn append_dom_query_member_path(target: &DomQuery, member: &str) -> Option<DomQuery> {
    match target {
        DomQuery::Var(base) => Some(DomQuery::VarPath {
            base: base.clone(),
            path: vec![member.to_string()],
        }),
        DomQuery::VarPath { base, path } => {
            let mut next_path = path.clone();
            next_path.push(member.to_string());
            Some(DomQuery::VarPath {
                base: base.clone(),
                path: next_path,
            })
        }
        _ => None,
    }
}

fn is_dom_target_chain_stop(ident: &str) -> bool {
    matches!(
        ident,
        "activeElement"
            | "addEventListener"
            | "after"
            | "append"
            | "appendChild"
            | "before"
            | "blur"
            | "checked"
            | "classList"
            | "className"
            | "click"
            | "close"
            | "closest"
            | "closedBy"
            | "closedby"
            | "dataset"
            | "disabled"
            | "dispatchEvent"
            | "elements"
            | "focus"
            | "forEach"
            | "getAttribute"
            | "hasAttribute"
            | "id"
            | "innerHTML"
            | "insertAdjacentElement"
            | "insertAdjacentHTML"
            | "insertAdjacentText"
            | "insertBefore"
            | "length"
            | "matches"
            | "name"
            | "offsetHeight"
            | "offsetLeft"
            | "offsetTop"
            | "offsetWidth"
            | "open"
            | "querySelector"
            | "querySelectorAll"
            | "prepend"
            | "readOnly"
            | "readonly"
            | "remove"
            | "removeAttribute"
            | "removeChild"
            | "removeEventListener"
            | "requestClose"
            | "returnValue"
            | "replaceWith"
            | "required"
            | "reset"
            | "scrollHeight"
            | "scrollIntoView"
            | "scrollLeft"
            | "scrollTop"
            | "scrollWidth"
            | "setAttribute"
            | "show"
            | "showModal"
            | "style"
            | "submit"
            | "textContent"
            | "value"
    )
}

fn parse_element_target(cursor: &mut Cursor<'_>) -> Result<DomQuery> {
    cursor.skip_ws();
    let start = cursor.pos();
    let mut target = if let Ok(target) = parse_form_elements_item_target(cursor) {
        target
    } else {
        cursor.set_pos(start);
        parse_document_or_var_target(cursor)?
    };

    loop {
        cursor.skip_ws();
        let dot_pos = cursor.pos();
        if !cursor.consume_byte(b'.') {
            break;
        }

        cursor.skip_ws();
        let method = match cursor.parse_identifier() {
            Some(method) => method,
            None => {
                cursor.set_pos(dot_pos);
                break;
            }
        };

        match method.as_str() {
            "body" if matches!(target, DomQuery::DocumentRoot) => {
                target = DomQuery::DocumentBody;
            }
            "head" if matches!(target, DomQuery::DocumentRoot) => {
                target = DomQuery::DocumentHead;
            }
            "documentElement" if matches!(target, DomQuery::DocumentRoot) => {
                target = DomQuery::DocumentElement;
            }
            "querySelector" => {
                cursor.skip_ws();
                if cursor.peek() != Some(b'(') {
                    cursor.set_pos(dot_pos);
                    break;
                }
                cursor.expect_byte(b'(')?;
                cursor.skip_ws();
                let selector = cursor.parse_string_literal()?;
                cursor.skip_ws();
                cursor.expect_byte(b')')?;
                cursor.skip_ws();
                target = DomQuery::QuerySelector {
                    target: Box::new(target),
                    selector,
                };
            }
            "querySelectorAll" => {
                cursor.skip_ws();
                if cursor.peek() != Some(b'(') {
                    cursor.set_pos(dot_pos);
                    break;
                }
                cursor.expect_byte(b'(')?;
                cursor.skip_ws();
                let selector = cursor.parse_string_literal()?;
                cursor.skip_ws();
                cursor.expect_byte(b')')?;
                cursor.skip_ws();
                target = DomQuery::QuerySelectorAll {
                    target: Box::new(target),
                    selector,
                };
            }
            _ => {
                if is_dom_target_chain_stop(&method) {
                    cursor.set_pos(dot_pos);
                    break;
                }
                if let Some(next_target) = append_dom_query_member_path(&target, &method) {
                    target = next_target;
                    continue;
                }
                cursor.set_pos(dot_pos);
                break;
            }
        }
    }

    loop {
        cursor.skip_ws();
        let index_pos = cursor.pos();
        if !cursor.consume_byte(b'[') {
            break;
        }

        cursor.skip_ws();
        let index_src = match cursor.read_until_byte(b']') {
            Ok(index_src) => index_src,
            Err(_) => {
                cursor.set_pos(index_pos);
                break;
            }
        };
        cursor.skip_ws();
        cursor.expect_byte(b']')?;
        let index = parse_dom_query_index(&index_src)?;
        target = match target {
            DomQuery::BySelectorAll { selector } => {
                DomQuery::BySelectorAllIndex { selector, index }
            }
            DomQuery::QuerySelectorAll { target, selector } => DomQuery::QuerySelectorAllIndex {
                target,
                selector,
                index,
            },
            _ => DomQuery::Index {
                target: Box::new(target),
                index,
            },
        };
        cursor.skip_ws();
    }
    Ok(target)
}

fn parse_document_or_var_target(cursor: &mut Cursor<'_>) -> Result<DomQuery> {
    let start = cursor.pos();
    if let Ok(target) = parse_document_element_call(cursor) {
        return Ok(target);
    }
    cursor.set_pos(start);
    if cursor.consume_ascii("document") {
        return Ok(DomQuery::DocumentRoot);
    }
    cursor.set_pos(start);
    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if cursor.consume_byte(b'.') {
            cursor.skip_ws();
            if cursor.consume_ascii("document") {
                cursor.skip_ws();
            } else {
                cursor.set_pos(start + "window".len());
            }
        }
        return Ok(DomQuery::DocumentRoot);
    }
    cursor.set_pos(start);
    if let Some(name) = cursor.parse_identifier() {
        return Ok(DomQuery::Var(name));
    }
    Err(Error::ScriptParse(format!(
        "expected element target at {}",
        start
    )))
}

fn parse_form_elements_item_target(cursor: &mut Cursor<'_>) -> Result<DomQuery> {
    let form = parse_form_elements_base(cursor)?;
    cursor.skip_ws();
    cursor.expect_byte(b'.')?;
    cursor.skip_ws();
    cursor.expect_ascii("elements")?;
    cursor.skip_ws();
    cursor.expect_byte(b'[')?;
    cursor.skip_ws();
    let index_src = cursor.read_until_byte(b']')?;
    cursor.skip_ws();
    cursor.expect_byte(b']')?;
    let index = parse_dom_query_index(&index_src)?;
    Ok(DomQuery::FormElementsIndex {
        form: Box::new(form),
        index,
    })
}

fn parse_dom_query_index(src: &str) -> Result<DomIndex> {
    let src = strip_js_comments(src).trim().to_string();
    if src.is_empty() {
        return Err(Error::ScriptParse("empty index".into()));
    }

    let expr = parse_expr(&src)?;
    if let Expr::Number(index) = expr {
        return usize::try_from(index)
            .map(DomIndex::Static)
            .map_err(|_| Error::ScriptParse(format!("invalid index: {src}")));
    }

    Ok(DomIndex::Dynamic(src))
}

fn parse_form_elements_base(cursor: &mut Cursor<'_>) -> Result<DomQuery> {
    let start = cursor.pos();
    if let Ok(target) = parse_document_element_call(cursor) {
        return Ok(target);
    }
    cursor.set_pos(start);
    if let Some(name) = cursor.parse_identifier() {
        return Ok(DomQuery::Var(name));
    }
    Err(Error::ScriptParse(format!(
        "expected form target at {}",
        start
    )))
}

fn parse_document_element_call(cursor: &mut Cursor<'_>) -> Result<DomQuery> {
    cursor.skip_ws();
    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        cursor.expect_byte(b'.')?;
        cursor.skip_ws();
    }
    cursor.expect_ascii("document")?;
    cursor.skip_ws();
    cursor.expect_byte(b'.')?;
    cursor.skip_ws();
    let method = cursor
        .parse_identifier()
        .ok_or_else(|| Error::ScriptParse("expected document method call".into()))?;
    cursor.skip_ws();
    cursor.expect_byte(b'(')?;
    cursor.skip_ws();
    let arg = cursor.parse_string_literal()?;
    cursor.skip_ws();
    cursor.expect_byte(b')')?;
    cursor.skip_ws();

    match method.as_str() {
        "getElementById" => Ok(DomQuery::ById(arg)),
        "querySelector" => Ok(DomQuery::BySelector(arg)),
        "querySelectorAll" => Ok(DomQuery::BySelectorAll { selector: arg }),
        "getElementsByTagName" => Ok(DomQuery::BySelectorAll {
            selector: normalize_get_elements_by_tag_name(&arg)?,
        }),
        "getElementsByClassName" => Ok(DomQuery::BySelectorAll {
            selector: normalize_get_elements_by_class_name(&arg)?,
        }),
        "getElementsByName" => Ok(DomQuery::BySelectorAll {
            selector: normalize_get_elements_by_name(&arg)?,
        }),
        _ => Err(Error::ScriptParse(format!(
            "unsupported document method: {}",
            method
        ))),
    }
}

fn normalize_get_elements_by_tag_name(tag_name: &str) -> Result<String> {
    let tag_name = tag_name.trim();
    if tag_name.is_empty() {
        return Err(Error::ScriptParse(
            "getElementsByTagName requires a tag name".into(),
        ));
    }
    if tag_name == "*" {
        return Ok("*".into());
    }
    Ok(tag_name.to_ascii_lowercase())
}

fn normalize_get_elements_by_class_name(class_names: &str) -> Result<String> {
    let mut selector = String::new();
    let classes: Vec<&str> = class_names
        .split_whitespace()
        .map(str::trim)
        .filter(|class_name| !class_name.is_empty())
        .collect();

    if classes.is_empty() {
        return Err(Error::ScriptParse(
            "getElementsByClassName requires at least one class name".into(),
        ));
    }

    for class_name in classes {
        selector.push('.');
        selector.push_str(class_name);
    }
    Ok(selector)
}

fn normalize_get_elements_by_name(name: &str) -> Result<String> {
    let name = name.trim();
    if name.is_empty() {
        return Err(Error::ScriptParse(
            "getElementsByName requires a name value".into(),
        ));
    }
    let escaped = name.replace('\\', "\\\\").replace('\'', "\\'");
    Ok(format!("[name='{}']", escaped))
}

fn parse_callback_parameter_list(
    src: &str,
    max_params: usize,
    label: &str,
) -> Result<Vec<FunctionParam>> {
    let parts = split_top_level_by_char(src.trim(), b',');
    if parts.len() == 1 && parts[0].trim().is_empty() {
        return Ok(Vec::new());
    }

    if parts.len() > max_params {
        return Err(Error::ScriptParse(format!("unsupported {label}: {src}")));
    }

    let mut params = Vec::new();
    for raw in parts {
        let param = raw.trim();
        if param.is_empty() {
            return Err(Error::ScriptParse(format!("unsupported {label}: {src}")));
        }

        if let Some((eq_pos, op_len)) = find_top_level_assignment(param) {
            if op_len != 1 {
                return Err(Error::ScriptParse(format!("unsupported {label}: {src}")));
            }
            let name = param[..eq_pos].trim();
            let default_src = param[eq_pos + op_len..].trim();
            if !is_ident(name) || default_src.is_empty() {
                return Err(Error::ScriptParse(format!("unsupported {label}: {src}")));
            }
            params.push(FunctionParam {
                name: name.to_string(),
                default: Some(parse_expr(default_src)?),
            });
            continue;
        }

        if !is_ident(param) {
            return Err(Error::ScriptParse(format!("unsupported {label}: {src}")));
        }
        params.push(FunctionParam {
            name: param.to_string(),
            default: None,
        });
    }

    Ok(params)
}

fn parse_arrow_or_block_body(cursor: &mut Cursor<'_>) -> Result<(String, bool)> {
    cursor.skip_ws();
    if cursor.peek() == Some(b'{') {
        return Ok((cursor.read_balanced_block(b'{', b'}')?, false));
    }

    let src = cursor
        .src
        .get(cursor.i..)
        .ok_or_else(|| Error::ScriptParse("expected callback body".into()))?;
    let mut end = src.len();

    while end > 0 {
        let raw = src
            .get(0..end)
            .ok_or_else(|| Error::ScriptParse("invalid callback body".into()))?;
        let expr_src = raw.trim();
        if expr_src.is_empty() {
            break;
        }

        let stripped = strip_js_comments(expr_src);
        let stripped = stripped.trim();
        if !stripped.is_empty() {
            if parse_expr(stripped).is_ok() {
                cursor.set_pos(cursor.i + expr_src.len());
                return Ok((stripped.to_string(), true));
            }
        }

        end -= 1;
    }

    Err(Error::ScriptParse("expected callback body".into()))
}

fn try_consume_async_function_prefix(cursor: &mut Cursor<'_>) -> bool {
    let start = cursor.pos();
    if !cursor.consume_ascii("async") {
        return false;
    }
    if cursor.peek().is_some_and(is_ident_char) {
        cursor.set_pos(start);
        return false;
    }

    let mut saw_separator = false;
    let mut saw_line_terminator = false;
    while let Some(b) = cursor.peek() {
        if b == b' ' || b == b'\t' || b == 0x0B || b == 0x0C {
            saw_separator = true;
            cursor.set_pos(cursor.pos() + 1);
            continue;
        }
        if b == b'\n' || b == b'\r' {
            saw_separator = true;
            saw_line_terminator = true;
            cursor.set_pos(cursor.pos() + 1);
            continue;
        }
        break;
    }

    if !saw_separator || saw_line_terminator {
        cursor.set_pos(start);
        return false;
    }

    let function_pos = cursor.pos();
    if cursor
        .src
        .get(function_pos..)
        .is_some_and(|rest| rest.starts_with("function"))
        && !cursor
            .bytes()
            .get(function_pos + "function".len())
            .is_some_and(|&b| is_ident_char(b))
    {
        true
    } else {
        cursor.set_pos(start);
        false
    }
}

fn parse_function_expr(src: &str) -> Result<Option<Expr>> {
    let src = src.trim();
    {
        let mut cursor = Cursor::new(src);
        cursor.skip_ws();
        if try_consume_async_function_prefix(&mut cursor) {
            let (params, body, concise_body) =
                parse_callback(&mut cursor, usize::MAX, "function parameters")?;
            cursor.skip_ws();
            if !cursor.eof() {
                return Ok(None);
            }
            let stmts = if concise_body {
                vec![Stmt::Return {
                    value: Some(parse_expr(body.trim())?),
                }]
            } else {
                parse_block_statements(&body)?
            };
            return Ok(Some(Expr::Function {
                handler: ScriptHandler { params, stmts },
                is_async: true,
            }));
        }
    }

    if !src.starts_with("function") && !src.contains("=>") {
        return Ok(None);
    }

    let mut cursor = Cursor::new(src);
    let parsed = match parse_callback(&mut cursor, usize::MAX, "function parameters") {
        Ok(parsed) => parsed,
        Err(err) => {
            if src.starts_with("function") {
                return Err(err);
            }
            return Ok(None);
        }
    };

    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }

    let (params, body, concise_body) = parsed;
    let stmts = if concise_body {
        vec![Stmt::Return {
            value: Some(parse_expr(body.trim())?),
        }]
    } else {
        parse_block_statements(&body)?
    };
    Ok(Some(Expr::Function {
        handler: ScriptHandler { params, stmts },
        is_async: false,
    }))
}

fn parse_callback(
    cursor: &mut Cursor<'_>,
    max_params: usize,
    label: &str,
) -> Result<(Vec<FunctionParam>, String, bool)> {
    cursor.skip_ws();

    let params = if cursor
        .src
        .get(cursor.i..)
        .is_some_and(|src| src.starts_with("function"))
        && !cursor
            .bytes()
            .get(cursor.i + "function".len())
            .is_some_and(|&b| is_ident_char(b))
    {
        cursor.consume_ascii("function");
        cursor.skip_ws();

        if !cursor.consume_byte(b'(') {
            let _ = cursor
                .parse_identifier()
                .ok_or_else(|| Error::ScriptParse("expected function name".into()))?;
            cursor.skip_ws();
            cursor.expect_byte(b'(')?;
        }

        let params = cursor.read_until_byte(b')')?;
        cursor.expect_byte(b')')?;
        let params = parse_callback_parameter_list(&params, max_params, label)?;
        cursor.skip_ws();
        let body = cursor.read_balanced_block(b'{', b'}')?;
        return Ok((params, body, false));
    } else if cursor.consume_byte(b'(') {
        let params = cursor.read_until_byte(b')')?;
        cursor.expect_byte(b')')?;
        let params = parse_callback_parameter_list(&params, max_params, label)?;
        params
    } else {
        let ident = cursor
            .parse_identifier()
            .ok_or_else(|| Error::ScriptParse("expected callback parameter or ()".into()))?;
        vec![FunctionParam {
            name: ident,
            default: None,
        }]
    };

    cursor.skip_ws();
    cursor.expect_ascii("=>")?;
    let (body, concise_body) = parse_arrow_or_block_body(cursor)?;
    Ok((params, body, concise_body))
}

fn parse_timer_callback(timer_name: &str, src: &str) -> Result<TimerCallback> {
    let mut cursor = Cursor::new(src);
    if let Ok((params, body, _)) =
        parse_callback(&mut cursor, usize::MAX, "timer callback parameters")
    {
        cursor.skip_ws();
        if cursor.eof() {
            return Ok(TimerCallback::Inline(ScriptHandler {
                params,
                stmts: parse_block_statements(&body)?,
            }));
        }
    }

    match parse_expr(src)? {
        Expr::Function { handler, .. } => Ok(TimerCallback::Inline(handler)),
        Expr::Var(name) => Ok(TimerCallback::Reference(name)),
        _ => Err(Error::ScriptParse(format!(
            "unsupported {timer_name} callback: {src}"
        ))),
    }
}

fn parse_block_statements(body: &str) -> Result<Vec<Stmt>> {
    let sanitized = strip_js_comments(body);
    let raw_stmts = split_top_level_statements(sanitized.as_str());
    let mut stmts = Vec::new();

    for raw in raw_stmts {
        let stmt = raw.trim();
        if stmt.is_empty() {
            continue;
        }

        if let Some(else_branch) = parse_else_fragment(stmt)? {
            if let Some(Stmt::If { else_stmts, .. }) = stmts.last_mut() {
                if else_stmts.is_empty() {
                    *else_stmts = else_branch;
                    continue;
                }
                return Err(Error::ScriptParse(format!(
                    "duplicate else branch in: {stmt}"
                )));
            }
            return Err(Error::ScriptParse(format!(
                "unexpected else without matching if: {stmt}"
            )));
        }

        let parsed = parse_single_statement(stmt)?;
        stmts.push(parsed);
    }

    Ok(stmts)
}

fn parse_single_statement(stmt: &str) -> Result<Stmt> {
    let stmt = stmt.trim();

    if let Some(parsed) = parse_if_stmt(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_do_while_stmt(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_while_stmt(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_for_stmt(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_try_stmt(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_return_stmt(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_throw_stmt(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_break_stmt(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_continue_stmt(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_query_selector_all_foreach_stmt(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_array_for_each_stmt(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_function_decl_stmt(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_var_decl(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_destructure_assign(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_var_assign(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_update_stmt(stmt) {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_form_data_append_stmt(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_dom_method_call_stmt(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_dom_assignment(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_object_assign(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_set_attribute_stmt(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_remove_attribute_stmt(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_class_list_stmt(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_insert_adjacent_element_stmt(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_insert_adjacent_text_stmt(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_insert_adjacent_html_stmt(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_set_timeout_stmt(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_set_interval_stmt(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_queue_microtask_stmt(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_clear_timeout_stmt(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_node_tree_mutation_stmt(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_node_remove_stmt(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_listener_mutation_stmt(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_dispatch_event_stmt(stmt)? {
        return Ok(parsed);
    }

    if let Some(parsed) = parse_event_call_stmt(stmt) {
        return Ok(parsed);
    }

    let expr = parse_expr(stmt)?;
    Ok(Stmt::Expr(expr))
}

fn parse_else_fragment(stmt: &str) -> Result<Option<Vec<Stmt>>> {
    let trimmed = stmt.trim_start();
    let Some(rest) = strip_else_prefix(trimmed) else {
        return Ok(None);
    };
    let branch = parse_if_branch(rest.trim())?;
    Ok(Some(branch))
}

fn strip_else_prefix(src: &str) -> Option<&str> {
    if !src.starts_with("else") {
        return None;
    }
    let bytes = src.as_bytes();
    let after = 4;
    if after < bytes.len() && is_ident_char(bytes[after]) {
        return None;
    }
    Some(&src[after..])
}

fn parse_if_branch(src: &str) -> Result<Vec<Stmt>> {
    let src = src.trim();
    if src.is_empty() {
        return Err(Error::ScriptParse("empty if branch".into()));
    }

    if src.starts_with('{') {
        let mut cursor = Cursor::new(src);
        let body = cursor.read_balanced_block(b'{', b'}')?;
        cursor.skip_ws();
        cursor.consume_byte(b';');
        cursor.skip_ws();
        if !cursor.eof() {
            return Err(Error::ScriptParse(format!(
                "unsupported trailing tokens in branch: {src}"
            )));
        }
        return parse_block_statements(&body);
    }

    let single = trim_optional_trailing_semicolon(src);
    if single.is_empty() {
        return Err(Error::ScriptParse("empty single statement branch".into()));
    }
    Ok(vec![parse_single_statement(single)?])
}

fn trim_optional_trailing_semicolon(src: &str) -> &str {
    let mut trimmed = src.trim_end();
    if let Some(without) = trimmed.strip_suffix(';') {
        trimmed = without.trim_end();
    }
    trimmed
}

fn find_top_level_else_keyword(src: &str) -> Option<usize> {
    let bytes = src.as_bytes();
    let mut i = 0usize;

    let mut paren = 0usize;
    let mut bracket = 0usize;
    let mut brace = 0usize;

    #[derive(Clone, Copy, PartialEq, Eq)]
    enum StrState {
        None,
        Single,
        Double,
        Backtick,
    }
    let mut state = StrState::None;

    while i < bytes.len() {
        let b = bytes[i];
        match state {
            StrState::None => match b {
                b'\'' => state = StrState::Single,
                b'"' => state = StrState::Double,
                b'`' => state = StrState::Backtick,
                b'(' => paren += 1,
                b')' => paren = paren.saturating_sub(1),
                b'[' => bracket += 1,
                b']' => bracket = bracket.saturating_sub(1),
                b'{' => brace += 1,
                b'}' => brace = brace.saturating_sub(1),
                b'e' if paren == 0 && bracket == 0 && brace == 0 => {
                    if i + 4 <= bytes.len()
                        && &bytes[i..i + 4] == b"else"
                        && (i == 0 || !is_ident_char(bytes[i - 1]))
                        && (i + 4 == bytes.len() || !is_ident_char(bytes[i + 4]))
                    {
                        return Some(i);
                    }
                }
                _ => {}
            },
            StrState::Single => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'\'' {
                    state = StrState::None;
                }
            }
            StrState::Double => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'"' {
                    state = StrState::None;
                }
            }
            StrState::Backtick => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'`' {
                    state = StrState::None;
                }
            }
        }
        i += 1;
    }

    None
}

fn is_ident_char(b: u8) -> bool {
    b == b'_' || b == b'$' || b.is_ascii_alphanumeric()
}

fn parse_if_stmt(stmt: &str) -> Result<Option<Stmt>> {
    let mut cursor = Cursor::new(stmt);
    cursor.skip_ws();

    if !cursor.consume_ascii("if") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }

    cursor.skip_ws();
    let cond_src = cursor.read_balanced_block(b'(', b')')?;
    let cond = parse_expr(cond_src.trim())?;

    let tail = cursor.src[cursor.i..].trim();
    if tail.is_empty() {
        return Err(Error::ScriptParse(format!(
            "if statement has no branch: {stmt}"
        )));
    }

    let (then_raw, else_raw) = if tail.starts_with('{') {
        let mut branch_cursor = Cursor::new(tail);
        let _ = branch_cursor.read_balanced_block(b'{', b'}')?;
        let split = branch_cursor.pos();
        let then_raw = tail
            .get(..split)
            .ok_or_else(|| Error::ScriptParse("invalid if branch slice".into()))?;
        let rest = tail
            .get(split..)
            .ok_or_else(|| Error::ScriptParse("invalid if remainder slice".into()))?
            .trim();

        if rest.is_empty() {
            (then_raw, None)
        } else if let Some(after_else) = strip_else_prefix(rest) {
            (then_raw, Some(after_else))
        } else {
            return Err(Error::ScriptParse(format!(
                "unsupported tokens after if block: {rest}"
            )));
        }
    } else {
        if let Some(pos) = find_top_level_else_keyword(tail) {
            let then_raw = tail
                .get(..pos)
                .ok_or_else(|| Error::ScriptParse("invalid then branch".into()))?;
            let else_raw = tail
                .get(pos + 4..)
                .ok_or_else(|| Error::ScriptParse("invalid else branch".into()))?;
            (then_raw, Some(else_raw))
        } else {
            (tail, None)
        }
    };

    let then_stmts = parse_if_branch(then_raw)?;
    let else_stmts = if let Some(raw) = else_raw {
        parse_if_branch(raw)?
    } else {
        Vec::new()
    };

    Ok(Some(Stmt::If {
        cond,
        then_stmts,
        else_stmts,
    }))
}

fn parse_while_stmt(stmt: &str) -> Result<Option<Stmt>> {
    let mut cursor = Cursor::new(stmt);
    cursor.skip_ws();

    if !cursor.consume_ascii("while") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }

    cursor.skip_ws();
    let cond_src = cursor.read_balanced_block(b'(', b')')?;
    let cond = parse_expr(cond_src.trim())?;

    cursor.skip_ws();
    let body_src = cursor.read_balanced_block(b'{', b'}')?;
    let body = parse_block_statements(&body_src)?;

    cursor.skip_ws();
    cursor.consume_byte(b';');
    cursor.skip_ws();
    if !cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "unsupported while statement tail: {stmt}"
        )));
    }

    Ok(Some(Stmt::While { cond, body }))
}

fn parse_do_while_stmt(stmt: &str) -> Result<Option<Stmt>> {
    let mut cursor = Cursor::new(stmt);
    cursor.skip_ws();

    if !cursor.consume_ascii("do") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }

    cursor.skip_ws();
    let body_src = cursor.read_balanced_block(b'{', b'}')?;
    let body = parse_block_statements(&body_src)?;

    cursor.skip_ws();
    if !cursor.consume_ascii("while") {
        return Err(Error::ScriptParse(format!(
            "unsupported do statement: {stmt}"
        )));
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Err(Error::ScriptParse(format!(
                "unsupported do statement: {stmt}"
            )));
        }
    }

    cursor.skip_ws();
    let cond_src = cursor.read_balanced_block(b'(', b')')?;
    let cond = parse_expr(cond_src.trim())?;

    cursor.skip_ws();
    cursor.consume_byte(b';');
    cursor.skip_ws();
    if !cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "unsupported do while statement tail: {stmt}"
        )));
    }

    Ok(Some(Stmt::DoWhile { cond, body }))
}

fn consume_keyword(cursor: &mut Cursor<'_>, keyword: &str) -> bool {
    let start = cursor.pos();
    if !cursor.consume_ascii(keyword) {
        return false;
    }
    if cursor.peek().is_some_and(is_ident_char) {
        cursor.set_pos(start);
        return false;
    }
    true
}

fn parse_catch_binding(src: &str) -> Result<CatchBinding> {
    let src = src.trim();
    if src.is_empty() {
        return Err(Error::ScriptParse("catch binding cannot be empty".into()));
    }
    if is_ident(src) {
        return Ok(CatchBinding::Identifier(src.to_string()));
    }
    if src.starts_with('[') && src.ends_with(']') {
        let pattern = parse_array_destructure_pattern(src)?;
        return Ok(CatchBinding::ArrayPattern(pattern));
    }
    if src.starts_with('{') && src.ends_with('}') {
        let pattern = parse_object_destructure_pattern(src)?;
        return Ok(CatchBinding::ObjectPattern(pattern));
    }
    Err(Error::ScriptParse(format!(
        "unsupported catch binding pattern: {src}"
    )))
}

fn parse_try_stmt(stmt: &str) -> Result<Option<Stmt>> {
    let mut cursor = Cursor::new(stmt);
    cursor.skip_ws();
    if !consume_keyword(&mut cursor, "try") {
        return Ok(None);
    }

    cursor.skip_ws();
    let try_src = cursor.read_balanced_block(b'{', b'}')?;
    let try_stmts = parse_block_statements(&try_src)?;

    cursor.skip_ws();
    let mut catch_binding = None;
    let mut catch_stmts = None;
    let mut finally_stmts = None;

    if consume_keyword(&mut cursor, "catch") {
        cursor.skip_ws();
        if cursor.peek() == Some(b'(') {
            let binding_src = cursor.read_balanced_block(b'(', b')')?;
            catch_binding = Some(parse_catch_binding(binding_src.trim())?);
            cursor.skip_ws();
        }
        let catch_src = cursor.read_balanced_block(b'{', b'}')?;
        catch_stmts = Some(parse_block_statements(&catch_src)?);
        cursor.skip_ws();
    }

    if consume_keyword(&mut cursor, "finally") {
        cursor.skip_ws();
        let finally_src = cursor.read_balanced_block(b'{', b'}')?;
        finally_stmts = Some(parse_block_statements(&finally_src)?);
        cursor.skip_ws();
    }

    if catch_stmts.is_none() && finally_stmts.is_none() {
        return Err(Error::ScriptParse(format!(
            "try statement requires catch or finally: {stmt}"
        )));
    }

    cursor.consume_byte(b';');
    cursor.skip_ws();
    if !cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "unsupported try statement tail: {stmt}"
        )));
    }

    Ok(Some(Stmt::Try {
        try_stmts,
        catch_binding,
        catch_stmts,
        finally_stmts,
    }))
}

fn parse_throw_stmt(stmt: &str) -> Result<Option<Stmt>> {
    let mut cursor = Cursor::new(stmt);
    cursor.skip_ws();
    if !consume_keyword(&mut cursor, "throw") {
        return Ok(None);
    }

    cursor.skip_ws();
    if cursor.eof() {
        return Err(Error::ScriptParse(
            "throw statement requires an operand".into(),
        ));
    }

    let expr_src = cursor.src.get(cursor.i..).unwrap_or_default().trim();
    let expr_src = expr_src.strip_suffix(';').unwrap_or(expr_src).trim();
    if expr_src.is_empty() {
        return Err(Error::ScriptParse(
            "throw statement requires an operand".into(),
        ));
    }
    let value = parse_expr(expr_src)?;
    Ok(Some(Stmt::Throw { value }))
}

fn parse_return_stmt(stmt: &str) -> Result<Option<Stmt>> {
    let mut cursor = Cursor::new(stmt);
    cursor.skip_ws();
    if !cursor.consume_ascii("return") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }

    cursor.skip_ws();
    if cursor.eof() {
        return Ok(Some(Stmt::Return { value: None }));
    }

    let expr_src = cursor.src.get(cursor.i..).unwrap_or_default().trim();
    let expr_src = expr_src.strip_suffix(';').unwrap_or(expr_src).trim();
    if expr_src.is_empty() {
        return Ok(Some(Stmt::Return { value: None }));
    }
    let value = parse_expr(expr_src)?;
    Ok(Some(Stmt::Return { value: Some(value) }))
}

fn parse_break_stmt(stmt: &str) -> Result<Option<Stmt>> {
    let mut cursor = Cursor::new(stmt);
    cursor.skip_ws();
    if !cursor.consume_ascii("break") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();
    cursor.consume_byte(b';');
    cursor.skip_ws();
    if !cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "unsupported break statement: {stmt}"
        )));
    }
    Ok(Some(Stmt::Break))
}

fn parse_continue_stmt(stmt: &str) -> Result<Option<Stmt>> {
    let mut cursor = Cursor::new(stmt);
    cursor.skip_ws();
    if !cursor.consume_ascii("continue") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();
    cursor.consume_byte(b';');
    cursor.skip_ws();
    if !cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "unsupported continue statement: {stmt}"
        )));
    }
    Ok(Some(Stmt::Continue))
}

fn parse_for_stmt(stmt: &str) -> Result<Option<Stmt>> {
    let mut cursor = Cursor::new(stmt);
    cursor.skip_ws();

    if !cursor.consume_ascii("for") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }

    cursor.skip_ws();
    let header_src = cursor.read_balanced_block(b'(', b')')?;
    if let Some((kind, item_var, iterable_src)) = parse_for_in_of_stmt(&header_src)? {
        let iterable = parse_expr(iterable_src.trim())?;
        cursor.skip_ws();
        let body_src = cursor.read_balanced_block(b'{', b'}')?;
        let body = parse_block_statements(&body_src)?;

        cursor.skip_ws();
        cursor.consume_byte(b';');
        cursor.skip_ws();
        if !cursor.eof() {
            return Err(Error::ScriptParse(format!(
                "unsupported for statement tail: {stmt}"
            )));
        }

        let stmt = match kind {
            ForInOfKind::In => Stmt::ForIn {
                item_var,
                iterable,
                body,
            },
            ForInOfKind::Of => Stmt::ForOf {
                item_var,
                iterable,
                body,
            },
        };
        return Ok(Some(stmt));
    }

    let header_parts = split_top_level_by_char(header_src.trim(), b';');
    if header_parts.len() != 3 {
        return Err(Error::ScriptParse(format!(
            "unsupported for statement: {stmt}"
        )));
    }

    let init = parse_for_clause_stmt(header_parts[0])?;
    let cond = if header_parts[1].trim().is_empty() {
        None
    } else {
        Some(parse_expr(header_parts[1].trim())?)
    };
    let post = parse_for_clause_stmt(header_parts[2])?;

    cursor.skip_ws();
    let body_src = cursor.read_balanced_block(b'{', b'}')?;
    let body = parse_block_statements(&body_src)?;

    cursor.skip_ws();
    cursor.consume_byte(b';');
    cursor.skip_ws();
    if !cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "unsupported for statement tail: {stmt}"
        )));
    }

    Ok(Some(Stmt::For {
        init,
        cond,
        post,
        body,
    }))
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum ForInOfKind {
    In,
    Of,
}

fn parse_for_in_of_stmt(header: &str) -> Result<Option<(ForInOfKind, String, &str)>> {
    let header = header.trim();
    if header.is_empty() {
        return Ok(None);
    }

    let mut found = None;
    for (kind, keyword) in [(ForInOfKind::In, "in"), (ForInOfKind::Of, "of")] {
        if let Some(pos) = find_top_level_in_of_keyword(header, keyword)? {
            found = Some((kind, pos, keyword));
            break;
        }
    }

    let Some((kind, pos, keyword)) = found else {
        return Ok(None);
    };

    let left = header[..pos].trim();
    let right = header[pos + keyword.len()..].trim();
    if left.is_empty() || right.is_empty() {
        return Err(Error::ScriptParse(format!(
            "unsupported for statement: {header}"
        )));
    }

    let item_var = parse_for_in_of_var(left)?;
    Ok(Some((kind, item_var, right)))
}

fn find_top_level_in_of_keyword(src: &str, keyword: &str) -> Result<Option<usize>> {
    let bytes = src.as_bytes();
    let mut state = 0u8;
    let mut i = 0usize;
    let mut paren = 0isize;
    let mut bracket = 0isize;
    let mut brace = 0isize;

    while i < bytes.len() {
        let b = bytes[i];
        match state {
            0 => match b {
                b'\'' => state = 1,
                b'"' => state = 2,
                b'`' => state = 3,
                b'(' => paren += 1,
                b')' => paren -= 1,
                b'[' => bracket += 1,
                b']' => bracket -= 1,
                b'{' => brace += 1,
                b'}' => brace -= 1,
                _ => {
                    if paren == 0 && bracket == 0 && brace == 0 {
                        if i + keyword.len() <= bytes.len() && &src[i..i + keyword.len()] == keyword
                        {
                            let prev_ok = i == 0
                                || !is_ident_char(
                                    src.as_bytes()
                                        .get(i.wrapping_sub(1))
                                        .copied()
                                        .unwrap_or_default(),
                                );
                            let next = src.as_bytes().get(i + keyword.len()).copied();
                            let next_ok = next.is_none() || !is_ident_char(next.unwrap());
                            if prev_ok && next_ok {
                                return Ok(Some(i));
                            }
                        }
                    }
                }
            },
            1 => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'\'' {
                    state = 0;
                }
            }
            2 => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'"' {
                    state = 0;
                }
            }
            3 => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'`' {
                    state = 0;
                }
            }
            _ => state = 0,
        }
        i += 1;
    }

    Ok(None)
}

fn parse_for_in_of_var(raw: &str) -> Result<String> {
    let mut cursor = Cursor::new(raw);
    cursor.skip_ws();
    let first = cursor
        .parse_identifier()
        .ok_or_else(|| Error::ScriptParse(format!("invalid for statement variable: {raw}")))?;

    let name = if matches!(first.as_str(), "let" | "const" | "var") {
        cursor.skip_ws();
        let name = cursor
            .parse_identifier()
            .ok_or_else(|| Error::ScriptParse(format!("invalid for statement variable: {raw}")))?;
        name
    } else {
        first
    };

    cursor.skip_ws();
    if !cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "invalid for statement declaration: {raw}"
        )));
    }
    if !is_ident(&name) {
        return Err(Error::ScriptParse(format!(
            "invalid for statement variable: {raw}"
        )));
    }
    Ok(name)
}

fn parse_for_clause_stmt(src: &str) -> Result<Option<Box<Stmt>>> {
    let src = src.trim();
    if src.is_empty() {
        return Ok(None);
    }

    if let Some(parsed) = parse_var_decl(src)? {
        return Ok(Some(Box::new(parsed)));
    }

    if let Some(parsed) = parse_var_assign(src)? {
        return Ok(Some(Box::new(parsed)));
    }

    if let Some(parsed) = parse_for_update_stmt(src) {
        return Ok(Some(Box::new(parsed)));
    }

    let expr = parse_expr(src)
        .map_err(|_| Error::ScriptParse(format!("unsupported for-loop clause: {src}")))?;
    Ok(Some(Box::new(Stmt::Expr(expr))))
}

fn parse_for_update_stmt(src: &str) -> Option<Stmt> {
    parse_update_stmt(src)
}

fn parse_update_stmt(stmt: &str) -> Option<Stmt> {
    let src = stmt.trim();

    if let Some(name) = src.strip_prefix("++") {
        let name = name.trim();
        if is_ident(name) {
            return Some(Stmt::VarUpdate {
                name: name.to_string(),
                delta: 1,
            });
        }
    }

    if let Some(name) = src.strip_prefix("--") {
        let name = name.trim();
        if is_ident(name) {
            return Some(Stmt::VarUpdate {
                name: name.to_string(),
                delta: -1,
            });
        }
    }

    if let Some(name) = src.strip_suffix("++") {
        let name = name.trim();
        if is_ident(name) {
            return Some(Stmt::VarUpdate {
                name: name.to_string(),
                delta: 1,
            });
        }
    }

    if let Some(name) = src.strip_suffix("--") {
        let name = name.trim();
        if is_ident(name) {
            return Some(Stmt::VarUpdate {
                name: name.to_string(),
                delta: -1,
            });
        }
    }

    None
}

fn split_top_level_statements(body: &str) -> Vec<String> {
    let bytes = body.as_bytes();
    let mut out = Vec::new();
    let mut start = 0;
    let mut i = 0;

    let mut paren = 0usize;
    let mut bracket = 0usize;
    let mut brace = 0usize;
    let mut brace_open_stack = Vec::new();

    #[derive(Clone, Copy, PartialEq, Eq)]
    enum StrState {
        None,
        Single,
        Double,
        Backtick,
        Regex { in_class: bool },
    }
    let mut state = StrState::None;
    let mut previous_significant = None;

    while i < bytes.len() {
        let b = bytes[i];
        match state {
            StrState::None => {
                if b.is_ascii_whitespace() {
                    i += 1;
                    continue;
                }
                match b {
                    b'\'' => state = StrState::Single,
                    b'"' => state = StrState::Double,
                    b'`' => state = StrState::Backtick,
                    b'/' => {
                        if can_start_regex_literal(previous_significant) {
                            state = StrState::Regex { in_class: false };
                        } else {
                            previous_significant = Some(b);
                        }
                    }
                    b'(' => {
                        paren += 1;
                        previous_significant = Some(b);
                    }
                    b')' => {
                        paren = paren.saturating_sub(1);
                        previous_significant = Some(b);
                    }
                    b'[' => {
                        bracket += 1;
                        previous_significant = Some(b);
                    }
                    b']' => {
                        bracket = bracket.saturating_sub(1);
                        previous_significant = Some(b);
                    }
                    b'{' => {
                        brace += 1;
                        brace_open_stack.push(i);
                        previous_significant = Some(b);
                    }
                    b'}' => {
                        brace = brace.saturating_sub(1);
                        let block_open = brace_open_stack.pop();
                        if paren == 0 && bracket == 0 && brace == 0 {
                            let tail = body.get(i + 1..).unwrap_or_default();
                            if should_split_after_closing_brace(body, block_open, tail) {
                                if let Some(part) = body.get(start..=i) {
                                    out.push(part.to_string());
                                }
                                start = i + 1;
                            }
                        }
                        previous_significant = Some(b);
                    }
                    b';' => {
                        if paren == 0 && bracket == 0 && brace == 0 {
                            if let Some(part) = body.get(start..i) {
                                out.push(part.to_string());
                            }
                            start = i + 1;
                        }
                        previous_significant = Some(b);
                    }
                    _ => {
                        previous_significant = Some(b);
                    }
                }
            }
            StrState::Single => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'\'' {
                    state = StrState::None;
                    previous_significant = Some(b'\'');
                }
            }
            StrState::Double => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'"' {
                    state = StrState::None;
                    previous_significant = Some(b'"');
                }
            }
            StrState::Backtick => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'`' {
                    state = StrState::None;
                    previous_significant = Some(b'`');
                }
            }
            StrState::Regex { mut in_class } => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'[' {
                    in_class = true;
                    state = StrState::Regex { in_class };
                } else if b == b']' && in_class {
                    in_class = false;
                    state = StrState::Regex { in_class };
                } else if b == b'/' && !in_class {
                    state = StrState::None;
                    previous_significant = Some(b'/');
                } else {
                    state = StrState::Regex { in_class };
                }
            }
        }
        i += 1;
    }

    if let Some(tail) = body.get(start..) {
        if !tail.trim().is_empty() {
            out.push(tail.to_string());
        }
    }

    out
}

fn should_split_after_closing_brace(body: &str, block_open: Option<usize>, tail: &str) -> bool {
    let tail = tail.trim_start();
    if tail.is_empty() {
        return false;
    }
    if tail.starts_with('=') {
        // Preserve object destructuring assignment: `{ a, b } = value`.
        return false;
    }
    if is_keyword_prefix(tail, "else") {
        return false;
    }
    if is_keyword_prefix(tail, "catch") {
        return false;
    }
    if is_keyword_prefix(tail, "finally") {
        return false;
    }
    if is_keyword_prefix(tail, "while")
        && block_open.is_some_and(|open| is_do_block_prefix(body, open))
    {
        return false;
    }
    true
}

fn is_do_block_prefix(body: &str, block_open: usize) -> bool {
    let bytes = body.as_bytes();
    if block_open == 0 || block_open > bytes.len() {
        return false;
    }

    let mut j = block_open;
    while j > 0 && bytes[j - 1].is_ascii_whitespace() {
        j -= 1;
    }
    if j < 2 {
        return false;
    }
    if &bytes[j - 2..j] != b"do" {
        return false;
    }
    match bytes.get(j - 3) {
        Some(&b) => !is_ident_char(b),
        None => true,
    }
}

fn is_keyword_prefix(src: &str, keyword: &str) -> bool {
    let Some(rest) = src.strip_prefix(keyword) else {
        return false;
    };
    rest.is_empty() || !is_ident_char(*rest.as_bytes().first().unwrap_or(&b'\0'))
}

fn parse_function_decl_stmt(stmt: &str) -> Result<Option<Stmt>> {
    let stmt = stmt.trim();
    let mut cursor = Cursor::new(stmt);
    cursor.skip_ws();
    let is_async = if try_consume_async_function_prefix(&mut cursor) {
        cursor.consume_ascii("function");
        true
    } else {
        if !cursor.consume_ascii("function") {
            return Ok(None);
        }
        if let Some(next) = cursor.peek() {
            if is_ident_char(next) {
                return Ok(None);
            }
        }
        false
    };
    cursor.skip_ws();

    let Some(name) = cursor.parse_identifier() else {
        return Err(Error::ScriptParse(
            "function declaration requires a function name".into(),
        ));
    };
    cursor.skip_ws();
    let params_src = cursor.read_balanced_block(b'(', b')')?;
    let params = parse_callback_parameter_list(&params_src, usize::MAX, "function parameters")?;
    cursor.skip_ws();
    let body = cursor.read_balanced_block(b'{', b'}')?;
    cursor.skip_ws();
    cursor.consume_byte(b';');
    cursor.skip_ws();
    if !cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "unsupported function declaration tail: {stmt}"
        )));
    }

    Ok(Some(Stmt::FunctionDecl {
        name,
        handler: ScriptHandler {
            params,
            stmts: parse_block_statements(&body)?,
        },
        is_async,
    }))
}

fn parse_var_decl(stmt: &str) -> Result<Option<Stmt>> {
    let mut rest = None;
    for kw in ["const", "let", "var"] {
        if let Some(after) = stmt.strip_prefix(kw) {
            rest = Some(after.trim_start());
            break;
        }
    }

    let Some(rest) = rest else {
        return Ok(None);
    };

    let (name, expr_src) = rest
        .split_once('=')
        .ok_or_else(|| Error::ScriptParse(format!("invalid variable declaration: {stmt}")))?;

    let name = name.trim();
    if !is_ident(name) {
        return Err(Error::ScriptParse(format!(
            "invalid variable name '{name}' in: {stmt}"
        )));
    }

    let expr = parse_expr(expr_src.trim())?;
    Ok(Some(Stmt::VarDecl {
        name: name.to_string(),
        expr,
    }))
}

fn parse_var_assign(stmt: &str) -> Result<Option<Stmt>> {
    let stmt = stmt.trim();
    let Some((name, op_len, value_src)) = find_top_level_var_assignment(stmt) else {
        return Ok(None);
    };

    if name.is_empty() || !is_ident(&name) {
        return Ok(None);
    }

    let split_pos = stmt.len() - value_src.len();
    let op = match &stmt[split_pos - op_len..split_pos] {
        "=" => VarAssignOp::Assign,
        "+=" => VarAssignOp::Add,
        "-=" => VarAssignOp::Sub,
        "*=" => VarAssignOp::Mul,
        "/=" => VarAssignOp::Div,
        "**=" => VarAssignOp::Pow,
        "%=" => VarAssignOp::Mod,
        "|=" => VarAssignOp::BitOr,
        "^=" => VarAssignOp::BitXor,
        "&=" => VarAssignOp::BitAnd,
        "<<=" => VarAssignOp::ShiftLeft,
        ">>=" => VarAssignOp::ShiftRight,
        ">>>=" => VarAssignOp::UnsignedShiftRight,
        "&&=" => VarAssignOp::LogicalAnd,
        "||=" => VarAssignOp::LogicalOr,
        "??=" => VarAssignOp::Nullish,
        _ => {
            return Err(Error::ScriptParse(format!(
                "unsupported assignment operator: {stmt}"
            )));
        }
    };

    let expr = parse_expr(value_src)?;
    Ok(Some(Stmt::VarAssign {
        name: name.to_string(),
        op,
        expr,
    }))
}

fn find_top_level_var_assignment(stmt: &str) -> Option<(String, usize, &str)> {
    let (eq_pos, op_len) = find_top_level_assignment(stmt)?;
    let lhs = stmt[..eq_pos].trim();
    if lhs.is_empty() {
        return None;
    }

    Some((
        lhs.to_string(),
        op_len,
        stmt.get(eq_pos + op_len..).unwrap_or_default(),
    ))
}

fn parse_destructure_assign(stmt: &str) -> Result<Option<Stmt>> {
    let stmt = stmt.trim();
    let Some((eq_pos, op_len)) = find_top_level_assignment(stmt) else {
        return Ok(None);
    };
    if op_len != 1 {
        return Ok(None);
    }

    let lhs = stmt[..eq_pos].trim();
    let rhs = stmt[eq_pos + op_len..].trim();
    if lhs.is_empty() || rhs.is_empty() {
        return Ok(None);
    }

    if lhs.starts_with('[') && lhs.ends_with(']') {
        let targets = parse_array_destructure_pattern(lhs)?;
        let expr = parse_expr(rhs)?;
        return Ok(Some(Stmt::ArrayDestructureAssign { targets, expr }));
    }
    if lhs.starts_with('{') && lhs.ends_with('}') {
        let bindings = parse_object_destructure_pattern(lhs)?;
        let expr = parse_expr(rhs)?;
        return Ok(Some(Stmt::ObjectDestructureAssign { bindings, expr }));
    }

    Ok(None)
}

fn parse_array_destructure_pattern(pattern: &str) -> Result<Vec<Option<String>>> {
    let mut cursor = Cursor::new(pattern);
    cursor.skip_ws();
    let items_src = cursor.read_balanced_block(b'[', b']')?;
    cursor.skip_ws();
    if !cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "invalid array destructuring pattern: {pattern}"
        )));
    }

    let mut items = split_top_level_by_char(&items_src, b',');
    while items.len() > 1 && items.last().is_some_and(|item| item.trim().is_empty()) {
        items.pop();
    }
    if items.len() == 1 && items[0].trim().is_empty() {
        return Ok(Vec::new());
    }

    let mut targets = Vec::with_capacity(items.len());
    for item in items {
        let item = item.trim();
        if item.is_empty() {
            targets.push(None);
            continue;
        }
        if !is_ident(item) {
            return Err(Error::ScriptParse(format!(
                "array destructuring target must be an identifier: {item}"
            )));
        }
        targets.push(Some(item.to_string()));
    }
    Ok(targets)
}

fn parse_object_destructure_pattern(pattern: &str) -> Result<Vec<(String, String)>> {
    let mut cursor = Cursor::new(pattern);
    cursor.skip_ws();
    let items_src = cursor.read_balanced_block(b'{', b'}')?;
    cursor.skip_ws();
    if !cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "invalid object destructuring pattern: {pattern}"
        )));
    }

    let mut items = split_top_level_by_char(&items_src, b',');
    while items.len() > 1 && items.last().is_some_and(|item| item.trim().is_empty()) {
        items.pop();
    }
    if items.len() == 1 && items[0].trim().is_empty() {
        return Ok(Vec::new());
    }

    let mut bindings = Vec::with_capacity(items.len());
    for item in items {
        let item = item.trim();
        if item.is_empty() {
            return Err(Error::ScriptParse(
                "object destructuring pattern does not support empty entries".into(),
            ));
        }

        if let Some(colon) = find_first_top_level_colon(item) {
            let source = item[..colon].trim();
            let target = item[colon + 1..].trim();
            if !is_ident(source) || !is_ident(target) {
                return Err(Error::ScriptParse(format!(
                    "object destructuring entry must be identifier or identifier: identifier: {item}"
                )));
            }
            bindings.push((source.to_string(), target.to_string()));
        } else {
            if !is_ident(item) {
                return Err(Error::ScriptParse(format!(
                    "object destructuring entry must be an identifier: {item}"
                )));
            }
            bindings.push((item.to_string(), item.to_string()));
        }
    }

    Ok(bindings)
}

fn parse_form_data_append_stmt(stmt: &str) -> Result<Option<Stmt>> {
    let stmt = stmt.trim();
    let mut cursor = Cursor::new(stmt);
    cursor.skip_ws();

    let Some(target_var) = cursor.parse_identifier() else {
        return Ok(None);
    };

    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();

    let Some(method) = cursor.parse_identifier() else {
        return Ok(None);
    };
    if method != "append" {
        return Ok(None);
    }

    cursor.skip_ws();
    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let args = split_top_level_by_char(&args_src, b',');
    if args.len() != 2 {
        return Ok(None);
    }

    let name = parse_expr(args[0].trim())?;
    let value = parse_expr(args[1].trim())?;

    cursor.skip_ws();
    cursor.consume_byte(b';');
    cursor.skip_ws();
    if !cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "unsupported FormData.append statement tail: {stmt}"
        )));
    }

    Ok(Some(Stmt::FormDataAppend {
        target_var,
        name,
        value,
    }))
}

fn parse_dom_method_call_stmt(stmt: &str) -> Result<Option<Stmt>> {
    let stmt = stmt.trim();
    let mut cursor = Cursor::new(stmt);
    let target = match parse_element_target(&mut cursor) {
        Ok(target) => target,
        Err(_) => return Ok(None),
    };

    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();

    let Some(method_name) = cursor.parse_identifier() else {
        return Ok(None);
    };
    let (method, accepts_optional_arg) = match method_name.as_str() {
        "focus" => (DomMethod::Focus, false),
        "blur" => (DomMethod::Blur, false),
        "click" => (DomMethod::Click, false),
        "scrollIntoView" => (DomMethod::ScrollIntoView, false),
        "submit" => (DomMethod::Submit, false),
        "reset" => (DomMethod::Reset, false),
        "show" => (DomMethod::Show, false),
        "showModal" => (DomMethod::ShowModal, false),
        "close" => (DomMethod::Close, true),
        "requestClose" => (DomMethod::RequestClose, true),
        _ => return Ok(None),
    };

    cursor.skip_ws();
    let args = cursor.read_balanced_block(b'(', b')')?;
    let arg = if accepts_optional_arg {
        let parsed_args = split_top_level_by_char(&args, b',');
        if parsed_args.len() == 1 && parsed_args[0].trim().is_empty() {
            None
        } else {
            if parsed_args.len() != 1 || parsed_args[0].trim().is_empty() {
                return Err(Error::ScriptParse(format!(
                    "{} accepts zero or one argument: {stmt}",
                    method_name
                )));
            }
            Some(parse_expr(parsed_args[0].trim())?)
        }
    } else {
        if !args.trim().is_empty() {
            return Err(Error::ScriptParse(format!(
                "{} takes no arguments: {stmt}",
                method_name
            )));
        }
        None
    };

    cursor.skip_ws();
    cursor.consume_byte(b';');
    cursor.skip_ws();
    if !cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "unsupported {} statement tail: {stmt}",
            method_name
        )));
    }

    Ok(Some(Stmt::DomMethodCall {
        target,
        method,
        arg,
    }))
}

fn parse_dom_assignment(stmt: &str) -> Result<Option<Stmt>> {
    let Some((eq_pos, op_len)) = find_top_level_assignment(stmt) else {
        return Ok(None);
    };

    let lhs = stmt[..eq_pos].trim();
    let rhs = stmt[eq_pos + op_len..].trim();

    if lhs.is_empty() {
        return Ok(None);
    }

    if op_len != 1 {
        return Ok(None);
    }

    let Some((target, prop)) = parse_dom_access(lhs)? else {
        return Ok(None);
    };

    let expr = parse_expr(rhs)?;
    Ok(Some(Stmt::DomAssign { target, prop, expr }))
}

fn parse_object_assign(stmt: &str) -> Result<Option<Stmt>> {
    let Some((eq_pos, op_len)) = find_top_level_assignment(stmt) else {
        return Ok(None);
    };

    if op_len != 1 {
        return Ok(None);
    }

    let lhs = stmt[..eq_pos].trim();
    let rhs = stmt[eq_pos + op_len..].trim();
    if lhs.is_empty() {
        return Ok(None);
    }

    let mut cursor = Cursor::new(lhs);
    cursor.skip_ws();
    let Some(target) = cursor.parse_identifier() else {
        return Ok(None);
    };
    cursor.skip_ws();

    let key = if cursor.consume_byte(b'.') {
        cursor.skip_ws();
        let Some(prop) = cursor.parse_identifier() else {
            return Ok(None);
        };
        Expr::String(prop)
    } else if cursor.peek() == Some(b'[') {
        let key_src = cursor.read_balanced_block(b'[', b']')?;
        let key_src = key_src.trim();
        if key_src.is_empty() {
            return Err(Error::ScriptParse(
                "object assignment key cannot be empty".into(),
            ));
        }
        parse_expr(key_src)?
    } else {
        return Ok(None);
    };

    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }

    let expr = parse_expr(rhs)?;
    Ok(Some(Stmt::ObjectAssign { target, key, expr }))
}

fn parse_query_selector_all_foreach_stmt(stmt: &str) -> Result<Option<Stmt>> {
    let stmt = stmt.trim();
    let mut cursor = Cursor::new(stmt);
    cursor.skip_ws();

    let source = match parse_element_target(&mut cursor) {
        Ok(target) => target,
        Err(_) => return Ok(None),
    };
    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    let method = cursor
        .parse_identifier()
        .ok_or_else(|| Error::ScriptParse(format!("invalid forEach statement: {stmt}")))?;

    let (target, selector) = match method.as_str() {
        "forEach" => {
            let (target, selector) = match &source {
                DomQuery::BySelectorAll { selector } => (None, selector.clone()),
                DomQuery::QuerySelectorAll { target, selector } => {
                    (Some(target.as_ref().clone()), selector.clone())
                }
                _ => {
                    return Ok(None);
                }
            };
            cursor.skip_ws();
            (target, selector)
        }
        "querySelectorAll" => {
            cursor.skip_ws();
            cursor.expect_byte(b'(')?;
            cursor.skip_ws();
            let selector = cursor.parse_string_literal()?;
            cursor.skip_ws();
            cursor.expect_byte(b')')?;
            cursor.skip_ws();
            if !cursor.consume_byte(b'.') {
                return Ok(None);
            }
            cursor.skip_ws();
            if !cursor.consume_ascii("forEach") {
                return Ok(None);
            }
            (
                match source {
                    DomQuery::DocumentRoot => None,
                    _ => Some(source.clone()),
                },
                selector,
            )
        }
        _ => return Ok(None),
    };
    cursor.skip_ws();

    // For consistency with current test grammar, allow optional event callback without a semicolon.
    cursor.skip_ws();

    let callback_src = cursor.read_balanced_block(b'(', b')')?;
    let (item_var, index_var, body) = parse_for_each_callback(&callback_src)?;

    cursor.skip_ws();
    cursor.consume_byte(b';');
    cursor.skip_ws();
    if !cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "unsupported forEach statement tail: {stmt}"
        )));
    }

    Ok(Some(Stmt::ForEach {
        target,
        selector,
        item_var,
        index_var,
        body,
    }))
}

fn parse_array_for_each_stmt(stmt: &str) -> Result<Option<Stmt>> {
    let stmt = stmt.trim();
    let mut cursor = Cursor::new(stmt);
    cursor.skip_ws();
    let Some(target) = cursor.parse_identifier() else {
        return Ok(None);
    };

    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.consume_ascii("forEach") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();

    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let args = split_top_level_by_char(&args_src, b',');
    if args.is_empty() || args.len() > 2 || args[0].trim().is_empty() {
        return Err(Error::ScriptParse(
            "forEach requires a callback and optional thisArg".into(),
        ));
    }
    if args.len() == 2 && args[1].trim().is_empty() {
        return Err(Error::ScriptParse("forEach thisArg cannot be empty".into()));
    }
    let callback = parse_array_callback_arg(args[0], 3, "array callback parameters")?;
    if args.len() == 2 {
        let _ = parse_expr(args[1].trim())?;
    }

    cursor.skip_ws();
    cursor.consume_byte(b';');
    cursor.skip_ws();
    if !cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "unsupported forEach statement tail: {stmt}"
        )));
    }

    Ok(Some(Stmt::ArrayForEach { target, callback }))
}

fn parse_for_each_callback(src: &str) -> Result<(String, Option<String>, Vec<Stmt>)> {
    let mut cursor = Cursor::new(src.trim());
    cursor.skip_ws();

    let (item_var, index_var) = if cursor
        .src
        .get(cursor.i..)
        .is_some_and(|src| src.starts_with("function"))
        && !cursor
            .bytes()
            .get(cursor.i + "function".len())
            .is_some_and(|&b| is_ident_char(b))
    {
        cursor.consume_ascii("function");
        cursor.skip_ws();
        if !cursor.consume_byte(b'(') {
            let _ = cursor
                .parse_identifier()
                .ok_or_else(|| Error::ScriptParse("expected function name".into()))?;
            cursor.skip_ws();
            cursor.expect_byte(b'(')?;
        }
        let params_src = cursor.read_until_byte(b')')?;
        cursor.expect_byte(b')')?;
        let params = parse_callback_parameter_list(
            &params_src,
            2,
            "forEach callback must have one or two parameters",
        )?;
        if params.iter().any(|param| param.default.is_some()) {
            return Err(Error::ScriptParse(format!(
                "forEach callback must not use default parameters: {src}"
            )));
        }
        let item_var = params
            .first()
            .map(|param| param.name.clone())
            .ok_or_else(|| {
                Error::ScriptParse(format!(
                    "forEach callback must have one or two parameters: {src}"
                ))
            })?;
        let index_var = params.get(1).map(|param| param.name.clone());

        cursor.skip_ws();
        let (body, concise_body) = parse_arrow_or_block_body(&mut cursor)?;
        cursor.skip_ws();
        if !cursor.eof() {
            return Err(Error::ScriptParse(format!(
                "unsupported forEach callback tail: {src}"
            )));
        }

        let body_stmts = if concise_body {
            vec![Stmt::Expr(parse_expr(body.trim())?)]
        } else {
            parse_block_statements(&body)?
        };
        return Ok((item_var, index_var, body_stmts));
    } else if cursor.consume_byte(b'(') {
        let params_src = cursor.read_until_byte(b')')?;
        cursor.expect_byte(b')')?;
        let params = parse_callback_parameter_list(
            &params_src,
            2,
            "forEach callback must have one or two parameters",
        )?;
        if params.iter().any(|param| param.default.is_some()) {
            return Err(Error::ScriptParse(format!(
                "forEach callback must not use default parameters: {src}"
            )));
        }
        let item_var = params
            .first()
            .map(|param| param.name.clone())
            .ok_or_else(|| {
                Error::ScriptParse(format!(
                    "forEach callback must have one or two parameters: {src}"
                ))
            })?;
        let index_var = params.get(1).map(|param| param.name.clone());
        (item_var, index_var)
    } else {
        let Some(item) = cursor.parse_identifier() else {
            return Err(Error::ScriptParse(format!(
                "invalid forEach callback parameters: {src}"
            )));
        };
        (item, None)
    };

    cursor.skip_ws();
    cursor.expect_ascii("=>")?;
    cursor.skip_ws();
    let (body, concise_body) = parse_arrow_or_block_body(&mut cursor)?;
    cursor.skip_ws();
    if !cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "unsupported forEach callback tail: {src}"
        )));
    }

    let body_stmts = if concise_body {
        vec![Stmt::Expr(parse_expr(body.trim())?)]
    } else {
        parse_block_statements(&body)?
    };
    Ok((item_var, index_var, body_stmts))
}

fn parse_set_attribute_stmt(stmt: &str) -> Result<Option<Stmt>> {
    let stmt = stmt.trim();
    let mut cursor = Cursor::new(stmt);
    let target = match parse_element_target(&mut cursor) {
        Ok(target) => target,
        Err(_) => return Ok(None),
    };

    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.consume_ascii("setAttribute") {
        return Ok(None);
    }
    cursor.skip_ws();

    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let args = split_top_level_by_char(&args_src, b',');
    if args.len() != 2 {
        return Err(Error::ScriptParse(format!(
            "setAttribute requires 2 arguments: {stmt}"
        )));
    }
    let name = parse_string_literal_exact(args[0].trim())?;
    let value = parse_expr(args[1].trim())?;

    cursor.skip_ws();
    cursor.consume_byte(b';');
    cursor.skip_ws();
    if !cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "unsupported setAttribute statement tail: {stmt}"
        )));
    }

    Ok(Some(Stmt::DomSetAttribute {
        target,
        name,
        value,
    }))
}

fn parse_remove_attribute_stmt(stmt: &str) -> Result<Option<Stmt>> {
    let stmt = stmt.trim();
    let mut cursor = Cursor::new(stmt);
    let target = match parse_element_target(&mut cursor) {
        Ok(target) => target,
        Err(_) => return Ok(None),
    };

    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.consume_ascii("removeAttribute") {
        return Ok(None);
    }
    cursor.skip_ws();
    cursor.expect_byte(b'(')?;
    cursor.skip_ws();
    let name = cursor.parse_string_literal()?;
    cursor.skip_ws();
    cursor.expect_byte(b')')?;
    cursor.skip_ws();
    cursor.consume_byte(b';');
    cursor.skip_ws();
    if !cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "unsupported removeAttribute statement tail: {stmt}"
        )));
    }

    Ok(Some(Stmt::DomRemoveAttribute { target, name }))
}

fn parse_class_list_stmt(stmt: &str) -> Result<Option<Stmt>> {
    let stmt = stmt.trim();
    let mut cursor = Cursor::new(stmt);
    let target = match parse_element_target(&mut cursor) {
        Ok(target) => target,
        Err(_) => return Ok(None),
    };

    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.consume_ascii("classList") {
        return Ok(None);
    }
    cursor.skip_ws();
    cursor.expect_byte(b'.')?;
    cursor.skip_ws();

    let method = cursor
        .parse_identifier()
        .ok_or_else(|| Error::ScriptParse(format!("expected classList method in: {stmt}")))?;

    if method == "forEach" {
        cursor.skip_ws();
        let callback_src = cursor.read_balanced_block(b'(', b')')?;
        let (item_var, index_var, body) = parse_for_each_callback(&callback_src)?;

        cursor.skip_ws();
        cursor.consume_byte(b';');
        cursor.skip_ws();
        if !cursor.eof() {
            return Err(Error::ScriptParse(format!(
                "unsupported classList statement tail: {stmt}"
            )));
        }

        return Ok(Some(Stmt::ClassListForEach {
            target,
            item_var,
            index_var,
            body,
        }));
    }

    let method = match method.as_str() {
        "add" => ClassListMethod::Add,
        "remove" => ClassListMethod::Remove,
        "toggle" => ClassListMethod::Toggle,
        _ => return Ok(None),
    };

    cursor.skip_ws();
    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let args = split_top_level_by_char(&args_src, b',');
    if args.is_empty() {
        return Err(Error::ScriptParse(format!(
            "invalid classList arguments: {stmt}"
        )));
    }

    let force = match method {
        ClassListMethod::Toggle => {
            if args.len() > 2 {
                return Err(Error::ScriptParse(format!(
                    "invalid classList arguments: {stmt}"
                )));
            }

            if args.len() == 2 {
                Some(parse_expr(args[1].trim())?)
            } else {
                None
            }
        }
        _ => None,
    };

    let class_names = match method {
        ClassListMethod::Toggle => vec![parse_string_literal_exact(args[0].trim())?],
        _ => args
            .iter()
            .map(|arg| parse_string_literal_exact(arg.trim()))
            .collect::<Result<Vec<_>>>()?,
    };

    if !matches!(method, ClassListMethod::Toggle) && class_names.is_empty() {
        return Err(Error::ScriptParse(format!(
            "classList add/remove requires at least one argument: {stmt}"
        )));
    }

    if !matches!(method, ClassListMethod::Toggle) && force.is_some() {
        return Err(Error::ScriptParse(
            "classList add/remove do not accept a force argument".into(),
        ));
    }

    cursor.skip_ws();
    cursor.consume_byte(b';');
    cursor.skip_ws();

    if !cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "unsupported classList statement tail: {stmt}"
        )));
    }

    Ok(Some(Stmt::ClassListCall {
        target,
        method,
        class_names,
        force,
    }))
}

fn parse_insert_adjacent_position(src: &str) -> Result<InsertAdjacentPosition> {
    let lowered = src.to_ascii_lowercase();
    match lowered.as_str() {
        "beforebegin" => Ok(InsertAdjacentPosition::BeforeBegin),
        "afterbegin" => Ok(InsertAdjacentPosition::AfterBegin),
        "beforeend" => Ok(InsertAdjacentPosition::BeforeEnd),
        "afterend" => Ok(InsertAdjacentPosition::AfterEnd),
        _ => Err(Error::ScriptParse(format!(
            "unsupported insertAdjacent position: {src}"
        ))),
    }
}

fn resolve_insert_adjacent_position(src: &str) -> Result<InsertAdjacentPosition> {
    let lowered = src.to_ascii_lowercase();
    match lowered.as_str() {
        "beforebegin" => Ok(InsertAdjacentPosition::BeforeBegin),
        "afterbegin" => Ok(InsertAdjacentPosition::AfterBegin),
        "beforeend" => Ok(InsertAdjacentPosition::BeforeEnd),
        "afterend" => Ok(InsertAdjacentPosition::AfterEnd),
        _ => Err(Error::ScriptRuntime(format!(
            "unsupported insertAdjacentHTML position: {src}"
        ))),
    }
}

fn parse_insert_adjacent_element_stmt(stmt: &str) -> Result<Option<Stmt>> {
    let stmt = stmt.trim();
    let mut cursor = Cursor::new(stmt);
    let target = match parse_element_target(&mut cursor) {
        Ok(target) => target,
        Err(_) => return Ok(None),
    };

    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.consume_ascii("insertAdjacentElement") {
        return Ok(None);
    }
    cursor.skip_ws();

    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let args = split_top_level_by_char(&args_src, b',');
    if args.len() != 2 {
        return Err(Error::ScriptParse(format!(
            "insertAdjacentElement requires 2 arguments: {stmt}"
        )));
    }

    let position = parse_insert_adjacent_position(&parse_string_literal_exact(args[0].trim())?)?;
    let node = parse_expr(args[1].trim())?;

    cursor.skip_ws();
    cursor.consume_byte(b';');
    cursor.skip_ws();
    if !cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "unsupported insertAdjacentElement statement tail: {stmt}"
        )));
    }

    Ok(Some(Stmt::InsertAdjacentElement {
        target,
        position,
        node,
    }))
}

fn parse_insert_adjacent_text_stmt(stmt: &str) -> Result<Option<Stmt>> {
    let stmt = stmt.trim();
    let mut cursor = Cursor::new(stmt);
    let target = match parse_element_target(&mut cursor) {
        Ok(target) => target,
        Err(_) => return Ok(None),
    };

    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.consume_ascii("insertAdjacentText") {
        return Ok(None);
    }
    cursor.skip_ws();

    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let args = split_top_level_by_char(&args_src, b',');
    if args.len() != 2 {
        return Err(Error::ScriptParse(format!(
            "insertAdjacentText requires 2 arguments: {stmt}"
        )));
    }

    let position = parse_insert_adjacent_position(&parse_string_literal_exact(args[0].trim())?)?;
    let text = parse_expr(args[1].trim())?;

    cursor.skip_ws();
    cursor.consume_byte(b';');
    cursor.skip_ws();
    if !cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "unsupported insertAdjacentText statement tail: {stmt}"
        )));
    }

    Ok(Some(Stmt::InsertAdjacentText {
        target,
        position,
        text,
    }))
}

fn parse_insert_adjacent_html_stmt(stmt: &str) -> Result<Option<Stmt>> {
    let stmt = stmt.trim();
    let mut cursor = Cursor::new(stmt);
    let target = match parse_element_target(&mut cursor) {
        Ok(target) => target,
        Err(_) => return Ok(None),
    };

    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.consume_ascii("insertAdjacentHTML") {
        return Ok(None);
    }
    cursor.skip_ws();

    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let args = split_top_level_by_char(&args_src, b',');
    if args.len() != 2 {
        return Err(Error::ScriptParse(format!(
            "insertAdjacentHTML requires 2 arguments: {stmt}"
        )));
    }

    let position = parse_expr(args[0].trim())?;
    let html = parse_expr(args[1].trim())?;

    cursor.skip_ws();
    cursor.consume_byte(b';');
    cursor.skip_ws();
    if !cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "unsupported insertAdjacentHTML statement tail: {stmt}"
        )));
    }

    Ok(Some(Stmt::InsertAdjacentHTML {
        target,
        position,
        html,
    }))
}

fn parse_set_timer_call(
    cursor: &mut Cursor<'_>,
    timer_name: &str,
) -> Result<Option<(TimerInvocation, Expr)>> {
    cursor.skip_ws();
    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(None);
        }
        cursor.skip_ws();
    }

    if !cursor.consume_ascii(timer_name) {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();

    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let args = split_top_level_by_char(&args_src, b',');
    if args.is_empty() {
        return Err(Error::ScriptParse(format!(
            "{timer_name} requires at least 1 argument"
        )));
    }

    let callback_arg = strip_js_comments(args[0]);
    let callback = parse_timer_callback(timer_name, callback_arg.as_str().trim())?;

    let delay_ms = if args.len() >= 2 {
        let delay_src = strip_js_comments(args[1]).trim().to_string();
        if delay_src.is_empty() {
            Expr::Number(0)
        } else {
            parse_expr(&delay_src)?
        }
    } else {
        Expr::Number(0)
    };

    let mut extra_args = Vec::new();
    for arg in args.iter().skip(2) {
        let arg_src = strip_js_comments(arg);
        if arg_src.trim().is_empty() {
            continue;
        }
        extra_args.push(parse_expr(arg_src.trim())?);
    }

    Ok(Some((
        TimerInvocation {
            callback,
            args: extra_args,
        },
        delay_ms,
    )))
}

fn parse_set_timeout_call(cursor: &mut Cursor<'_>) -> Result<Option<(TimerInvocation, Expr)>> {
    parse_set_timer_call(cursor, "setTimeout")
}

fn parse_set_interval_call(cursor: &mut Cursor<'_>) -> Result<Option<(TimerInvocation, Expr)>> {
    parse_set_timer_call(cursor, "setInterval")
}

fn parse_set_timeout_stmt(stmt: &str) -> Result<Option<Stmt>> {
    let stmt = stmt.trim();
    let mut cursor = Cursor::new(stmt);
    let Some((handler, delay_ms)) = parse_set_timeout_call(&mut cursor)? else {
        return Ok(None);
    };

    cursor.skip_ws();
    cursor.consume_byte(b';');
    cursor.skip_ws();
    if !cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "unsupported setTimeout statement tail: {stmt}"
        )));
    }

    Ok(Some(Stmt::SetTimeout { handler, delay_ms }))
}

fn parse_set_interval_stmt(stmt: &str) -> Result<Option<Stmt>> {
    let stmt = stmt.trim();
    let mut cursor = Cursor::new(stmt);
    let Some((handler, delay_ms)) = parse_set_interval_call(&mut cursor)? else {
        return Ok(None);
    };

    cursor.skip_ws();
    cursor.consume_byte(b';');
    cursor.skip_ws();
    if !cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "unsupported setInterval statement tail: {stmt}"
        )));
    }

    Ok(Some(Stmt::SetInterval { handler, delay_ms }))
}

fn parse_clear_timeout_stmt(stmt: &str) -> Result<Option<Stmt>> {
    let stmt = stmt.trim();
    let mut cursor = Cursor::new(stmt);
    cursor.skip_ws();
    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(None);
        }
        cursor.skip_ws();
    }
    let method = if cursor.consume_ascii("clearTimeout") {
        "clearTimeout"
    } else if cursor.consume_ascii("clearInterval") {
        "clearInterval"
    } else if cursor.consume_ascii("cancelAnimationFrame") {
        "cancelAnimationFrame"
    } else {
        return Ok(None);
    };
    cursor.skip_ws();

    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let args = split_top_level_by_char(&args_src, b',');
    if args.len() != 1 || args[0].trim().is_empty() {
        return Err(Error::ScriptParse(format!(
            "{method} requires 1 argument: {stmt}"
        )));
    }
    let timer_id = parse_expr(args[0].trim())?;

    cursor.skip_ws();
    cursor.consume_byte(b';');
    cursor.skip_ws();
    if !cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "unsupported {method} statement tail: {stmt}"
        )));
    }

    Ok(Some(Stmt::ClearTimeout { timer_id }))
}

fn parse_node_tree_mutation_stmt(stmt: &str) -> Result<Option<Stmt>> {
    let stmt = stmt.trim();
    let mut cursor = Cursor::new(stmt);
    let target = match parse_element_target(&mut cursor) {
        Ok(target) => target,
        Err(_) => return Ok(None),
    };

    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    let Some(method) = cursor.parse_identifier() else {
        return Ok(None);
    };
    let method = match method.as_str() {
        "after" => NodeTreeMethod::After,
        "append" => NodeTreeMethod::Append,
        "appendChild" => NodeTreeMethod::AppendChild,
        "before" => NodeTreeMethod::Before,
        "replaceWith" => NodeTreeMethod::ReplaceWith,
        "prepend" => NodeTreeMethod::Prepend,
        "removeChild" => NodeTreeMethod::RemoveChild,
        "insertBefore" => NodeTreeMethod::InsertBefore,
        _ => return Ok(None),
    };
    cursor.skip_ws();

    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let args = split_top_level_by_char(&args_src, b',');
    let (method_name, expected_args) = match method {
        NodeTreeMethod::After => ("after", 1),
        NodeTreeMethod::Append => ("append", 1),
        NodeTreeMethod::AppendChild => ("appendChild", 1),
        NodeTreeMethod::Before => ("before", 1),
        NodeTreeMethod::ReplaceWith => ("replaceWith", 1),
        NodeTreeMethod::Prepend => ("prepend", 1),
        NodeTreeMethod::RemoveChild => ("removeChild", 1),
        NodeTreeMethod::InsertBefore => ("insertBefore", 2),
    };
    if args.len() != expected_args {
        return Err(Error::ScriptParse(format!(
            "{} requires {} argument{}: {}",
            method_name,
            expected_args,
            if expected_args == 1 { "" } else { "s" },
            stmt
        )));
    }
    let child = parse_expr(args[0].trim())?;
    let reference = if method == NodeTreeMethod::InsertBefore {
        Some(parse_expr(args[1].trim())?)
    } else {
        None
    };

    cursor.skip_ws();
    cursor.consume_byte(b';');
    cursor.skip_ws();
    if !cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "unsupported node tree mutation statement tail: {stmt}"
        )));
    }

    Ok(Some(Stmt::NodeTreeMutation {
        target,
        method,
        child,
        reference,
    }))
}

fn parse_node_remove_stmt(stmt: &str) -> Result<Option<Stmt>> {
    let stmt = stmt.trim();
    let mut cursor = Cursor::new(stmt);
    let target = match parse_element_target(&mut cursor) {
        Ok(target) => target,
        Err(_) => return Ok(None),
    };

    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    let Some(method) = cursor.parse_identifier() else {
        return Ok(None);
    };
    if method != "remove" {
        return Ok(None);
    }
    cursor.skip_ws();
    cursor.expect_byte(b'(')?;
    cursor.skip_ws();
    cursor.expect_byte(b')')?;
    cursor.skip_ws();
    cursor.consume_byte(b';');
    cursor.skip_ws();
    if !cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "unsupported remove() statement tail: {stmt}"
        )));
    }

    Ok(Some(Stmt::NodeRemove { target }))
}

fn parse_dispatch_event_stmt(stmt: &str) -> Result<Option<Stmt>> {
    let stmt = stmt.trim();
    let mut cursor = Cursor::new(stmt);
    let target = match parse_element_target(&mut cursor) {
        Ok(target) => target,
        Err(_) => return Ok(None),
    };

    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.consume_ascii("dispatchEvent") {
        return Ok(None);
    }
    cursor.skip_ws();

    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let args = split_top_level_by_char(&args_src, b',');
    if args.len() != 1 {
        return Err(Error::ScriptParse(format!(
            "dispatchEvent requires 1 argument: {stmt}"
        )));
    }
    let event_type = parse_expr(args[0].trim())?;

    cursor.skip_ws();
    cursor.consume_byte(b';');
    cursor.skip_ws();
    if !cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "unsupported dispatchEvent statement tail: {stmt}"
        )));
    }

    Ok(Some(Stmt::DispatchEvent { target, event_type }))
}

fn parse_listener_mutation_stmt(stmt: &str) -> Result<Option<Stmt>> {
    let stmt = stmt.trim();
    let mut cursor = Cursor::new(stmt);
    let target = match parse_element_target(&mut cursor) {
        Ok(target) => target,
        Err(_) => return Ok(None),
    };

    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    let Some(method) = cursor.parse_identifier() else {
        return Ok(None);
    };
    let op = match method.as_str() {
        "addEventListener" => ListenerRegistrationOp::Add,
        "removeEventListener" => ListenerRegistrationOp::Remove,
        _ => return Ok(None),
    };
    cursor.skip_ws();
    cursor.expect_byte(b'(')?;
    cursor.skip_ws();
    let event_type = cursor.parse_string_literal()?;
    cursor.skip_ws();
    cursor.expect_byte(b',')?;
    cursor.skip_ws();
    let (params, body, _) = parse_callback(&mut cursor, 1, "callback parameters")?;

    cursor.skip_ws();
    let capture = if cursor.consume_byte(b',') {
        cursor.skip_ws();
        if cursor.consume_ascii("true") {
            true
        } else if cursor.consume_ascii("false") {
            false
        } else {
            return Err(Error::ScriptParse(
                "add/removeEventListener third argument must be true/false".into(),
            ));
        }
    } else {
        false
    };

    cursor.skip_ws();
    cursor.expect_byte(b')')?;
    cursor.skip_ws();
    cursor.consume_byte(b';');
    cursor.skip_ws();
    if !cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "unsupported listener mutation statement tail: {stmt}"
        )));
    }

    let handler = ScriptHandler {
        params,
        stmts: parse_block_statements(&body)?,
    };
    Ok(Some(Stmt::ListenerMutation {
        target,
        op,
        event_type,
        capture,
        handler,
    }))
}

fn parse_event_call_stmt(stmt: &str) -> Option<Stmt> {
    let stmt = stmt.trim();
    let open = stmt.find('(')?;
    let close = stmt.rfind(')')?;
    if close <= open {
        return None;
    }

    let head = stmt[..open].trim();
    let args = stmt[open + 1..close].trim();
    if !args.is_empty() {
        return None;
    }

    let (event_var, method) = head.split_once('.')?;
    if !is_ident(event_var.trim()) {
        return None;
    }

    let method = match method.trim() {
        "preventDefault" => EventMethod::PreventDefault,
        "stopPropagation" => EventMethod::StopPropagation,
        "stopImmediatePropagation" => EventMethod::StopImmediatePropagation,
        _ => return None,
    };

    Some(Stmt::EventCall {
        event_var: event_var.trim().to_string(),
        method,
    })
}

fn parse_expr(src: &str) -> Result<Expr> {
    let src = strip_outer_parens(src.trim());
    if src.is_empty() {
        return Err(Error::ScriptParse("empty expression".into()));
    }

    if let Some(expr) = parse_regex_method_expr(src)? {
        return Ok(expr);
    }

    if let Some((pattern, flags)) = parse_regex_literal_expr(src)? {
        return Ok(Expr::RegexLiteral { pattern, flags });
    }

    if let Some(expr) = parse_new_regexp_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_regexp_static_expr(src)? {
        return Ok(expr);
    }

    if let Some(handler_expr) = parse_function_expr(src)? {
        return Ok(handler_expr);
    }

    parse_comma_expr(src)
}

fn strip_js_comments(src: &str) -> String {
    enum State {
        Normal,
        Single,
        Double,
        Template,
    }

    let bytes = src.as_bytes();
    let mut state = State::Normal;
    let mut i = 0usize;
    let mut out: Vec<u8> = Vec::with_capacity(src.len());

    while i < bytes.len() {
        let b = bytes[i];
        match state {
            State::Normal => {
                if b == b'/' && i + 1 < bytes.len() && bytes[i + 1] == b'/' {
                    i += 2;
                    while i < bytes.len() && bytes[i] != b'\n' {
                        i += 1;
                    }
                    if i < bytes.len() {
                        out.push(b'\n');
                        i += 1;
                    }
                    continue;
                }
                if b == b'/' && i + 1 < bytes.len() && bytes[i + 1] == b'*' {
                    i += 2;
                    while i + 1 < bytes.len() && !(bytes[i] == b'*' && bytes[i + 1] == b'/') {
                        i += 1;
                    }
                    if i + 1 < bytes.len() {
                        i += 2;
                    } else {
                        i = bytes.len();
                    }
                    continue;
                }

                match b {
                    b'\'' => {
                        state = State::Single;
                        out.push(b);
                        i += 1;
                    }
                    b'"' => {
                        state = State::Double;
                        out.push(b);
                        i += 1;
                    }
                    b'`' => {
                        state = State::Template;
                        out.push(b);
                        i += 1;
                    }
                    _ => {
                        out.push(b);
                        i += 1;
                    }
                }
            }
            State::Single => {
                if b == b'\\' {
                    out.push(b);
                    if i + 1 < bytes.len() {
                        out.push(bytes[i + 1]);
                        i += 2;
                    } else {
                        i += 1;
                    }
                    continue;
                }
                out.push(b);
                if b == b'\'' {
                    state = State::Normal;
                }
                i += 1;
            }
            State::Double => {
                if b == b'\\' {
                    out.push(b);
                    if i + 1 < bytes.len() {
                        out.push(bytes[i + 1]);
                        i += 2;
                    } else {
                        i += 1;
                    }
                    continue;
                }
                out.push(b);
                if b == b'"' {
                    state = State::Normal;
                }
                i += 1;
            }
            State::Template => {
                if b == b'\\' {
                    out.push(b);
                    if i + 1 < bytes.len() {
                        out.push(bytes[i + 1]);
                        i += 2;
                    } else {
                        i += 1;
                    }
                    continue;
                }
                out.push(b);
                if b == b'`' {
                    state = State::Normal;
                }
                i += 1;
            }
        }
    }

    String::from_utf8(out).unwrap_or_else(|_| src.to_string())
}

fn parse_comma_expr(src: &str) -> Result<Expr> {
    let src = strip_outer_parens(src.trim());
    let parts = split_top_level_by_char(src, b',');
    if parts.len() == 1 {
        return parse_ternary_expr(src);
    }

    let mut parsed = Vec::with_capacity(parts.len());
    for part in parts {
        let part = part.trim();
        if part.is_empty() {
            return Err(Error::ScriptParse(format!(
                "invalid comma expression: {src}"
            )));
        }
        parsed.push(parse_ternary_expr(part)?);
    }
    Ok(Expr::Comma(parsed))
}

fn parse_ternary_expr(src: &str) -> Result<Expr> {
    let src = strip_outer_parens(src.trim());

    if let Some(q_pos) = find_top_level_ternary_question(src) {
        let cond_src = src[..q_pos].trim();
        let colon_pos = find_matching_ternary_colon(src, q_pos + 1).ok_or_else(|| {
            Error::ScriptParse(format!("invalid ternary expression (missing ':'): {src}"))
        })?;
        let true_src = src[q_pos + 1..colon_pos].trim();
        let false_src = src[colon_pos + 1..].trim();

        return Ok(Expr::Ternary {
            cond: Box::new(parse_ternary_expr(cond_src)?),
            on_true: Box::new(parse_ternary_expr(true_src)?),
            on_false: Box::new(parse_ternary_expr(false_src)?),
        });
    }

    parse_logical_or_expr(src)
}

fn parse_logical_or_expr(src: &str) -> Result<Expr> {
    let src = strip_outer_parens(src.trim());
    let (parts, ops) = split_top_level_by_ops(src, &["||"]);
    if ops.is_empty() {
        return parse_nullish_expr(src);
    }
    fold_binary(parts, ops, parse_nullish_expr, |op| match op {
        "||" => BinaryOp::Or,
        _ => unreachable!(),
    })
}

fn parse_nullish_expr(src: &str) -> Result<Expr> {
    let src = strip_outer_parens(src.trim());
    let (parts, ops) = split_top_level_by_ops(src, &["??"]);
    if ops.is_empty() {
        return parse_logical_and_expr(src);
    }
    fold_binary(parts, ops, parse_logical_and_expr, |op| match op {
        "??" => BinaryOp::Nullish,
        _ => unreachable!(),
    })
}

fn parse_logical_and_expr(src: &str) -> Result<Expr> {
    let src = strip_outer_parens(src.trim());
    let (parts, ops) = split_top_level_by_ops(src, &["&&"]);
    if ops.is_empty() {
        return parse_bitwise_or_expr(src);
    }
    fold_binary(parts, ops, parse_bitwise_or_expr, |op| match op {
        "&&" => BinaryOp::And,
        _ => unreachable!(),
    })
}

fn parse_bitwise_or_expr(src: &str) -> Result<Expr> {
    let src = strip_outer_parens(src.trim());
    let (parts, ops) = split_top_level_by_ops(src, &["|"]);
    if ops.is_empty() {
        return parse_bitwise_xor_expr(src);
    }
    fold_binary(parts, ops, parse_bitwise_xor_expr, |op| match op {
        "|" => BinaryOp::BitOr,
        _ => unreachable!(),
    })
}

fn parse_bitwise_xor_expr(src: &str) -> Result<Expr> {
    let src = strip_outer_parens(src.trim());
    let (parts, ops) = split_top_level_by_ops(src, &["^"]);
    if ops.is_empty() {
        return parse_bitwise_and_expr(src);
    }
    fold_binary(parts, ops, parse_bitwise_and_expr, |op| match op {
        "^" => BinaryOp::BitXor,
        _ => unreachable!(),
    })
}

fn parse_bitwise_and_expr(src: &str) -> Result<Expr> {
    let src = strip_outer_parens(src.trim());
    let (parts, ops) = split_top_level_by_ops(src, &["&"]);
    if ops.is_empty() {
        return parse_equality_expr(src);
    }
    fold_binary(parts, ops, parse_equality_expr, |op| match op {
        "&" => BinaryOp::BitAnd,
        _ => unreachable!(),
    })
}

fn parse_equality_expr(src: &str) -> Result<Expr> {
    let src = strip_outer_parens(src.trim());
    let (parts, ops) = split_top_level_by_ops(src, &["!==", "===", "!=", "=="]);
    if ops.is_empty() {
        return parse_relational_expr(src);
    }
    fold_binary(parts, ops, parse_relational_expr, |op| match op {
        "===" => BinaryOp::StrictEq,
        "!==" => BinaryOp::StrictNe,
        "==" => BinaryOp::Eq,
        "!=" => BinaryOp::Ne,
        _ => unreachable!(),
    })
}

fn parse_relational_expr(src: &str) -> Result<Expr> {
    let src = strip_outer_parens(src.trim());
    let (parts, ops) = split_top_level_by_ops(src, &["<=", ">=", "<", ">", "instanceof", "in"]);
    if ops.is_empty() {
        return parse_shift_expr(src);
    }
    fold_binary(parts, ops, parse_shift_expr, |op| match op {
        "<" => BinaryOp::Lt,
        ">" => BinaryOp::Gt,
        "<=" => BinaryOp::Le,
        ">=" => BinaryOp::Ge,
        "instanceof" => BinaryOp::InstanceOf,
        "in" => BinaryOp::In,
        _ => unreachable!(),
    })
}

fn parse_shift_expr(src: &str) -> Result<Expr> {
    let src = strip_outer_parens(src.trim());
    let (parts, ops) = split_top_level_by_ops(src, &[">>>", "<<", ">>"]);
    if ops.is_empty() {
        return parse_add_expr(src);
    }
    fold_binary(parts, ops, parse_add_expr, |op| match op {
        ">>>" => BinaryOp::UnsignedShiftRight,
        "<<" => BinaryOp::ShiftLeft,
        ">>" => BinaryOp::ShiftRight,
        _ => unreachable!(),
    })
}

fn parse_add_expr(src: &str) -> Result<Expr> {
    let src = strip_outer_parens(src.trim());
    let (parts, ops) = split_top_level_add_sub(src);
    if ops.is_empty() {
        return parse_mul_expr(src);
    }

    if parts.iter().any(|part| part.trim().is_empty()) {
        return Err(Error::ScriptParse(format!(
            "invalid additive expression: {src}"
        )));
    }

    let mut expr = parse_mul_expr(parts[0].trim())?;
    for (idx, op) in ops.iter().enumerate() {
        let rhs = parse_expr(parts[idx + 1].trim())?;
        if *op == '+' {
            expr = append_concat_expr(expr, rhs);
        } else {
            expr = Expr::Binary {
                left: Box::new(expr),
                op: BinaryOp::Sub,
                right: Box::new(rhs),
            };
        }
    }

    Ok(expr)
}

fn append_concat_expr(lhs: Expr, rhs: Expr) -> Expr {
    match lhs {
        Expr::Add(mut parts) => {
            parts.push(rhs);
            Expr::Add(parts)
        }
        other => Expr::Add(vec![other, rhs]),
    }
}

fn split_top_level_add_sub(src: &str) -> (Vec<&str>, Vec<char>) {
    let bytes = src.as_bytes();
    let mut parts = Vec::new();
    let mut ops = Vec::new();
    let mut start = 0usize;

    let mut paren = 0usize;
    let mut bracket = 0usize;
    let mut brace = 0usize;

    #[derive(Clone, Copy, PartialEq, Eq)]
    enum StrState {
        None,
        Single,
        Double,
        Backtick,
    }
    let mut state = StrState::None;

    let mut i = 0usize;
    while i < bytes.len() {
        let b = bytes[i];
        match state {
            StrState::None => match b {
                b'\'' => state = StrState::Single,
                b'"' => state = StrState::Double,
                b'`' => state = StrState::Backtick,
                b'(' => paren += 1,
                b')' => paren = paren.saturating_sub(1),
                b'[' => bracket += 1,
                b']' => bracket = bracket.saturating_sub(1),
                b'{' => brace += 1,
                b'}' => brace = brace.saturating_sub(1),
                b'+' | b'-' if paren == 0 && bracket == 0 && brace == 0 => {
                    if is_add_sub_binary_operator(bytes, i) {
                        if let Some(part) = src.get(start..i) {
                            parts.push(part);
                        }
                        ops.push(b as char);
                        start = i + 1;
                    }
                }
                _ => {}
            },
            StrState::Single => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'\'' {
                    state = StrState::None;
                }
            }
            StrState::Double => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'"' {
                    state = StrState::None;
                }
            }
            StrState::Backtick => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'`' {
                    state = StrState::None;
                }
            }
        }
        i += 1;
    }

    if let Some(part) = src.get(start..) {
        parts.push(part);
    }

    (parts, ops)
}

fn is_add_sub_binary_operator(bytes: &[u8], idx: usize) -> bool {
    if idx >= bytes.len() {
        return false;
    }
    let mut left = idx;
    while left > 0 && bytes[left - 1].is_ascii_whitespace() {
        left -= 1;
    }
    if left == 0 {
        return false;
    }
    let prev = bytes[left - 1];
    !matches!(
        prev,
        b'(' | b'['
            | b'{'
            | b','
            | b'?'
            | b':'
            | b'='
            | b'!'
            | b'<'
            | b'>'
            | b'&'
            | b'|'
            | b'+'
            | b'-'
            | b'*'
            | b'/'
            | b'%'
    )
}

fn parse_mul_expr(src: &str) -> Result<Expr> {
    let trimmed = src.trim();
    let src = strip_outer_parens(trimmed);
    if src.len() != trimmed.len() {
        return parse_expr(src);
    }
    if let Some(expr) = parse_regex_method_expr(src)? {
        return Ok(expr);
    }
    if let Some((pattern, flags)) = parse_regex_literal_expr(src)? {
        return Ok(Expr::RegexLiteral { pattern, flags });
    }
    if src.strip_prefix("yield*").is_some() {
        return parse_pow_expr(src);
    }
    let bytes = src.as_bytes();
    let mut parts = Vec::new();
    let mut ops: Vec<u8> = Vec::new();
    let mut start = 0usize;
    let mut i = 0usize;

    let mut paren = 0usize;
    let mut bracket = 0usize;
    let mut brace = 0usize;

    #[derive(Clone, Copy, PartialEq, Eq)]
    enum StrState {
        None,
        Single,
        Double,
        Backtick,
    }
    let mut state = StrState::None;

    while i < bytes.len() {
        let b = bytes[i];
        match state {
            StrState::None => match b {
                b'\'' => state = StrState::Single,
                b'"' => state = StrState::Double,
                b'`' => state = StrState::Backtick,
                b'(' => paren += 1,
                b')' => paren = paren.saturating_sub(1),
                b'[' => bracket += 1,
                b']' => bracket = bracket.saturating_sub(1),
                b'{' => brace += 1,
                b'}' => brace = brace.saturating_sub(1),
                b'/' | b'%' => {
                    if paren == 0 && bracket == 0 && brace == 0 {
                        if let Some(part) = src.get(start..i) {
                            parts.push(part);
                            ops.push(b);
                            start = i + 1;
                        }
                    }
                }
                b'*' if paren == 0 && bracket == 0 && brace == 0 => {
                    if i + 1 < bytes.len() && bytes[i + 1] == b'*' {
                        i += 1;
                    } else if let Some(part) = src.get(start..i) {
                        parts.push(part);
                        ops.push(b);
                        start = i + 1;
                    }
                }
                _ => {}
            },
            StrState::Single => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'\'' {
                    state = StrState::None;
                }
            }
            StrState::Double => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'"' {
                    state = StrState::None;
                }
            }
            StrState::Backtick => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'`' {
                    state = StrState::None;
                }
            }
        }

        i += 1;
    }

    if let Some(last) = src.get(start..) {
        parts.push(last);
    }

    if ops.is_empty() {
        return parse_pow_expr(src);
    }

    let mut expr = parse_pow_expr(parts[0].trim())?;
    for (idx, op) in ops.iter().enumerate() {
        let rhs = parse_pow_expr(parts[idx + 1].trim())?;
        let op = match op {
            b'/' => BinaryOp::Div,
            b'%' => BinaryOp::Mod,
            _ => BinaryOp::Mul,
        };
        expr = Expr::Binary {
            left: Box::new(expr),
            op,
            right: Box::new(rhs),
        };
    }
    Ok(expr)
}

fn parse_pow_expr(src: &str) -> Result<Expr> {
    let src = strip_outer_parens(src.trim());
    let bytes = src.as_bytes();
    let mut i = 0usize;

    let mut paren = 0usize;
    let mut bracket = 0usize;
    let mut brace = 0usize;

    #[derive(Clone, Copy, PartialEq, Eq)]
    enum StrState {
        None,
        Single,
        Double,
        Backtick,
    }
    let mut state = StrState::None;

    while i < bytes.len() {
        let b = bytes[i];
        match state {
            StrState::None => match b {
                b'\'' => state = StrState::Single,
                b'"' => state = StrState::Double,
                b'`' => state = StrState::Backtick,
                b'(' => paren += 1,
                b')' => paren = paren.saturating_sub(1),
                b'[' => bracket += 1,
                b']' => bracket = bracket.saturating_sub(1),
                b'{' => brace += 1,
                b'}' => brace = brace.saturating_sub(1),
                b'*' if paren == 0 && bracket == 0 && brace == 0 => {
                    if i + 1 < bytes.len() && bytes[i + 1] == b'*' {
                        let left = parse_expr(src[..i].trim())?;
                        let right = parse_pow_expr(src[i + 2..].trim())?;
                        return Ok(Expr::Binary {
                            left: Box::new(left),
                            op: BinaryOp::Pow,
                            right: Box::new(right),
                        });
                    }
                }
                _ => {}
            },
            StrState::Single => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'\'' {
                    state = StrState::None;
                }
            }
            StrState::Double => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'"' {
                    state = StrState::None;
                }
            }
            StrState::Backtick => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'`' {
                    state = StrState::None;
                }
            }
        }
        i += 1;
    }

    parse_unary_expr(src)
}

fn parse_unary_expr(src: &str) -> Result<Expr> {
    let trimmed = src.trim();
    let src = strip_outer_parens(trimmed);
    if src.len() != trimmed.len() {
        return parse_expr(src);
    }
    if let Some(rest) = strip_keyword_operator(src, "await") {
        if rest.is_empty() {
            return Err(Error::ScriptParse(
                "await operator requires an operand".into(),
            ));
        }
        let inner = parse_unary_expr(rest)?;
        return Ok(Expr::Await(Box::new(inner)));
    }
    if let Some(rest) = src.strip_prefix("yield*") {
        let rest = rest.trim_start();
        if rest.is_empty() {
            return Err(Error::ScriptParse(
                "yield* operator requires an operand".into(),
            ));
        }
        let inner = parse_unary_expr(rest)?;
        return Ok(Expr::YieldStar(Box::new(inner)));
    }
    if let Some(rest) = strip_keyword_operator(src, "yield") {
        if rest.is_empty() {
            return Err(Error::ScriptParse(
                "yield operator requires an operand".into(),
            ));
        }
        let inner = parse_unary_expr(rest)?;
        return Ok(Expr::Yield(Box::new(inner)));
    }
    if let Some(rest) = strip_keyword_operator(src, "typeof") {
        let inner = parse_unary_expr(rest)?;
        return Ok(Expr::TypeOf(Box::new(inner)));
    }
    if let Some(rest) = strip_keyword_operator(src, "void") {
        let inner = parse_unary_expr(rest)?;
        return Ok(Expr::Void(Box::new(inner)));
    }
    if let Some(rest) = strip_keyword_operator(src, "delete") {
        let inner = parse_unary_expr(rest)?;
        return Ok(Expr::Delete(Box::new(inner)));
    }
    if let Some(rest) = src.strip_prefix('+') {
        let inner = parse_unary_expr(rest.trim())?;
        return Ok(Expr::Pos(Box::new(inner)));
    }
    if let Some(rest) = src.strip_prefix('-') {
        let inner = parse_unary_expr(rest.trim())?;
        return Ok(Expr::Neg(Box::new(inner)));
    }
    if let Some(rest) = src.strip_prefix('!') {
        let inner = parse_unary_expr(rest.trim())?;
        return Ok(Expr::Not(Box::new(inner)));
    }
    if let Some(rest) = src.strip_prefix('~') {
        let inner = parse_unary_expr(rest.trim())?;
        return Ok(Expr::BitNot(Box::new(inner)));
    }
    parse_primary(src)
}

fn fold_binary<F, G>(parts: Vec<&str>, ops: Vec<&str>, parse_leaf: F, map_op: G) -> Result<Expr>
where
    F: Fn(&str) -> Result<Expr>,
    G: Fn(&str) -> BinaryOp,
{
    if parts.is_empty() {
        return Err(Error::ScriptParse("invalid binary expression".into()));
    }
    let mut expr = parse_leaf(parts[0].trim())?;
    for (idx, op) in ops.iter().enumerate() {
        let rhs = parse_leaf(parts[idx + 1].trim())?;
        expr = Expr::Binary {
            left: Box::new(expr),
            op: map_op(op),
            right: Box::new(rhs),
        };
    }
    Ok(expr)
}

fn parse_primary(src: &str) -> Result<Expr> {
    let src = src.trim();

    if src == "true" {
        return Ok(Expr::Bool(true));
    }
    if src == "false" {
        return Ok(Expr::Bool(false));
    }
    if src == "null" {
        return Ok(Expr::Null);
    }
    if src == "undefined" {
        return Ok(Expr::Undefined);
    }
    if src == "NaN" {
        return Ok(Expr::Float(f64::NAN));
    }
    if src == "Infinity" {
        return Ok(Expr::Float(f64::INFINITY));
    }
    if let Some(numeric) = parse_numeric_literal(src)? {
        return Ok(numeric);
    }

    if src.starts_with('`') && src.ends_with('`') && src.len() >= 2 {
        return parse_template_literal(src);
    }

    if (src.starts_with('\'') && src.ends_with('\''))
        || (src.starts_with('"') && src.ends_with('"'))
    {
        let value = parse_string_literal_exact(src)?;
        return Ok(Expr::String(value));
    }

    if let Some((pattern, flags)) = parse_regex_literal_expr(src)? {
        return Ok(Expr::RegexLiteral { pattern, flags });
    }

    if let Some(expr) = parse_new_date_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_new_regexp_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_new_function_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_new_callee_expr(src)? {
        return Ok(expr);
    }

    if parse_date_now_expr(src)? {
        return Ok(Expr::DateNow);
    }

    if parse_performance_now_expr(src)? {
        return Ok(Expr::PerformanceNow);
    }

    if let Some(value) = parse_date_parse_expr(src)? {
        return Ok(Expr::DateParse(Box::new(value)));
    }

    if let Some(args) = parse_date_utc_expr(src)? {
        return Ok(Expr::DateUtc { args });
    }

    if let Some(expr) = parse_intl_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_string_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_math_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_number_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_bigint_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_array_buffer_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_typed_array_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_promise_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_map_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_set_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_symbol_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_regexp_static_expr(src)? {
        return Ok(expr);
    }

    if let Some(value) = parse_encode_uri_component_expr(src)? {
        return Ok(Expr::EncodeUriComponent(Box::new(value)));
    }

    if let Some(value) = parse_encode_uri_expr(src)? {
        return Ok(Expr::EncodeUri(Box::new(value)));
    }

    if let Some(value) = parse_decode_uri_component_expr(src)? {
        return Ok(Expr::DecodeUriComponent(Box::new(value)));
    }

    if let Some(value) = parse_decode_uri_expr(src)? {
        return Ok(Expr::DecodeUri(Box::new(value)));
    }

    if let Some(value) = parse_escape_expr(src)? {
        return Ok(Expr::Escape(Box::new(value)));
    }

    if let Some(value) = parse_unescape_expr(src)? {
        return Ok(Expr::Unescape(Box::new(value)));
    }

    if let Some(value) = parse_is_nan_expr(src)? {
        return Ok(Expr::IsNaN(Box::new(value)));
    }

    if let Some(value) = parse_is_finite_expr(src)? {
        return Ok(Expr::IsFinite(Box::new(value)));
    }

    if let Some(value) = parse_atob_expr(src)? {
        return Ok(Expr::Atob(Box::new(value)));
    }

    if let Some(value) = parse_btoa_expr(src)? {
        return Ok(Expr::Btoa(Box::new(value)));
    }

    if let Some((value, radix)) = parse_parse_int_expr(src)? {
        return Ok(Expr::ParseInt {
            value: Box::new(value),
            radix: radix.map(Box::new),
        });
    }

    if let Some(value) = parse_parse_float_expr(src)? {
        return Ok(Expr::ParseFloat(Box::new(value)));
    }

    if let Some(value) = parse_json_parse_expr(src)? {
        return Ok(Expr::JsonParse(Box::new(value)));
    }

    if let Some(value) = parse_json_stringify_expr(src)? {
        return Ok(Expr::JsonStringify(Box::new(value)));
    }

    if let Some(entries) = parse_object_literal_expr(src)? {
        return Ok(Expr::ObjectLiteral(entries));
    }

    if let Some(expr) = parse_object_static_expr(src)? {
        return Ok(expr);
    }

    if let Some(value) = parse_structured_clone_expr(src)? {
        return Ok(Expr::StructuredClone(Box::new(value)));
    }

    if let Some(value) = parse_fetch_expr(src)? {
        return Ok(Expr::Fetch(Box::new(value)));
    }

    if let Some(expr) = parse_match_media_expr(src)? {
        return Ok(expr);
    }

    if let Some(value) = parse_alert_expr(src)? {
        return Ok(Expr::Alert(Box::new(value)));
    }

    if let Some(value) = parse_confirm_expr(src)? {
        return Ok(Expr::Confirm(Box::new(value)));
    }

    if let Some((message, default)) = parse_prompt_expr(src)? {
        return Ok(Expr::Prompt {
            message: Box::new(message),
            default: default.map(Box::new),
        });
    }

    if let Some(values) = parse_array_literal_expr(src)? {
        return Ok(Expr::ArrayLiteral(values));
    }

    if let Some(value) = parse_array_is_array_expr(src)? {
        return Ok(Expr::ArrayIsArray(Box::new(value)));
    }

    if let Some(expr) = parse_array_from_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_array_access_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_array_buffer_access_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_typed_array_access_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_map_access_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_set_access_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_promise_method_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_location_method_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_history_method_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_clipboard_method_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_string_method_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_date_method_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_number_method_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_bigint_method_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_intl_format_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_regex_method_expr(src)? {
        return Ok(expr);
    }

    if let Some(tag_name) = parse_document_create_element_expr(src)? {
        return Ok(Expr::CreateElement(tag_name));
    }

    if let Some(text) = parse_document_create_text_node_expr(src)? {
        return Ok(Expr::CreateTextNode(text));
    }

    if parse_document_has_focus_expr(src)? {
        return Ok(Expr::DocumentHasFocus);
    }

    if let Some(handler_expr) = parse_function_expr(src)? {
        return Ok(handler_expr);
    }

    if let Some((handler, delay_ms)) = parse_set_timeout_expr(src)? {
        return Ok(Expr::SetTimeout {
            handler,
            delay_ms: Box::new(delay_ms),
        });
    }

    if let Some((handler, delay_ms)) = parse_set_interval_expr(src)? {
        return Ok(Expr::SetInterval {
            handler,
            delay_ms: Box::new(delay_ms),
        });
    }

    if let Some(callback) = parse_request_animation_frame_expr(src)? {
        return Ok(Expr::RequestAnimationFrame { callback });
    }

    if let Some(handler) = parse_queue_microtask_expr(src)? {
        return Ok(Expr::QueueMicrotask { handler });
    }

    if let Some((target, class_name)) = parse_class_list_contains_expr(src)? {
        return Ok(Expr::ClassListContains { target, class_name });
    }

    if let Some(target) = parse_query_selector_all_length_expr(src)? {
        return Ok(Expr::QuerySelectorAllLength { target });
    }

    if let Some(form) = parse_form_elements_length_expr(src)? {
        return Ok(Expr::FormElementsLength { form });
    }

    if let Some((source, name)) = parse_form_data_get_all_length_expr(src)? {
        return Ok(Expr::FormDataGetAllLength { source, name });
    }

    if let Some((source, name)) = parse_form_data_get_all_expr(src)? {
        return Ok(Expr::FormDataGetAll { source, name });
    }

    if let Some((source, name)) = parse_form_data_get_expr(src)? {
        return Ok(Expr::FormDataGet { source, name });
    }

    if let Some((source, name)) = parse_form_data_has_expr(src)? {
        return Ok(Expr::FormDataHas { source, name });
    }

    if let Some(form) = parse_new_form_data_expr(src)? {
        return Ok(Expr::FormDataNew { form });
    }

    if let Some((target, name)) = parse_get_attribute_expr(src)? {
        return Ok(Expr::DomGetAttribute { target, name });
    }

    if let Some((target, name)) = parse_has_attribute_expr(src)? {
        return Ok(Expr::DomHasAttribute { target, name });
    }

    if let Some((target, selector)) = parse_dom_matches_expr(src)? {
        return Ok(Expr::DomMatches { target, selector });
    }

    if let Some((target, selector)) = parse_dom_closest_expr(src)? {
        return Ok(Expr::DomClosest { target, selector });
    }

    if let Some((target, property)) = parse_dom_computed_style_property_expr(src)? {
        return Ok(Expr::DomComputedStyleProperty { target, property });
    }

    if let Some((event_var, prop)) = parse_event_property_expr(src)? {
        return Ok(Expr::EventProp { event_var, prop });
    }

    if let Some((target, prop)) = parse_dom_access(src)? {
        return Ok(Expr::DomRead { target, prop });
    }

    if let Some(expr) = parse_object_has_own_property_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_object_get_expr(src)? {
        return Ok(expr);
    }

    if let Some(expr) = parse_function_call_expr(src)? {
        return Ok(expr);
    }

    if let Some(target) = parse_element_ref_expr(src)? {
        return Ok(Expr::DomRef(target));
    }

    if is_ident(src) {
        return Ok(Expr::Var(src.to_string()));
    }

    Err(Error::ScriptParse(format!("unsupported expression: {src}")))
}

fn parse_numeric_literal(src: &str) -> Result<Option<Expr>> {
    if src.is_empty() {
        return Ok(None);
    }

    if let Some(value) = parse_bigint_literal(src)? {
        return Ok(Some(value));
    }

    if let Some(value) = parse_prefixed_integer_literal(src, "0x", 16)? {
        return Ok(Some(value));
    }
    if let Some(value) = parse_prefixed_integer_literal(src, "0o", 8)? {
        return Ok(Some(value));
    }
    if let Some(value) = parse_prefixed_integer_literal(src, "0b", 2)? {
        return Ok(Some(value));
    }

    if src.as_bytes().iter().any(|b| matches!(b, b'e' | b'E')) {
        if !matches!(src.as_bytes().first(), Some(b) if b.is_ascii_digit() || *b == b'.') {
            return Ok(None);
        }
        let n: f64 = src
            .parse()
            .map_err(|_| Error::ScriptParse(format!("invalid numeric literal: {src}")))?;
        if !n.is_finite() {
            return Err(Error::ScriptParse(format!(
                "invalid numeric literal: {src}"
            )));
        }
        return Ok(Some(Expr::Float(n)));
    }

    if src.as_bytes().iter().all(|b| b.is_ascii_digit()) {
        let n: i64 = src
            .parse()
            .map_err(|_| Error::ScriptParse(format!("invalid numeric literal: {src}")))?;
        return Ok(Some(Expr::Number(n)));
    }

    let mut dot_count = 0usize;
    for b in src.as_bytes() {
        if *b == b'.' {
            dot_count += 1;
        } else if !b.is_ascii_digit() {
            return Ok(None);
        }
    }

    if dot_count != 1 {
        return Ok(None);
    }
    if src.starts_with('.') || src.ends_with('.') {
        return Ok(None);
    }

    let n: f64 = src
        .parse()
        .map_err(|_| Error::ScriptParse(format!("invalid numeric literal: {src}")))?;
    if !n.is_finite() {
        return Err(Error::ScriptParse(format!(
            "invalid numeric literal: {src}"
        )));
    }
    Ok(Some(Expr::Float(n)))
}

fn parse_bigint_literal(src: &str) -> Result<Option<Expr>> {
    let Some(raw) = src.strip_suffix('n') else {
        return Ok(None);
    };
    if raw.is_empty() || !raw.as_bytes().first().is_some_and(u8::is_ascii_digit) {
        return Ok(None);
    }

    let (digits, radix) =
        if let Some(hex) = raw.strip_prefix("0x").or_else(|| raw.strip_prefix("0X")) {
            (hex, 16u32)
        } else if let Some(octal) = raw.strip_prefix("0o").or_else(|| raw.strip_prefix("0O")) {
            (octal, 8u32)
        } else if let Some(binary) = raw.strip_prefix("0b").or_else(|| raw.strip_prefix("0B")) {
            (binary, 2u32)
        } else {
            if raw.len() > 1 && raw.starts_with('0') {
                return Err(Error::ScriptParse(format!(
                    "invalid numeric literal: {src}"
                )));
            }
            (raw, 10u32)
        };

    if digits.is_empty() {
        return Err(Error::ScriptParse(format!(
            "invalid numeric literal: {src}"
        )));
    }

    let value = JsBigInt::parse_bytes(digits.as_bytes(), radix)
        .ok_or_else(|| Error::ScriptParse(format!("invalid numeric literal: {src}")))?;
    Ok(Some(Expr::BigInt(value)))
}

fn parse_prefixed_integer_literal(src: &str, prefix: &str, radix: u32) -> Result<Option<Expr>> {
    let src = src.to_ascii_lowercase();
    if !src.starts_with(prefix) {
        return Ok(None);
    }

    let digits = &src[prefix.len()..];
    if digits.is_empty() {
        return Err(Error::ScriptParse(format!(
            "invalid numeric literal: {src}"
        )));
    }

    let n = i64::from_str_radix(digits, radix)
        .map_err(|_| Error::ScriptParse(format!("invalid numeric literal: {src}")))?;
    Ok(Some(Expr::Number(n)))
}

fn strip_keyword_operator<'a>(src: &'a str, keyword: &str) -> Option<&'a str> {
    if !src.starts_with(keyword) {
        return None;
    }

    let after = &src[keyword.len()..];
    if after.is_empty() || !is_ident_char(after.as_bytes()[0]) {
        return Some(after.trim_start());
    }

    None
}

fn parse_element_ref_expr(src: &str) -> Result<Option<DomQuery>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();
    let target = match parse_element_target(&mut cursor) {
        Ok(target) => target,
        Err(_) => return Ok(None),
    };
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }
    if matches!(target, DomQuery::Var(_) | DomQuery::DocumentRoot) {
        return Ok(None);
    }
    Ok(Some(target))
}

fn parse_document_create_element_expr(src: &str) -> Result<Option<String>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();
    if !cursor.consume_ascii("document") {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.consume_ascii("createElement") {
        return Ok(None);
    }
    cursor.skip_ws();
    cursor.expect_byte(b'(')?;
    cursor.skip_ws();
    let tag_name = cursor.parse_string_literal()?;
    cursor.skip_ws();
    cursor.expect_byte(b')')?;
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some(tag_name.to_ascii_lowercase()))
}

fn parse_document_create_text_node_expr(src: &str) -> Result<Option<String>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();
    if !cursor.consume_ascii("document") {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.consume_ascii("createTextNode") {
        return Ok(None);
    }
    cursor.skip_ws();
    cursor.expect_byte(b'(')?;
    cursor.skip_ws();
    let text = cursor.parse_string_literal()?;
    cursor.skip_ws();
    cursor.expect_byte(b')')?;
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some(text))
}

fn parse_document_has_focus_expr(src: &str) -> Result<bool> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(false);
        }
        cursor.skip_ws();
    }

    if !cursor.consume_ascii("document") {
        return Ok(false);
    }
    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(false);
    }
    cursor.skip_ws();
    if !cursor.consume_ascii("hasFocus") {
        return Ok(false);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(false);
        }
    }
    cursor.skip_ws();
    let args_src = cursor.read_balanced_block(b'(', b')')?;
    if !args_src.trim().is_empty() {
        return Err(Error::ScriptParse(
            "document.hasFocus takes no arguments".into(),
        ));
    }
    cursor.skip_ws();
    Ok(cursor.eof())
}

fn parse_location_method_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    if !parse_location_base(&mut cursor) {
        return Ok(None);
    }

    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    let Some(method_name) = cursor.parse_identifier() else {
        return Ok(None);
    };
    let method = match method_name.as_str() {
        "assign" => LocationMethod::Assign,
        "reload" => LocationMethod::Reload,
        "replace" => LocationMethod::Replace,
        "toString" => LocationMethod::ToString,
        _ => return Ok(None),
    };

    cursor.skip_ws();
    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let args = split_top_level_by_char(&args_src, b',');
    let args = if args.len() == 1 && args[0].trim().is_empty() {
        Vec::new()
    } else {
        args
    };
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }

    let url = match method {
        LocationMethod::Assign | LocationMethod::Replace => {
            if args.len() != 1 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(format!(
                    "location.{} requires exactly one argument",
                    method_name
                )));
            }
            Some(Box::new(parse_expr(args[0].trim())?))
        }
        LocationMethod::Reload | LocationMethod::ToString => {
            if !args.is_empty() {
                return Err(Error::ScriptParse(format!(
                    "location.{} takes no arguments",
                    method_name
                )));
            }
            None
        }
    };

    Ok(Some(Expr::LocationMethodCall { method, url }))
}

fn parse_location_base(cursor: &mut Cursor<'_>) -> bool {
    let start = cursor.pos();

    if cursor.consume_ascii("location") {
        if cursor.peek().is_none_or(|ch| !is_ident_char(ch)) {
            return true;
        }
        cursor.set_pos(start);
    }

    if cursor.consume_ascii("document") {
        if cursor.peek().is_some_and(is_ident_char) {
            cursor.set_pos(start);
            return false;
        }
        cursor.skip_ws();
        if cursor.consume_byte(b'.') {
            cursor.skip_ws();
            if cursor.consume_ascii("location") && cursor.peek().is_none_or(|ch| !is_ident_char(ch))
            {
                return true;
            }
        }
        cursor.set_pos(start);
    }

    if cursor.consume_ascii("window") {
        if cursor.peek().is_some_and(is_ident_char) {
            cursor.set_pos(start);
            return false;
        }
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            cursor.set_pos(start);
            return false;
        }
        cursor.skip_ws();
        if cursor.consume_ascii("location") && cursor.peek().is_none_or(|ch| !is_ident_char(ch)) {
            return true;
        }
        cursor.set_pos(start);
        if cursor.consume_ascii("window") {
            cursor.skip_ws();
            if !cursor.consume_byte(b'.') {
                cursor.set_pos(start);
                return false;
            }
            cursor.skip_ws();
            if !cursor.consume_ascii("document") {
                cursor.set_pos(start);
                return false;
            }
            cursor.skip_ws();
            if !cursor.consume_byte(b'.') {
                cursor.set_pos(start);
                return false;
            }
            cursor.skip_ws();
            if cursor.consume_ascii("location") && cursor.peek().is_none_or(|ch| !is_ident_char(ch))
            {
                return true;
            }
        }
        cursor.set_pos(start);
    }

    false
}

fn parse_history_method_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    if !parse_history_base(&mut cursor) {
        return Ok(None);
    }

    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    let Some(method_name) = cursor.parse_identifier() else {
        return Ok(None);
    };
    let method = match method_name.as_str() {
        "back" => HistoryMethod::Back,
        "forward" => HistoryMethod::Forward,
        "go" => HistoryMethod::Go,
        "pushState" => HistoryMethod::PushState,
        "replaceState" => HistoryMethod::ReplaceState,
        _ => return Ok(None),
    };

    cursor.skip_ws();
    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let args = split_top_level_by_char(&args_src, b',');
    let args = if args.len() == 1 && args[0].trim().is_empty() {
        Vec::new()
    } else {
        args
    };
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }

    let mut parsed_args = Vec::new();
    match method {
        HistoryMethod::Back | HistoryMethod::Forward => {
            if !args.is_empty() {
                return Err(Error::ScriptParse(format!(
                    "history.{} takes no arguments",
                    method_name
                )));
            }
        }
        HistoryMethod::Go => {
            if args.len() > 1 {
                return Err(Error::ScriptParse(
                    "history.go accepts zero or one argument".into(),
                ));
            }
            if let Some(arg) = args.first() {
                if arg.trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "history.go argument cannot be empty".into(),
                    ));
                }
                parsed_args.push(parse_expr(arg.trim())?);
            }
        }
        HistoryMethod::PushState | HistoryMethod::ReplaceState => {
            if args.len() < 2 || args.len() > 3 {
                return Err(Error::ScriptParse(format!(
                    "history.{} requires 2 or 3 arguments",
                    method_name
                )));
            }
            for arg in args {
                let arg = arg.trim();
                if arg.is_empty() {
                    return Err(Error::ScriptParse(format!(
                        "history.{} arguments cannot be empty",
                        method_name
                    )));
                }
                parsed_args.push(parse_expr(arg)?);
            }
        }
    }

    Ok(Some(Expr::HistoryMethodCall {
        method,
        args: parsed_args,
    }))
}

fn parse_history_base(cursor: &mut Cursor<'_>) -> bool {
    let start = cursor.pos();

    if cursor.consume_ascii("history") {
        if cursor.peek().is_none_or(|ch| !is_ident_char(ch)) {
            return true;
        }
        cursor.set_pos(start);
    }

    if cursor.consume_ascii("window") {
        if cursor.peek().is_some_and(is_ident_char) {
            cursor.set_pos(start);
            return false;
        }
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            cursor.set_pos(start);
            return false;
        }
        cursor.skip_ws();
        if cursor.consume_ascii("history") && cursor.peek().is_none_or(|ch| !is_ident_char(ch)) {
            return true;
        }
    }

    cursor.set_pos(start);
    false
}

fn parse_clipboard_method_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    if !parse_clipboard_base(&mut cursor) {
        return Ok(None);
    }

    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    let Some(method_name) = cursor.parse_identifier() else {
        return Ok(None);
    };
    let method = match method_name.as_str() {
        "readText" => ClipboardMethod::ReadText,
        "writeText" => ClipboardMethod::WriteText,
        _ => return Ok(None),
    };

    cursor.skip_ws();
    if cursor.peek() != Some(b'(') {
        return Ok(None);
    }
    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let args = split_top_level_by_char(&args_src, b',');
    let args = if args.len() == 1 && args[0].trim().is_empty() {
        Vec::new()
    } else {
        args
    };
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }

    let mut parsed_args = Vec::new();
    match method {
        ClipboardMethod::ReadText => {
            if !args.is_empty() {
                return Err(Error::ScriptParse(
                    "navigator.clipboard.readText takes no arguments".into(),
                ));
            }
        }
        ClipboardMethod::WriteText => {
            if args.len() != 1 {
                return Err(Error::ScriptParse(
                    "navigator.clipboard.writeText requires exactly one argument".into(),
                ));
            }
            if args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "navigator.clipboard.writeText argument cannot be empty".into(),
                ));
            }
            parsed_args.push(parse_expr(args[0].trim())?);
        }
    }

    Ok(Some(Expr::ClipboardMethodCall {
        method,
        args: parsed_args,
    }))
}

fn parse_clipboard_base(cursor: &mut Cursor<'_>) -> bool {
    let start = cursor.pos();

    if cursor.consume_ascii("navigator") {
        if cursor.peek().is_some_and(is_ident_char) {
            cursor.set_pos(start);
            return false;
        }
        cursor.skip_ws();
        if cursor.consume_byte(b'.') {
            cursor.skip_ws();
            if cursor.consume_ascii("clipboard")
                && cursor.peek().is_none_or(|ch| !is_ident_char(ch))
            {
                return true;
            }
        }
        cursor.set_pos(start);
    }

    if cursor.consume_ascii("window") {
        if cursor.peek().is_some_and(is_ident_char) {
            cursor.set_pos(start);
            return false;
        }
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            cursor.set_pos(start);
            return false;
        }
        cursor.skip_ws();
        if !cursor.consume_ascii("navigator") || cursor.peek().is_some_and(is_ident_char) {
            cursor.set_pos(start);
            return false;
        }
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            cursor.set_pos(start);
            return false;
        }
        cursor.skip_ws();
        if cursor.consume_ascii("clipboard") && cursor.peek().is_none_or(|ch| !is_ident_char(ch)) {
            return true;
        }
    }

    cursor.set_pos(start);
    false
}

fn parse_new_date_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();
    if !cursor.consume_ascii("new") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();

    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(None);
        }
        cursor.skip_ws();
    }

    if !cursor.consume_ascii("Date") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();

    let args: Vec<String> = if cursor.peek() == Some(b'(') {
        let args_src = cursor.read_balanced_block(b'(', b')')?;
        let raw_args = split_top_level_by_char(&args_src, b',');
        if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args.into_iter().map(|arg| arg.to_string()).collect()
        }
    } else {
        Vec::new()
    };

    if args.len() > 1 {
        return Err(Error::ScriptParse(
            "new Date supports zero or one argument".into(),
        ));
    }

    let value = if args.len() == 1 {
        if args[0].trim().is_empty() {
            return Err(Error::ScriptParse(
                "new Date argument cannot be empty".into(),
            ));
        }
        Some(Box::new(parse_expr(args[0].trim())?))
    } else {
        None
    };

    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }

    Ok(Some(Expr::DateNew { value }))
}

fn parse_regex_literal_expr(src: &str) -> Result<Option<(String, String)>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();
    let Some((pattern, flags)) = parse_regex_literal_from_cursor(&mut cursor)? else {
        return Ok(None);
    };
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some((pattern, flags)))
}

fn parse_regex_literal_from_cursor(cursor: &mut Cursor<'_>) -> Result<Option<(String, String)>> {
    cursor.skip_ws();
    if cursor.peek() != Some(b'/') {
        return Ok(None);
    }
    let start = cursor.i;
    let bytes = cursor.bytes();
    let mut i = cursor.i + 1;
    let mut escaped = false;
    let mut in_class = false;

    while i < bytes.len() {
        let b = bytes[i];
        if escaped {
            escaped = false;
            i += 1;
            continue;
        }
        if b == b'\\' {
            escaped = true;
            i += 1;
            continue;
        }
        if b == b'[' && !in_class {
            in_class = true;
            i += 1;
            continue;
        }
        if b == b']' && in_class {
            in_class = false;
            i += 1;
            continue;
        }
        if b == b'/' && !in_class {
            break;
        }
        if b == b'\n' || b == b'\r' {
            return Err(Error::ScriptParse("unterminated regex literal".into()));
        }
        i += 1;
    }

    if i >= bytes.len() || bytes[i] != b'/' {
        return Err(Error::ScriptParse("unterminated regex literal".into()));
    }

    let pattern = cursor
        .src
        .get(start + 1..i)
        .ok_or_else(|| Error::ScriptParse("invalid regex literal".into()))?
        .to_string();
    i += 1;
    let flags_start = i;
    while i < bytes.len() && bytes[i].is_ascii_alphabetic() {
        i += 1;
    }
    let flags = cursor
        .src
        .get(flags_start..i)
        .ok_or_else(|| Error::ScriptParse("invalid regex flags".into()))?
        .to_string();

    let info = Harness::analyze_regex_flags(&flags).map_err(Error::ScriptParse)?;
    Harness::compile_regex(&pattern, info).map_err(|err| {
        Error::ScriptParse(format!(
            "invalid regular expression: /{pattern}/{flags}: {err}"
        ))
    })?;

    cursor.i = i;
    Ok(Some((pattern, flags)))
}

fn parse_new_regexp_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();
    let Some(expr) = parse_new_regexp_expr_from_cursor(&mut cursor)? else {
        return Ok(None);
    };
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some(expr))
}

fn parse_new_regexp_expr_from_cursor(cursor: &mut Cursor<'_>) -> Result<Option<Expr>> {
    let start = cursor.i;
    cursor.skip_ws();
    if cursor.consume_ascii("new") {
        if let Some(next) = cursor.peek() {
            if is_ident_char(next) {
                cursor.i = start;
                return Ok(None);
            }
        }
        cursor.skip_ws();
    }

    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            cursor.i = start;
            return Ok(None);
        }
        cursor.skip_ws();
    }

    if !cursor.consume_ascii("RegExp") {
        cursor.i = start;
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            cursor.i = start;
            return Ok(None);
        }
    }
    cursor.skip_ws();
    if cursor.peek() != Some(b'(') {
        cursor.i = start;
        return Ok(None);
    }
    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let raw_args = split_top_level_by_char(&args_src, b',');
    let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
        Vec::new()
    } else {
        raw_args
    };

    if args.len() > 2 {
        return Err(Error::ScriptParse(
            "RegExp supports up to two arguments".into(),
        ));
    }
    if !args.is_empty() && args[0].trim().is_empty() {
        return Err(Error::ScriptParse(
            "RegExp pattern argument cannot be empty".into(),
        ));
    }
    if args.len() == 2 && args[1].trim().is_empty() {
        return Err(Error::ScriptParse(
            "RegExp flags argument cannot be empty".into(),
        ));
    }

    let pattern = if args.is_empty() {
        Box::new(Expr::String(String::new()))
    } else {
        Box::new(parse_expr(args[0].trim())?)
    };
    let flags = if args.len() == 2 {
        Some(Box::new(parse_expr(args[1].trim())?))
    } else {
        None
    };

    Ok(Some(Expr::RegexNew { pattern, flags }))
}

fn parse_regexp_static_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(None);
        }
        cursor.skip_ws();
    }

    if !cursor.consume_ascii("RegExp") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();

    if cursor.consume_byte(b'.') {
        cursor.skip_ws();
        let Some(member) = cursor.parse_identifier() else {
            return Ok(None);
        };
        cursor.skip_ws();
        if member != "escape" {
            return Ok(None);
        }

        let args_src = cursor.read_balanced_block(b'(', b')')?;
        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };
        if args.len() != 1 || args[0].trim().is_empty() {
            return Err(Error::ScriptParse(
                "RegExp.escape requires exactly one argument".into(),
            ));
        }
        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::RegExpStaticMethod {
            method: RegExpStaticMethod::Escape,
            args: vec![parse_expr(args[0].trim())?],
        }));
    }

    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some(Expr::RegExpConstructor))
}

fn parse_new_function_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();
    if !cursor.consume_ascii("new") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();

    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(None);
        }
        cursor.skip_ws();
    }

    if !cursor.consume_ascii("Function") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();

    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let raw_args = split_top_level_by_char(&args_src, b',');
    let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
        Vec::new()
    } else {
        raw_args
    };

    if args.is_empty() {
        return Err(Error::ScriptParse(
            "new Function requires at least one argument".into(),
        ));
    }

    let mut parsed = Vec::with_capacity(args.len());
    for arg in args {
        let arg = arg.trim();
        if arg.is_empty() {
            return Err(Error::ScriptParse(
                "new Function arguments cannot be empty".into(),
            ));
        }
        parsed.push(parse_expr(arg)?);
    }

    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }

    Ok(Some(Expr::FunctionConstructor { args: parsed }))
}

fn parse_regex_method_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    let (receiver, receiver_is_identifier) =
        if let Some((pattern, flags)) = parse_regex_literal_from_cursor(&mut cursor)? {
            (Expr::RegexLiteral { pattern, flags }, false)
        } else if let Some(expr) = parse_new_regexp_expr_from_cursor(&mut cursor)? {
            (expr, false)
        } else if let Some(name) = cursor.parse_identifier() {
            (Expr::Var(name), true)
        } else {
            return Ok(None);
        };

    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    let Some(method) = cursor.parse_identifier() else {
        return Ok(None);
    };
    if !matches!(method.as_str(), "test" | "exec" | "toString") {
        return Ok(None);
    }
    cursor.skip_ws();
    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let args = split_top_level_by_char(&args_src, b',');
    let input = match method.as_str() {
        "test" | "exec" => {
            if args.len() != 1 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(format!(
                    "RegExp.{} requires exactly one argument",
                    method
                )));
            }
            Some(Box::new(parse_expr(args[0].trim())?))
        }
        "toString" => {
            if !(args.len() == 1 && args[0].trim().is_empty()) {
                if receiver_is_identifier {
                    return Ok(None);
                }
                return Err(Error::ScriptParse(
                    "RegExp.toString does not take arguments".into(),
                ));
            }
            None
        }
        _ => return Ok(None),
    };

    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }

    let regex = Box::new(receiver);
    match method.as_str() {
        "test" => Ok(Some(Expr::RegexTest {
            regex,
            input: input.expect("validated"),
        })),
        "exec" => Ok(Some(Expr::RegexExec {
            regex,
            input: input.expect("validated"),
        })),
        "toString" => Ok(Some(Expr::RegexToString { regex })),
        _ => Ok(None),
    }
}

fn parse_date_now_expr(src: &str) -> Result<bool> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(false);
        }
        cursor.skip_ws();
    }

    if !cursor.consume_ascii("Date") {
        return Ok(false);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(false);
        }
    }
    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(false);
    }
    cursor.skip_ws();
    if !cursor.consume_ascii("now") {
        return Ok(false);
    }
    cursor.skip_ws();
    cursor.expect_byte(b'(')?;
    cursor.skip_ws();
    cursor.expect_byte(b')')?;
    cursor.skip_ws();
    Ok(cursor.eof())
}

fn parse_performance_now_expr(src: &str) -> Result<bool> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(false);
        }
        cursor.skip_ws();
    }

    if !cursor.consume_ascii("performance") {
        return Ok(false);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(false);
        }
    }
    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(false);
    }
    cursor.skip_ws();
    if !cursor.consume_ascii("now") {
        return Ok(false);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(false);
        }
    }
    cursor.skip_ws();
    cursor.expect_byte(b'(')?;
    cursor.skip_ws();
    cursor.expect_byte(b')')?;
    cursor.skip_ws();
    Ok(cursor.eof())
}

fn parse_date_static_args_expr(src: &str, method: &str) -> Result<Option<Vec<String>>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(None);
        }
        cursor.skip_ws();
    }

    if !cursor.consume_ascii("Date") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();

    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.consume_ascii(method) {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();

    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let args = split_top_level_by_char(&args_src, b',')
        .into_iter()
        .map(|arg| arg.to_string())
        .collect::<Vec<_>>();
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some(args))
}

fn parse_date_parse_expr(src: &str) -> Result<Option<Expr>> {
    let Some(args) = parse_date_static_args_expr(src, "parse")? else {
        return Ok(None);
    };
    if args.len() != 1 || args[0].trim().is_empty() {
        return Err(Error::ScriptParse(
            "Date.parse requires exactly one argument".into(),
        ));
    }
    Ok(Some(parse_expr(args[0].trim())?))
}

fn parse_date_utc_expr(src: &str) -> Result<Option<Vec<Expr>>> {
    let Some(args) = parse_date_static_args_expr(src, "UTC")? else {
        return Ok(None);
    };

    if args.len() < 2 || args.len() > 7 {
        return Err(Error::ScriptParse(
            "Date.UTC requires between 2 and 7 arguments".into(),
        ));
    }

    let mut out = Vec::with_capacity(args.len());
    for arg in args {
        if arg.trim().is_empty() {
            return Err(Error::ScriptParse(
                "Date.UTC argument cannot be empty".into(),
            ));
        }
        out.push(parse_expr(arg.trim())?);
    }
    Ok(Some(out))
}

fn parse_intl_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    let mut called_with_new = false;
    if cursor.consume_ascii("new") {
        if let Some(next) = cursor.peek() {
            if is_ident_char(next) {
                return Ok(None);
            }
        }
        called_with_new = true;
        cursor.skip_ws();
    }

    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(None);
        }
        cursor.skip_ws();
    }

    if !cursor.consume_ascii("Intl") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();

    if called_with_new && cursor.peek() == Some(b'(') {
        let args_src = cursor.read_balanced_block(b'(', b')')?;
        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };
        let mut parsed = Vec::with_capacity(args.len());
        for arg in args {
            let arg = arg.trim();
            if arg.is_empty() {
                return Err(Error::ScriptParse(
                    "Intl constructor argument cannot be empty".into(),
                ));
            }
            parsed.push(parse_expr(arg)?);
        }
        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::IntlConstruct { args: parsed }));
    }

    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    let Some(member) = cursor.parse_identifier() else {
        return Ok(None);
    };
    cursor.skip_ws();

    if member == "Collator" {
        if called_with_new && cursor.eof() {
            return Ok(Some(Expr::IntlFormatterConstruct {
                kind: IntlFormatterKind::Collator,
                locales: None,
                options: None,
                called_with_new: true,
            }));
        }

        if cursor.consume_byte(b'.') {
            cursor.skip_ws();
            let Some(collator_member) = cursor.parse_identifier() else {
                return Ok(None);
            };
            cursor.skip_ws();

            if collator_member == "prototype" {
                if !cursor.consume_byte(b'[') {
                    return Ok(None);
                }
                cursor.skip_ws();
                if !cursor.consume_ascii("Symbol") {
                    return Ok(None);
                }
                cursor.skip_ws();
                if !cursor.consume_byte(b'.') {
                    return Ok(None);
                }
                cursor.skip_ws();
                if !cursor.consume_ascii("toStringTag") {
                    return Ok(None);
                }
                if let Some(next) = cursor.peek() {
                    if is_ident_char(next) {
                        return Ok(None);
                    }
                }
                cursor.skip_ws();
                cursor.expect_byte(b']')?;
                cursor.skip_ws();
                if !cursor.eof() {
                    return Ok(None);
                }
                return Ok(Some(Expr::String("Intl.Collator".to_string())));
            }

            if collator_member == "supportedLocalesOf" {
                if cursor.peek() != Some(b'(') {
                    return Ok(None);
                }
                let args_src = cursor.read_balanced_block(b'(', b')')?;
                let raw_args = split_top_level_by_char(&args_src, b',');
                let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
                    Vec::new()
                } else {
                    raw_args
                };
                if args.is_empty() || args.len() > 2 || args[0].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "Intl.Collator.supportedLocalesOf requires locales and optional options"
                            .into(),
                    ));
                }
                if args.len() == 2 && args[1].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "Intl.Collator.supportedLocalesOf options cannot be empty".into(),
                    ));
                }
                let mut parsed = Vec::with_capacity(args.len());
                parsed.push(parse_expr(args[0].trim())?);
                if args.len() == 2 {
                    parsed.push(parse_expr(args[1].trim())?);
                }
                cursor.skip_ws();
                if !cursor.eof() {
                    return Ok(None);
                }
                return Ok(Some(Expr::IntlStaticMethod {
                    method: IntlStaticMethod::CollatorSupportedLocalesOf,
                    args: parsed,
                }));
            }

            return Ok(None);
        }

        if cursor.peek() != Some(b'(') {
            return Ok(None);
        }

        let args_src = cursor.read_balanced_block(b'(', b')')?;
        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };
        if args.len() > 2 {
            return Err(Error::ScriptParse(
                "Intl.Collator supports up to two arguments".into(),
            ));
        }
        if args.iter().any(|arg| arg.trim().is_empty()) {
            return Err(Error::ScriptParse(
                "Intl.Collator argument cannot be empty".into(),
            ));
        }
        let locales = args
            .first()
            .map(|value| parse_expr(value.trim()))
            .transpose()?
            .map(Box::new);
        let options = args
            .get(1)
            .map(|value| parse_expr(value.trim()))
            .transpose()?
            .map(Box::new);
        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::IntlFormatterConstruct {
            kind: IntlFormatterKind::Collator,
            locales,
            options,
            called_with_new,
        }));
    }

    if member == "DateTimeFormat" {
        if called_with_new && cursor.eof() {
            return Ok(Some(Expr::IntlFormatterConstruct {
                kind: IntlFormatterKind::DateTimeFormat,
                locales: None,
                options: None,
                called_with_new: true,
            }));
        }

        if cursor.consume_byte(b'.') {
            cursor.skip_ws();
            let Some(dtf_member) = cursor.parse_identifier() else {
                return Ok(None);
            };
            cursor.skip_ws();

            if dtf_member == "prototype" {
                if !cursor.consume_byte(b'[') {
                    return Ok(None);
                }
                cursor.skip_ws();
                if !cursor.consume_ascii("Symbol") {
                    return Ok(None);
                }
                cursor.skip_ws();
                if !cursor.consume_byte(b'.') {
                    return Ok(None);
                }
                cursor.skip_ws();
                if !cursor.consume_ascii("toStringTag") {
                    return Ok(None);
                }
                if let Some(next) = cursor.peek() {
                    if is_ident_char(next) {
                        return Ok(None);
                    }
                }
                cursor.skip_ws();
                cursor.expect_byte(b']')?;
                cursor.skip_ws();
                if !cursor.eof() {
                    return Ok(None);
                }
                return Ok(Some(Expr::String("Intl.DateTimeFormat".to_string())));
            }

            if dtf_member == "supportedLocalesOf" {
                if cursor.peek() != Some(b'(') {
                    return Ok(None);
                }
                let args_src = cursor.read_balanced_block(b'(', b')')?;
                let raw_args = split_top_level_by_char(&args_src, b',');
                let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
                    Vec::new()
                } else {
                    raw_args
                };
                if args.is_empty() || args.len() > 2 || args[0].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "Intl.DateTimeFormat.supportedLocalesOf requires locales and optional options"
                            .into(),
                    ));
                }
                if args.len() == 2 && args[1].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "Intl.DateTimeFormat.supportedLocalesOf options cannot be empty".into(),
                    ));
                }
                let mut parsed = Vec::with_capacity(args.len());
                parsed.push(parse_expr(args[0].trim())?);
                if args.len() == 2 {
                    parsed.push(parse_expr(args[1].trim())?);
                }
                cursor.skip_ws();
                if !cursor.eof() {
                    return Ok(None);
                }
                return Ok(Some(Expr::IntlStaticMethod {
                    method: IntlStaticMethod::DateTimeFormatSupportedLocalesOf,
                    args: parsed,
                }));
            }

            return Ok(None);
        }

        if cursor.peek() != Some(b'(') {
            return Ok(None);
        }

        let args_src = cursor.read_balanced_block(b'(', b')')?;
        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };
        if args.len() > 2 {
            return Err(Error::ScriptParse(
                "Intl.DateTimeFormat supports up to two arguments".into(),
            ));
        }
        if args.iter().any(|arg| arg.trim().is_empty()) {
            return Err(Error::ScriptParse(
                "Intl.DateTimeFormat argument cannot be empty".into(),
            ));
        }
        let locales = args
            .first()
            .map(|value| parse_expr(value.trim()))
            .transpose()?
            .map(Box::new);
        let options = args
            .get(1)
            .map(|value| parse_expr(value.trim()))
            .transpose()?
            .map(Box::new);
        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::IntlFormatterConstruct {
            kind: IntlFormatterKind::DateTimeFormat,
            locales,
            options,
            called_with_new,
        }));
    }

    if member == "DisplayNames" {
        if called_with_new && cursor.eof() {
            return Ok(Some(Expr::IntlFormatterConstruct {
                kind: IntlFormatterKind::DisplayNames,
                locales: None,
                options: None,
                called_with_new: true,
            }));
        }

        if cursor.consume_byte(b'.') {
            cursor.skip_ws();
            let Some(display_names_member) = cursor.parse_identifier() else {
                return Ok(None);
            };
            cursor.skip_ws();

            if display_names_member == "prototype" {
                if !cursor.consume_byte(b'[') {
                    return Ok(None);
                }
                cursor.skip_ws();
                if !cursor.consume_ascii("Symbol") {
                    return Ok(None);
                }
                cursor.skip_ws();
                if !cursor.consume_byte(b'.') {
                    return Ok(None);
                }
                cursor.skip_ws();
                if !cursor.consume_ascii("toStringTag") {
                    return Ok(None);
                }
                if let Some(next) = cursor.peek() {
                    if is_ident_char(next) {
                        return Ok(None);
                    }
                }
                cursor.skip_ws();
                cursor.expect_byte(b']')?;
                cursor.skip_ws();
                if !cursor.eof() {
                    return Ok(None);
                }
                return Ok(Some(Expr::String("Intl.DisplayNames".to_string())));
            }

            if display_names_member == "supportedLocalesOf" {
                if cursor.peek() != Some(b'(') {
                    return Ok(None);
                }
                let args_src = cursor.read_balanced_block(b'(', b')')?;
                let raw_args = split_top_level_by_char(&args_src, b',');
                let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
                    Vec::new()
                } else {
                    raw_args
                };
                if args.is_empty() || args.len() > 2 || args[0].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "Intl.DisplayNames.supportedLocalesOf requires locales and optional options"
                            .into(),
                    ));
                }
                if args.len() == 2 && args[1].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "Intl.DisplayNames.supportedLocalesOf options cannot be empty".into(),
                    ));
                }
                let mut parsed = Vec::with_capacity(args.len());
                parsed.push(parse_expr(args[0].trim())?);
                if args.len() == 2 {
                    parsed.push(parse_expr(args[1].trim())?);
                }
                cursor.skip_ws();
                if !cursor.eof() {
                    return Ok(None);
                }
                return Ok(Some(Expr::IntlStaticMethod {
                    method: IntlStaticMethod::DisplayNamesSupportedLocalesOf,
                    args: parsed,
                }));
            }

            return Ok(None);
        }

        if cursor.peek() != Some(b'(') {
            return Ok(None);
        }

        let args_src = cursor.read_balanced_block(b'(', b')')?;
        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };
        if args.len() > 2 {
            return Err(Error::ScriptParse(
                "Intl.DisplayNames supports up to two arguments".into(),
            ));
        }
        if args.iter().any(|arg| arg.trim().is_empty()) {
            return Err(Error::ScriptParse(
                "Intl.DisplayNames argument cannot be empty".into(),
            ));
        }
        let locales = args
            .first()
            .map(|value| parse_expr(value.trim()))
            .transpose()?
            .map(Box::new);
        let options = args
            .get(1)
            .map(|value| parse_expr(value.trim()))
            .transpose()?
            .map(Box::new);
        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::IntlFormatterConstruct {
            kind: IntlFormatterKind::DisplayNames,
            locales,
            options,
            called_with_new,
        }));
    }

    if member == "DurationFormat" {
        if called_with_new && cursor.eof() {
            return Ok(Some(Expr::IntlFormatterConstruct {
                kind: IntlFormatterKind::DurationFormat,
                locales: None,
                options: None,
                called_with_new: true,
            }));
        }

        if cursor.consume_byte(b'.') {
            cursor.skip_ws();
            let Some(duration_member) = cursor.parse_identifier() else {
                return Ok(None);
            };
            cursor.skip_ws();

            if duration_member == "prototype" {
                if !cursor.consume_byte(b'[') {
                    return Ok(None);
                }
                cursor.skip_ws();
                if !cursor.consume_ascii("Symbol") {
                    return Ok(None);
                }
                cursor.skip_ws();
                if !cursor.consume_byte(b'.') {
                    return Ok(None);
                }
                cursor.skip_ws();
                if !cursor.consume_ascii("toStringTag") {
                    return Ok(None);
                }
                if let Some(next) = cursor.peek() {
                    if is_ident_char(next) {
                        return Ok(None);
                    }
                }
                cursor.skip_ws();
                cursor.expect_byte(b']')?;
                cursor.skip_ws();
                if !cursor.eof() {
                    return Ok(None);
                }
                return Ok(Some(Expr::String("Intl.DurationFormat".to_string())));
            }

            if duration_member == "supportedLocalesOf" {
                if cursor.peek() != Some(b'(') {
                    return Ok(None);
                }
                let args_src = cursor.read_balanced_block(b'(', b')')?;
                let raw_args = split_top_level_by_char(&args_src, b',');
                let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
                    Vec::new()
                } else {
                    raw_args
                };
                if args.is_empty() || args.len() > 2 || args[0].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "Intl.DurationFormat.supportedLocalesOf requires locales and optional options"
                            .into(),
                    ));
                }
                if args.len() == 2 && args[1].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "Intl.DurationFormat.supportedLocalesOf options cannot be empty".into(),
                    ));
                }
                let mut parsed = Vec::with_capacity(args.len());
                parsed.push(parse_expr(args[0].trim())?);
                if args.len() == 2 {
                    parsed.push(parse_expr(args[1].trim())?);
                }
                cursor.skip_ws();
                if !cursor.eof() {
                    return Ok(None);
                }
                return Ok(Some(Expr::IntlStaticMethod {
                    method: IntlStaticMethod::DurationFormatSupportedLocalesOf,
                    args: parsed,
                }));
            }

            return Ok(None);
        }

        if cursor.peek() != Some(b'(') {
            return Ok(None);
        }

        let args_src = cursor.read_balanced_block(b'(', b')')?;
        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };
        if args.len() > 2 {
            return Err(Error::ScriptParse(
                "Intl.DurationFormat supports up to two arguments".into(),
            ));
        }
        if args.iter().any(|arg| arg.trim().is_empty()) {
            return Err(Error::ScriptParse(
                "Intl.DurationFormat argument cannot be empty".into(),
            ));
        }
        let locales = args
            .first()
            .map(|value| parse_expr(value.trim()))
            .transpose()?
            .map(Box::new);
        let options = args
            .get(1)
            .map(|value| parse_expr(value.trim()))
            .transpose()?
            .map(Box::new);
        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::IntlFormatterConstruct {
            kind: IntlFormatterKind::DurationFormat,
            locales,
            options,
            called_with_new,
        }));
    }

    if member == "ListFormat" {
        if called_with_new && cursor.eof() {
            return Ok(Some(Expr::IntlFormatterConstruct {
                kind: IntlFormatterKind::ListFormat,
                locales: None,
                options: None,
                called_with_new: true,
            }));
        }

        if cursor.consume_byte(b'.') {
            cursor.skip_ws();
            let Some(list_member) = cursor.parse_identifier() else {
                return Ok(None);
            };
            cursor.skip_ws();

            if list_member == "prototype" {
                if !cursor.consume_byte(b'[') {
                    return Ok(None);
                }
                cursor.skip_ws();
                if !cursor.consume_ascii("Symbol") {
                    return Ok(None);
                }
                cursor.skip_ws();
                if !cursor.consume_byte(b'.') {
                    return Ok(None);
                }
                cursor.skip_ws();
                if !cursor.consume_ascii("toStringTag") {
                    return Ok(None);
                }
                if let Some(next) = cursor.peek() {
                    if is_ident_char(next) {
                        return Ok(None);
                    }
                }
                cursor.skip_ws();
                cursor.expect_byte(b']')?;
                cursor.skip_ws();
                if !cursor.eof() {
                    return Ok(None);
                }
                return Ok(Some(Expr::String("Intl.ListFormat".to_string())));
            }

            if list_member == "supportedLocalesOf" {
                if cursor.peek() != Some(b'(') {
                    return Ok(None);
                }
                let args_src = cursor.read_balanced_block(b'(', b')')?;
                let raw_args = split_top_level_by_char(&args_src, b',');
                let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
                    Vec::new()
                } else {
                    raw_args
                };
                if args.is_empty() || args.len() > 2 || args[0].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "Intl.ListFormat.supportedLocalesOf requires locales and optional options"
                            .into(),
                    ));
                }
                if args.len() == 2 && args[1].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "Intl.ListFormat.supportedLocalesOf options cannot be empty".into(),
                    ));
                }
                let mut parsed = Vec::with_capacity(args.len());
                parsed.push(parse_expr(args[0].trim())?);
                if args.len() == 2 {
                    parsed.push(parse_expr(args[1].trim())?);
                }
                cursor.skip_ws();
                if !cursor.eof() {
                    return Ok(None);
                }
                return Ok(Some(Expr::IntlStaticMethod {
                    method: IntlStaticMethod::ListFormatSupportedLocalesOf,
                    args: parsed,
                }));
            }

            return Ok(None);
        }

        if cursor.peek() != Some(b'(') {
            return Ok(None);
        }

        let args_src = cursor.read_balanced_block(b'(', b')')?;
        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };
        if args.len() > 2 {
            return Err(Error::ScriptParse(
                "Intl.ListFormat supports up to two arguments".into(),
            ));
        }
        if args.iter().any(|arg| arg.trim().is_empty()) {
            return Err(Error::ScriptParse(
                "Intl.ListFormat argument cannot be empty".into(),
            ));
        }
        let locales = args
            .first()
            .map(|value| parse_expr(value.trim()))
            .transpose()?
            .map(Box::new);
        let options = args
            .get(1)
            .map(|value| parse_expr(value.trim()))
            .transpose()?
            .map(Box::new);
        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::IntlFormatterConstruct {
            kind: IntlFormatterKind::ListFormat,
            locales,
            options,
            called_with_new,
        }));
    }

    if member == "PluralRules" {
        if called_with_new && cursor.eof() {
            return Ok(Some(Expr::IntlFormatterConstruct {
                kind: IntlFormatterKind::PluralRules,
                locales: None,
                options: None,
                called_with_new: true,
            }));
        }

        if cursor.consume_byte(b'.') {
            cursor.skip_ws();
            let Some(plural_rules_member) = cursor.parse_identifier() else {
                return Ok(None);
            };
            cursor.skip_ws();

            if plural_rules_member == "prototype" {
                if !cursor.consume_byte(b'[') {
                    return Ok(None);
                }
                cursor.skip_ws();
                if !cursor.consume_ascii("Symbol") {
                    return Ok(None);
                }
                cursor.skip_ws();
                if !cursor.consume_byte(b'.') {
                    return Ok(None);
                }
                cursor.skip_ws();
                if !cursor.consume_ascii("toStringTag") {
                    return Ok(None);
                }
                if let Some(next) = cursor.peek() {
                    if is_ident_char(next) {
                        return Ok(None);
                    }
                }
                cursor.skip_ws();
                cursor.expect_byte(b']')?;
                cursor.skip_ws();
                if !cursor.eof() {
                    return Ok(None);
                }
                return Ok(Some(Expr::String("Intl.PluralRules".to_string())));
            }

            if plural_rules_member == "supportedLocalesOf" {
                if cursor.peek() != Some(b'(') {
                    return Ok(None);
                }
                let args_src = cursor.read_balanced_block(b'(', b')')?;
                let raw_args = split_top_level_by_char(&args_src, b',');
                let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
                    Vec::new()
                } else {
                    raw_args
                };
                if args.is_empty() || args.len() > 2 || args[0].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "Intl.PluralRules.supportedLocalesOf requires locales and optional options"
                            .into(),
                    ));
                }
                if args.len() == 2 && args[1].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "Intl.PluralRules.supportedLocalesOf options cannot be empty".into(),
                    ));
                }
                let mut parsed = Vec::with_capacity(args.len());
                parsed.push(parse_expr(args[0].trim())?);
                if args.len() == 2 {
                    parsed.push(parse_expr(args[1].trim())?);
                }
                cursor.skip_ws();
                if !cursor.eof() {
                    return Ok(None);
                }
                return Ok(Some(Expr::IntlStaticMethod {
                    method: IntlStaticMethod::PluralRulesSupportedLocalesOf,
                    args: parsed,
                }));
            }

            return Ok(None);
        }

        if cursor.peek() != Some(b'(') {
            return Ok(None);
        }

        let args_src = cursor.read_balanced_block(b'(', b')')?;
        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };
        if args.len() > 2 {
            return Err(Error::ScriptParse(
                "Intl.PluralRules supports up to two arguments".into(),
            ));
        }
        if args.iter().any(|arg| arg.trim().is_empty()) {
            return Err(Error::ScriptParse(
                "Intl.PluralRules argument cannot be empty".into(),
            ));
        }
        let locales = args
            .first()
            .map(|value| parse_expr(value.trim()))
            .transpose()?
            .map(Box::new);
        let options = args
            .get(1)
            .map(|value| parse_expr(value.trim()))
            .transpose()?
            .map(Box::new);
        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::IntlFormatterConstruct {
            kind: IntlFormatterKind::PluralRules,
            locales,
            options,
            called_with_new,
        }));
    }

    if member == "RelativeTimeFormat" {
        if called_with_new && cursor.eof() {
            return Ok(Some(Expr::IntlFormatterConstruct {
                kind: IntlFormatterKind::RelativeTimeFormat,
                locales: None,
                options: None,
                called_with_new: true,
            }));
        }

        if cursor.consume_byte(b'.') {
            cursor.skip_ws();
            let Some(relative_time_member) = cursor.parse_identifier() else {
                return Ok(None);
            };
            cursor.skip_ws();

            if relative_time_member == "prototype" {
                if !cursor.consume_byte(b'[') {
                    return Ok(None);
                }
                cursor.skip_ws();
                if !cursor.consume_ascii("Symbol") {
                    return Ok(None);
                }
                cursor.skip_ws();
                if !cursor.consume_byte(b'.') {
                    return Ok(None);
                }
                cursor.skip_ws();
                if !cursor.consume_ascii("toStringTag") {
                    return Ok(None);
                }
                if let Some(next) = cursor.peek() {
                    if is_ident_char(next) {
                        return Ok(None);
                    }
                }
                cursor.skip_ws();
                cursor.expect_byte(b']')?;
                cursor.skip_ws();
                if !cursor.eof() {
                    return Ok(None);
                }
                return Ok(Some(Expr::String("Intl.RelativeTimeFormat".to_string())));
            }

            if relative_time_member == "supportedLocalesOf" {
                if cursor.peek() != Some(b'(') {
                    return Ok(None);
                }
                let args_src = cursor.read_balanced_block(b'(', b')')?;
                let raw_args = split_top_level_by_char(&args_src, b',');
                let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
                    Vec::new()
                } else {
                    raw_args
                };
                if args.is_empty() || args.len() > 2 || args[0].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "Intl.RelativeTimeFormat.supportedLocalesOf requires locales and optional options"
                            .into(),
                    ));
                }
                if args.len() == 2 && args[1].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "Intl.RelativeTimeFormat.supportedLocalesOf options cannot be empty".into(),
                    ));
                }
                let mut parsed = Vec::with_capacity(args.len());
                parsed.push(parse_expr(args[0].trim())?);
                if args.len() == 2 {
                    parsed.push(parse_expr(args[1].trim())?);
                }
                cursor.skip_ws();
                if !cursor.eof() {
                    return Ok(None);
                }
                return Ok(Some(Expr::IntlStaticMethod {
                    method: IntlStaticMethod::RelativeTimeFormatSupportedLocalesOf,
                    args: parsed,
                }));
            }

            return Ok(None);
        }

        if cursor.peek() != Some(b'(') {
            return Ok(None);
        }

        let args_src = cursor.read_balanced_block(b'(', b')')?;
        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };
        if args.len() > 2 {
            return Err(Error::ScriptParse(
                "Intl.RelativeTimeFormat supports up to two arguments".into(),
            ));
        }
        if args.iter().any(|arg| arg.trim().is_empty()) {
            return Err(Error::ScriptParse(
                "Intl.RelativeTimeFormat argument cannot be empty".into(),
            ));
        }
        let locales = args
            .first()
            .map(|value| parse_expr(value.trim()))
            .transpose()?
            .map(Box::new);
        let options = args
            .get(1)
            .map(|value| parse_expr(value.trim()))
            .transpose()?
            .map(Box::new);
        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::IntlFormatterConstruct {
            kind: IntlFormatterKind::RelativeTimeFormat,
            locales,
            options,
            called_with_new,
        }));
    }

    if member == "Segmenter" {
        if called_with_new && cursor.eof() {
            return Ok(Some(Expr::IntlFormatterConstruct {
                kind: IntlFormatterKind::Segmenter,
                locales: None,
                options: None,
                called_with_new: true,
            }));
        }

        if cursor.consume_byte(b'.') {
            cursor.skip_ws();
            let Some(segmenter_member) = cursor.parse_identifier() else {
                return Ok(None);
            };
            cursor.skip_ws();

            if segmenter_member == "prototype" {
                if !cursor.consume_byte(b'[') {
                    return Ok(None);
                }
                cursor.skip_ws();
                if !cursor.consume_ascii("Symbol") {
                    return Ok(None);
                }
                cursor.skip_ws();
                if !cursor.consume_byte(b'.') {
                    return Ok(None);
                }
                cursor.skip_ws();
                if !cursor.consume_ascii("toStringTag") {
                    return Ok(None);
                }
                if let Some(next) = cursor.peek() {
                    if is_ident_char(next) {
                        return Ok(None);
                    }
                }
                cursor.skip_ws();
                cursor.expect_byte(b']')?;
                cursor.skip_ws();
                if !cursor.eof() {
                    return Ok(None);
                }
                return Ok(Some(Expr::String("Intl.Segmenter".to_string())));
            }

            if segmenter_member == "supportedLocalesOf" {
                if cursor.peek() != Some(b'(') {
                    return Ok(None);
                }
                let args_src = cursor.read_balanced_block(b'(', b')')?;
                let raw_args = split_top_level_by_char(&args_src, b',');
                let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
                    Vec::new()
                } else {
                    raw_args
                };
                if args.is_empty() || args.len() > 2 || args[0].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "Intl.Segmenter.supportedLocalesOf requires locales and optional options"
                            .into(),
                    ));
                }
                if args.len() == 2 && args[1].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "Intl.Segmenter.supportedLocalesOf options cannot be empty".into(),
                    ));
                }
                let mut parsed = Vec::with_capacity(args.len());
                parsed.push(parse_expr(args[0].trim())?);
                if args.len() == 2 {
                    parsed.push(parse_expr(args[1].trim())?);
                }
                cursor.skip_ws();
                if !cursor.eof() {
                    return Ok(None);
                }
                return Ok(Some(Expr::IntlStaticMethod {
                    method: IntlStaticMethod::SegmenterSupportedLocalesOf,
                    args: parsed,
                }));
            }

            return Ok(None);
        }

        if cursor.peek() != Some(b'(') {
            return Ok(None);
        }

        let args_src = cursor.read_balanced_block(b'(', b')')?;
        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };
        if args.len() > 2 {
            return Err(Error::ScriptParse(
                "Intl.Segmenter supports up to two arguments".into(),
            ));
        }
        if args.iter().any(|arg| arg.trim().is_empty()) {
            return Err(Error::ScriptParse(
                "Intl.Segmenter argument cannot be empty".into(),
            ));
        }
        let locales = args
            .first()
            .map(|value| parse_expr(value.trim()))
            .transpose()?
            .map(Box::new);
        let options = args
            .get(1)
            .map(|value| parse_expr(value.trim()))
            .transpose()?
            .map(Box::new);
        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::IntlFormatterConstruct {
            kind: IntlFormatterKind::Segmenter,
            locales,
            options,
            called_with_new,
        }));
    }

    if member == "Locale" {
        if cursor.consume_byte(b'.') {
            cursor.skip_ws();
            let Some(locale_member) = cursor.parse_identifier() else {
                return Ok(None);
            };
            cursor.skip_ws();

            if locale_member == "prototype" {
                if !cursor.consume_byte(b'[') {
                    return Ok(None);
                }
                cursor.skip_ws();
                if !cursor.consume_ascii("Symbol") {
                    return Ok(None);
                }
                cursor.skip_ws();
                if !cursor.consume_byte(b'.') {
                    return Ok(None);
                }
                cursor.skip_ws();
                if !cursor.consume_ascii("toStringTag") {
                    return Ok(None);
                }
                if let Some(next) = cursor.peek() {
                    if is_ident_char(next) {
                        return Ok(None);
                    }
                }
                cursor.skip_ws();
                cursor.expect_byte(b']')?;
                cursor.skip_ws();
                if !cursor.eof() {
                    return Ok(None);
                }
                return Ok(Some(Expr::String("Intl.Locale".to_string())));
            }

            return Ok(None);
        }

        if cursor.peek() != Some(b'(') {
            return Ok(None);
        }

        let args_src = cursor.read_balanced_block(b'(', b')')?;
        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };
        if args.is_empty() || args.len() > 2 || args[0].trim().is_empty() {
            return Err(Error::ScriptParse(
                "Intl.Locale requires a locale identifier and optional options".into(),
            ));
        }
        if args.len() == 2 && args[1].trim().is_empty() {
            return Err(Error::ScriptParse(
                "Intl.Locale options cannot be empty".into(),
            ));
        }
        let tag = Box::new(parse_expr(args[0].trim())?);
        let options = if args.len() == 2 {
            Some(Box::new(parse_expr(args[1].trim())?))
        } else {
            None
        };
        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::IntlLocaleConstruct {
            tag,
            options,
            called_with_new,
        }));
    }

    let intl_formatter_kind = match member.as_str() {
        "NumberFormat" => Some(IntlFormatterKind::NumberFormat),
        _ => None,
    };
    if let Some(kind) = intl_formatter_kind {
        if called_with_new && cursor.eof() {
            return Ok(Some(Expr::IntlFormatterConstruct {
                kind,
                locales: None,
                options: None,
                called_with_new: true,
            }));
        }

        if cursor.peek() != Some(b'(') {
            return Ok(None);
        }

        let args_src = cursor.read_balanced_block(b'(', b')')?;
        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };
        if args.len() > 2 {
            return Err(Error::ScriptParse(format!(
                "Intl.{member} supports up to two arguments"
            )));
        }
        if args.iter().any(|arg| arg.trim().is_empty()) {
            return Err(Error::ScriptParse(format!(
                "Intl.{member} argument cannot be empty"
            )));
        }
        let locales = args
            .first()
            .map(|value| parse_expr(value.trim()))
            .transpose()?
            .map(Box::new);
        let options = args
            .get(1)
            .map(|value| parse_expr(value.trim()))
            .transpose()?
            .map(Box::new);

        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::IntlFormatterConstruct {
            kind,
            locales,
            options,
            called_with_new,
        }));
    }

    if cursor.peek() != Some(b'(') {
        return Ok(None);
    }

    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let raw_args = split_top_level_by_char(&args_src, b',');
    let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
        Vec::new()
    } else {
        raw_args
    };
    let expr = match member.as_str() {
        "getCanonicalLocales" => {
            if args.len() > 1 {
                return Err(Error::ScriptParse(
                    "Intl.getCanonicalLocales supports zero or one argument".into(),
                ));
            }
            if args.len() == 1 && args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Intl.getCanonicalLocales argument cannot be empty".into(),
                ));
            }
            let mut parsed = Vec::new();
            if let Some(arg) = args.first() {
                parsed.push(parse_expr(arg.trim())?);
            }
            Expr::IntlStaticMethod {
                method: IntlStaticMethod::GetCanonicalLocales,
                args: parsed,
            }
        }
        "supportedValuesOf" => {
            if args.len() != 1 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Intl.supportedValuesOf requires exactly one argument".into(),
                ));
            }
            Expr::IntlStaticMethod {
                method: IntlStaticMethod::SupportedValuesOf,
                args: vec![parse_expr(args[0].trim())?],
            }
        }
        _ => return Ok(None),
    };

    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some(expr))
}

fn parse_math_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();
    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(None);
        }
        cursor.skip_ws();
    }
    if !cursor.consume_ascii("Math") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();

    if cursor.consume_byte(b'[') {
        cursor.skip_ws();
        if !cursor.consume_ascii("Symbol") {
            return Ok(None);
        }
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(None);
        }
        cursor.skip_ws();
        if !cursor.consume_ascii("toStringTag") {
            return Ok(None);
        }
        if let Some(next) = cursor.peek() {
            if is_ident_char(next) {
                return Ok(None);
            }
        }
        cursor.skip_ws();
        cursor.expect_byte(b']')?;
        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::MathConst(MathConst::ToStringTag)));
    }

    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    let Some(member) = cursor.parse_identifier() else {
        return Ok(None);
    };
    cursor.skip_ws();

    if cursor.peek() == Some(b'(') {
        let args_src = cursor.read_balanced_block(b'(', b')')?;
        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };

        let Some(method) = parse_math_method_name(&member) else {
            return Ok(None);
        };
        validate_math_arity(method, args.len())?;

        let mut parsed = Vec::with_capacity(args.len());
        for arg in args {
            let arg = arg.trim();
            if arg.is_empty() {
                return Err(Error::ScriptParse(format!(
                    "Math.{} argument cannot be empty",
                    member
                )));
            }
            parsed.push(parse_expr(arg)?);
        }

        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::MathMethod {
            method,
            args: parsed,
        }));
    }

    let Some(constant) = parse_math_const_name(&member) else {
        return Ok(None);
    };

    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some(Expr::MathConst(constant)))
}

fn parse_math_const_name(name: &str) -> Option<MathConst> {
    match name {
        "E" => Some(MathConst::E),
        "LN10" => Some(MathConst::Ln10),
        "LN2" => Some(MathConst::Ln2),
        "LOG10E" => Some(MathConst::Log10E),
        "LOG2E" => Some(MathConst::Log2E),
        "PI" => Some(MathConst::Pi),
        "SQRT1_2" => Some(MathConst::Sqrt1_2),
        "SQRT2" => Some(MathConst::Sqrt2),
        _ => None,
    }
}

fn parse_math_method_name(name: &str) -> Option<MathMethod> {
    match name {
        "abs" => Some(MathMethod::Abs),
        "acos" => Some(MathMethod::Acos),
        "acosh" => Some(MathMethod::Acosh),
        "asin" => Some(MathMethod::Asin),
        "asinh" => Some(MathMethod::Asinh),
        "atan" => Some(MathMethod::Atan),
        "atan2" => Some(MathMethod::Atan2),
        "atanh" => Some(MathMethod::Atanh),
        "cbrt" => Some(MathMethod::Cbrt),
        "ceil" => Some(MathMethod::Ceil),
        "clz32" => Some(MathMethod::Clz32),
        "cos" => Some(MathMethod::Cos),
        "cosh" => Some(MathMethod::Cosh),
        "exp" => Some(MathMethod::Exp),
        "expm1" => Some(MathMethod::Expm1),
        "floor" => Some(MathMethod::Floor),
        "f16round" => Some(MathMethod::F16Round),
        "fround" => Some(MathMethod::FRound),
        "hypot" => Some(MathMethod::Hypot),
        "imul" => Some(MathMethod::Imul),
        "log" => Some(MathMethod::Log),
        "log10" => Some(MathMethod::Log10),
        "log1p" => Some(MathMethod::Log1p),
        "log2" => Some(MathMethod::Log2),
        "max" => Some(MathMethod::Max),
        "min" => Some(MathMethod::Min),
        "pow" => Some(MathMethod::Pow),
        "random" => Some(MathMethod::Random),
        "round" => Some(MathMethod::Round),
        "sign" => Some(MathMethod::Sign),
        "sin" => Some(MathMethod::Sin),
        "sinh" => Some(MathMethod::Sinh),
        "sqrt" => Some(MathMethod::Sqrt),
        "sumPrecise" => Some(MathMethod::SumPrecise),
        "tan" => Some(MathMethod::Tan),
        "tanh" => Some(MathMethod::Tanh),
        "trunc" => Some(MathMethod::Trunc),
        _ => None,
    }
}

fn validate_math_arity(method: MathMethod, count: usize) -> Result<()> {
    let method_name = match method {
        MathMethod::Abs => "abs",
        MathMethod::Acos => "acos",
        MathMethod::Acosh => "acosh",
        MathMethod::Asin => "asin",
        MathMethod::Asinh => "asinh",
        MathMethod::Atan => "atan",
        MathMethod::Atan2 => "atan2",
        MathMethod::Atanh => "atanh",
        MathMethod::Cbrt => "cbrt",
        MathMethod::Ceil => "ceil",
        MathMethod::Clz32 => "clz32",
        MathMethod::Cos => "cos",
        MathMethod::Cosh => "cosh",
        MathMethod::Exp => "exp",
        MathMethod::Expm1 => "expm1",
        MathMethod::Floor => "floor",
        MathMethod::F16Round => "f16round",
        MathMethod::FRound => "fround",
        MathMethod::Hypot => "hypot",
        MathMethod::Imul => "imul",
        MathMethod::Log => "log",
        MathMethod::Log10 => "log10",
        MathMethod::Log1p => "log1p",
        MathMethod::Log2 => "log2",
        MathMethod::Max => "max",
        MathMethod::Min => "min",
        MathMethod::Pow => "pow",
        MathMethod::Random => "random",
        MathMethod::Round => "round",
        MathMethod::Sign => "sign",
        MathMethod::Sin => "sin",
        MathMethod::Sinh => "sinh",
        MathMethod::Sqrt => "sqrt",
        MathMethod::SumPrecise => "sumPrecise",
        MathMethod::Tan => "tan",
        MathMethod::Tanh => "tanh",
        MathMethod::Trunc => "trunc",
    };

    let valid = match method {
        MathMethod::Random => count == 0,
        MathMethod::Atan2 | MathMethod::Imul | MathMethod::Pow => count == 2,
        MathMethod::Hypot | MathMethod::Max | MathMethod::Min => true,
        MathMethod::SumPrecise => count == 1,
        _ => count == 1,
    };

    if valid {
        return Ok(());
    }

    let message = match method {
        MathMethod::Random => format!("Math.{method_name} does not take arguments"),
        MathMethod::Atan2 | MathMethod::Imul | MathMethod::Pow => {
            format!("Math.{method_name} requires exactly two arguments")
        }
        MathMethod::SumPrecise => format!("Math.{method_name} requires exactly one argument"),
        _ => format!("Math.{method_name} requires exactly one argument"),
    };
    Err(Error::ScriptParse(message))
}

fn parse_string_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    let mut called_with_new = false;
    if cursor.consume_ascii("new") {
        if let Some(next) = cursor.peek() {
            if is_ident_char(next) {
                return Ok(None);
            }
        }
        called_with_new = true;
        cursor.skip_ws();
    }

    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(None);
        }
        cursor.skip_ws();
    }

    if !cursor.consume_ascii("String") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();

    if cursor.peek() == Some(b'(') {
        let args_src = cursor.read_balanced_block(b'(', b')')?;
        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };
        if args.len() > 1 {
            return Err(Error::ScriptParse(
                "String supports zero or one argument".into(),
            ));
        }
        let value = if let Some(arg) = args.first() {
            let arg = arg.trim();
            if arg.is_empty() {
                return Err(Error::ScriptParse("String argument cannot be empty".into()));
            }
            Some(Box::new(parse_expr(arg)?))
        } else {
            None
        };
        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::StringConstruct {
            value,
            called_with_new,
        }));
    }

    if called_with_new {
        cursor.skip_ws();
        if cursor.eof() {
            return Ok(Some(Expr::StringConstruct {
                value: None,
                called_with_new: true,
            }));
        }
        return Ok(None);
    }

    if cursor.consume_byte(b'.') {
        cursor.skip_ws();
        let Some(member) = cursor.parse_identifier() else {
            return Ok(None);
        };
        cursor.skip_ws();
        if cursor.peek() != Some(b'(') {
            return Ok(None);
        }
        let args_src = cursor.read_balanced_block(b'(', b')')?;
        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };

        let method = match member.as_str() {
            "fromCharCode" => StringStaticMethod::FromCharCode,
            "fromCodePoint" => StringStaticMethod::FromCodePoint,
            "raw" => StringStaticMethod::Raw,
            _ => return Ok(None),
        };

        if matches!(method, StringStaticMethod::Raw) && args.is_empty() {
            return Err(Error::ScriptParse(
                "String.raw requires at least one argument".into(),
            ));
        }

        let mut parsed = Vec::with_capacity(args.len());
        for arg in args {
            let arg = arg.trim();
            if arg.is_empty() {
                return Err(Error::ScriptParse(format!(
                    "String.{member} argument cannot be empty"
                )));
            }
            parsed.push(parse_expr(arg)?);
        }
        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::StringStaticMethod {
            method,
            args: parsed,
        }));
    }

    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some(Expr::StringConstructor))
}

fn parse_number_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    let mut has_new = false;
    if cursor.consume_ascii("new") {
        if let Some(next) = cursor.peek() {
            if is_ident_char(next) {
                return Ok(None);
            }
        }
        has_new = true;
        cursor.skip_ws();
    }

    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(None);
        }
        cursor.skip_ws();
    }

    if !cursor.consume_ascii("Number") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();

    if has_new && cursor.peek() != Some(b'(') {
        cursor.skip_ws();
        if cursor.eof() {
            return Ok(Some(Expr::NumberConstruct { value: None }));
        }
        return Ok(None);
    }

    if cursor.peek() == Some(b'(') {
        let args_src = cursor.read_balanced_block(b'(', b')')?;
        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };
        if args.len() > 1 {
            return Err(Error::ScriptParse(
                "Number supports zero or one argument".into(),
            ));
        }
        let value = if let Some(arg) = args.first() {
            let arg = arg.trim();
            if arg.is_empty() {
                return Err(Error::ScriptParse("Number argument cannot be empty".into()));
            }
            Some(Box::new(parse_expr(arg)?))
        } else {
            None
        };
        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::NumberConstruct { value }));
    }

    if has_new {
        return Ok(None);
    }

    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    let Some(member) = cursor.parse_identifier() else {
        return Ok(None);
    };
    cursor.skip_ws();

    if cursor.peek() == Some(b'(') {
        let Some(method) = parse_number_method_name(&member) else {
            return Ok(None);
        };

        let args_src = cursor.read_balanced_block(b'(', b')')?;
        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };

        let parsed = match method {
            NumberMethod::IsFinite
            | NumberMethod::IsInteger
            | NumberMethod::IsNaN
            | NumberMethod::IsSafeInteger
            | NumberMethod::ParseFloat => {
                if args.len() != 1 || args[0].trim().is_empty() {
                    return Err(Error::ScriptParse(format!(
                        "Number.{member} requires exactly one argument"
                    )));
                }
                vec![parse_expr(args[0].trim())?]
            }
            NumberMethod::ParseInt => {
                if args.is_empty() || args.len() > 2 || args[0].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "Number.parseInt requires one or two arguments".into(),
                    ));
                }
                if args.len() == 2 && args[1].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "Number.parseInt radix argument cannot be empty".into(),
                    ));
                }
                let mut parsed = Vec::with_capacity(args.len());
                parsed.push(parse_expr(args[0].trim())?);
                if args.len() == 2 {
                    parsed.push(parse_expr(args[1].trim())?);
                }
                parsed
            }
        };

        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::NumberMethod {
            method,
            args: parsed,
        }));
    }

    let Some(constant) = parse_number_const_name(&member) else {
        return Ok(None);
    };
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some(Expr::NumberConst(constant)))
}

fn parse_number_const_name(name: &str) -> Option<NumberConst> {
    match name {
        "EPSILON" => Some(NumberConst::Epsilon),
        "MAX_SAFE_INTEGER" => Some(NumberConst::MaxSafeInteger),
        "MAX_VALUE" => Some(NumberConst::MaxValue),
        "MIN_SAFE_INTEGER" => Some(NumberConst::MinSafeInteger),
        "MIN_VALUE" => Some(NumberConst::MinValue),
        "NaN" => Some(NumberConst::NaN),
        "NEGATIVE_INFINITY" => Some(NumberConst::NegativeInfinity),
        "POSITIVE_INFINITY" => Some(NumberConst::PositiveInfinity),
        _ => None,
    }
}

fn parse_number_method_name(name: &str) -> Option<NumberMethod> {
    match name {
        "isFinite" => Some(NumberMethod::IsFinite),
        "isInteger" => Some(NumberMethod::IsInteger),
        "isNaN" => Some(NumberMethod::IsNaN),
        "isSafeInteger" => Some(NumberMethod::IsSafeInteger),
        "parseFloat" => Some(NumberMethod::ParseFloat),
        "parseInt" => Some(NumberMethod::ParseInt),
        _ => None,
    }
}

fn parse_bigint_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    let mut called_with_new = false;
    if cursor.consume_ascii("new") {
        if let Some(next) = cursor.peek() {
            if is_ident_char(next) {
                return Ok(None);
            }
        }
        called_with_new = true;
        cursor.skip_ws();
    }

    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(None);
        }
        cursor.skip_ws();
    }

    if !cursor.consume_ascii("BigInt") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();

    if cursor.peek() == Some(b'(') {
        let args_src = cursor.read_balanced_block(b'(', b')')?;
        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };
        if args.len() > 1 {
            return Err(Error::ScriptParse(
                "BigInt supports zero or one argument".into(),
            ));
        }
        let value = if let Some(arg) = args.first() {
            let arg = arg.trim();
            if arg.is_empty() {
                return Err(Error::ScriptParse("BigInt argument cannot be empty".into()));
            }
            Some(Box::new(parse_expr(arg)?))
        } else {
            None
        };
        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::BigIntConstruct {
            value,
            called_with_new,
        }));
    }

    if called_with_new {
        return Ok(None);
    }

    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    let Some(member) = cursor.parse_identifier() else {
        return Ok(None);
    };
    cursor.skip_ws();
    if cursor.peek() != Some(b'(') {
        return Ok(None);
    }

    let Some(method) = parse_bigint_method_name(&member) else {
        return Ok(None);
    };
    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let raw_args = split_top_level_by_char(&args_src, b',');
    let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
        Vec::new()
    } else {
        raw_args
    };
    if args.len() != 2 || args[0].trim().is_empty() || args[1].trim().is_empty() {
        return Err(Error::ScriptParse(format!(
            "BigInt.{member} requires exactly two arguments"
        )));
    }

    let parsed = vec![parse_expr(args[0].trim())?, parse_expr(args[1].trim())?];
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some(Expr::BigIntMethod {
        method,
        args: parsed,
    }))
}

fn parse_bigint_method_name(name: &str) -> Option<BigIntMethod> {
    match name {
        "asIntN" => Some(BigIntMethod::AsIntN),
        "asUintN" => Some(BigIntMethod::AsUintN),
        _ => None,
    }
}

fn parse_typed_array_kind_name(name: &str) -> Option<TypedArrayKind> {
    match name {
        "Int8Array" => Some(TypedArrayKind::Int8),
        "Uint8Array" => Some(TypedArrayKind::Uint8),
        "Uint8ClampedArray" => Some(TypedArrayKind::Uint8Clamped),
        "Int16Array" => Some(TypedArrayKind::Int16),
        "Uint16Array" => Some(TypedArrayKind::Uint16),
        "Int32Array" => Some(TypedArrayKind::Int32),
        "Uint32Array" => Some(TypedArrayKind::Uint32),
        "Float16Array" => Some(TypedArrayKind::Float16),
        "Float32Array" => Some(TypedArrayKind::Float32),
        "Float64Array" => Some(TypedArrayKind::Float64),
        "BigInt64Array" => Some(TypedArrayKind::BigInt64),
        "BigUint64Array" => Some(TypedArrayKind::BigUint64),
        _ => None,
    }
}

fn parse_typed_array_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    let mut called_with_new = false;
    if cursor.consume_ascii("new") {
        if let Some(next) = cursor.peek() {
            if is_ident_char(next) {
                return Ok(None);
            }
        }
        called_with_new = true;
        cursor.skip_ws();
    }

    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(None);
        }
        cursor.skip_ws();
    }

    let Some(constructor_name) = cursor.parse_identifier() else {
        return Ok(None);
    };
    let Some(kind) = parse_typed_array_kind_name(&constructor_name) else {
        return Ok(None);
    };
    cursor.skip_ws();

    if cursor.peek() == Some(b'(') {
        let args_src = cursor.read_balanced_block(b'(', b')')?;
        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };
        let mut parsed = Vec::with_capacity(args.len());
        for arg in args {
            let arg = arg.trim();
            if arg.is_empty() {
                return Err(Error::ScriptParse(format!(
                    "{} argument cannot be empty",
                    constructor_name
                )));
            }
            parsed.push(parse_expr(arg)?);
        }
        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::TypedArrayConstruct {
            kind,
            args: parsed,
            called_with_new,
        }));
    }

    if called_with_new {
        cursor.skip_ws();
        if cursor.eof() {
            return Ok(Some(Expr::TypedArrayConstruct {
                kind,
                args: Vec::new(),
                called_with_new: true,
            }));
        }
        return Ok(None);
    }

    if cursor.consume_byte(b'.') {
        cursor.skip_ws();
        let Some(member) = cursor.parse_identifier() else {
            return Ok(None);
        };
        cursor.skip_ws();

        if member == "BYTES_PER_ELEMENT" {
            if !cursor.eof() {
                return Ok(None);
            }
            return Ok(Some(Expr::TypedArrayStaticBytesPerElement(kind)));
        }

        if cursor.peek() != Some(b'(') {
            return Ok(None);
        }
        let args_src = cursor.read_balanced_block(b'(', b')')?;
        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };
        let method = match member.as_str() {
            "from" => TypedArrayStaticMethod::From,
            "of" => TypedArrayStaticMethod::Of,
            _ => return Ok(None),
        };
        if matches!(method, TypedArrayStaticMethod::From)
            && (args.len() != 1 || args[0].trim().is_empty())
        {
            return Err(Error::ScriptParse(format!(
                "{}.from requires exactly one argument",
                constructor_name
            )));
        }
        let mut parsed = Vec::with_capacity(args.len());
        for arg in args {
            let arg = arg.trim();
            if arg.is_empty() {
                return Err(Error::ScriptParse(format!(
                    "{}.{} argument cannot be empty",
                    constructor_name, member
                )));
            }
            parsed.push(parse_expr(arg)?);
        }
        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::TypedArrayStaticMethod {
            kind,
            method,
            args: parsed,
        }));
    }

    if !cursor.eof() {
        return Ok(None);
    }

    Ok(Some(Expr::TypedArrayConstructorRef(
        TypedArrayConstructorKind::Concrete(kind),
    )))
}

fn parse_promise_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    let mut called_with_new = false;
    if cursor.consume_ascii("new") {
        if let Some(next) = cursor.peek() {
            if is_ident_char(next) {
                return Ok(None);
            }
        }
        called_with_new = true;
        cursor.skip_ws();
    }

    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(None);
        }
        cursor.skip_ws();
    }

    if !cursor.consume_ascii("Promise") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();

    if cursor.peek() == Some(b'(') {
        let args_src = cursor.read_balanced_block(b'(', b')')?;
        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };
        if args.len() > 1 {
            return Err(Error::ScriptParse(
                "Promise supports exactly one executor argument".into(),
            ));
        }
        let executor = if let Some(first) = args.first() {
            let first = first.trim();
            if first.is_empty() {
                return Err(Error::ScriptParse(
                    "Promise executor argument cannot be empty".into(),
                ));
            }
            Some(Box::new(parse_expr(first)?))
        } else {
            None
        };
        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::PromiseConstruct {
            executor,
            called_with_new,
        }));
    }

    if called_with_new {
        cursor.skip_ws();
        if cursor.eof() {
            return Ok(Some(Expr::PromiseConstruct {
                executor: None,
                called_with_new: true,
            }));
        }
        return Ok(None);
    }

    if cursor.consume_byte(b'.') {
        cursor.skip_ws();
        let Some(member) = cursor.parse_identifier() else {
            return Ok(None);
        };
        cursor.skip_ws();
        if cursor.peek() != Some(b'(') {
            return Ok(None);
        }
        let args_src = cursor.read_balanced_block(b'(', b')')?;
        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };

        let method = match member.as_str() {
            "resolve" => {
                if args.len() > 1 {
                    return Err(Error::ScriptParse(
                        "Promise.resolve supports zero or one argument".into(),
                    ));
                }
                PromiseStaticMethod::Resolve
            }
            "reject" => {
                if args.len() > 1 {
                    return Err(Error::ScriptParse(
                        "Promise.reject supports zero or one argument".into(),
                    ));
                }
                PromiseStaticMethod::Reject
            }
            "all" => {
                if args.len() != 1 || args[0].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "Promise.all requires exactly one argument".into(),
                    ));
                }
                PromiseStaticMethod::All
            }
            "allSettled" => {
                if args.len() != 1 || args[0].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "Promise.allSettled requires exactly one argument".into(),
                    ));
                }
                PromiseStaticMethod::AllSettled
            }
            "any" => {
                if args.len() != 1 || args[0].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "Promise.any requires exactly one argument".into(),
                    ));
                }
                PromiseStaticMethod::Any
            }
            "race" => {
                if args.len() != 1 || args[0].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "Promise.race requires exactly one argument".into(),
                    ));
                }
                PromiseStaticMethod::Race
            }
            "try" => {
                if args.is_empty() || args[0].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "Promise.try requires at least one argument".into(),
                    ));
                }
                PromiseStaticMethod::Try
            }
            "withResolvers" => {
                if !args.is_empty() {
                    return Err(Error::ScriptParse(
                        "Promise.withResolvers does not take arguments".into(),
                    ));
                }
                PromiseStaticMethod::WithResolvers
            }
            _ => return Ok(None),
        };

        let mut parsed = Vec::with_capacity(args.len());
        for arg in args {
            let arg = arg.trim();
            if arg.is_empty() {
                return Err(Error::ScriptParse(format!(
                    "Promise.{} argument cannot be empty",
                    member
                )));
            }
            parsed.push(parse_expr(arg)?);
        }

        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::PromiseStaticMethod {
            method,
            args: parsed,
        }));
    }

    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some(Expr::PromiseConstructor))
}

fn parse_promise_method_expr(src: &str) -> Result<Option<Expr>> {
    let src = src.trim();
    let dots = collect_top_level_char_positions(src, b'.');
    for dot in dots.into_iter().rev() {
        let Some(base_src) = src.get(..dot) else {
            continue;
        };
        let base_src = base_src.trim();
        if base_src.is_empty() {
            continue;
        }

        let Some(tail_src) = src.get(dot + 1..) else {
            continue;
        };
        let tail_src = tail_src.trim();
        let mut cursor = Cursor::new(tail_src);
        let Some(member) = cursor.parse_identifier() else {
            continue;
        };
        cursor.skip_ws();
        if cursor.peek() != Some(b'(') {
            continue;
        }
        let args_src = cursor.read_balanced_block(b'(', b')')?;
        cursor.skip_ws();
        if !cursor.eof() {
            continue;
        }

        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };

        let method = match member.as_str() {
            "then" => {
                if args.len() > 2 {
                    return Err(Error::ScriptParse(
                        "Promise.then supports up to two arguments".into(),
                    ));
                }
                PromiseInstanceMethod::Then
            }
            "catch" => {
                if args.len() > 1 {
                    return Err(Error::ScriptParse(
                        "Promise.catch supports at most one argument".into(),
                    ));
                }
                PromiseInstanceMethod::Catch
            }
            "finally" => {
                if args.len() > 1 {
                    return Err(Error::ScriptParse(
                        "Promise.finally supports at most one argument".into(),
                    ));
                }
                PromiseInstanceMethod::Finally
            }
            _ => continue,
        };

        let mut parsed_args = Vec::with_capacity(args.len());
        for arg in args {
            let arg = arg.trim();
            if arg.is_empty() {
                return Err(Error::ScriptParse(format!(
                    "Promise.{} argument cannot be empty",
                    member
                )));
            }
            parsed_args.push(parse_expr(arg)?);
        }

        return Ok(Some(Expr::PromiseMethod {
            target: Box::new(parse_expr(base_src)?),
            method,
            args: parsed_args,
        }));
    }
    Ok(None)
}

fn parse_map_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    let mut called_with_new = false;
    if cursor.consume_ascii("new") {
        if let Some(next) = cursor.peek() {
            if is_ident_char(next) {
                return Ok(None);
            }
        }
        called_with_new = true;
        cursor.skip_ws();
    }

    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(None);
        }
        cursor.skip_ws();
    }

    if !cursor.consume_ascii("Map") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();

    if cursor.peek() == Some(b'(') {
        let args_src = cursor.read_balanced_block(b'(', b')')?;
        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };
        if args.len() > 1 {
            return Err(Error::ScriptParse(
                "Map supports zero or one argument".into(),
            ));
        }
        let iterable = if let Some(first) = args.first() {
            let first = first.trim();
            if first.is_empty() {
                return Err(Error::ScriptParse("Map argument cannot be empty".into()));
            }
            Some(Box::new(parse_expr(first)?))
        } else {
            None
        };
        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::MapConstruct {
            iterable,
            called_with_new,
        }));
    }

    if called_with_new {
        cursor.skip_ws();
        if cursor.eof() {
            return Ok(Some(Expr::MapConstruct {
                iterable: None,
                called_with_new: true,
            }));
        }
        return Ok(None);
    }

    if cursor.consume_byte(b'.') {
        cursor.skip_ws();
        let Some(member) = cursor.parse_identifier() else {
            return Ok(None);
        };
        cursor.skip_ws();
        if member != "groupBy" {
            return Ok(None);
        }
        let args_src = cursor.read_balanced_block(b'(', b')')?;
        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };
        if args.len() != 2 || args[0].trim().is_empty() || args[1].trim().is_empty() {
            return Err(Error::ScriptParse(
                "Map.groupBy requires exactly two arguments".into(),
            ));
        }
        let parsed = vec![parse_expr(args[0].trim())?, parse_expr(args[1].trim())?];
        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::MapStaticMethod {
            method: MapStaticMethod::GroupBy,
            args: parsed,
        }));
    }

    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some(Expr::MapConstructor))
}

fn parse_set_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    let mut called_with_new = false;
    if cursor.consume_ascii("new") {
        if let Some(next) = cursor.peek() {
            if is_ident_char(next) {
                return Ok(None);
            }
        }
        called_with_new = true;
        cursor.skip_ws();
    }

    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(None);
        }
        cursor.skip_ws();
    }

    if !cursor.consume_ascii("Set") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();

    if cursor.peek() == Some(b'(') {
        let args_src = cursor.read_balanced_block(b'(', b')')?;
        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };
        if args.len() > 1 {
            return Err(Error::ScriptParse(
                "Set supports zero or one argument".into(),
            ));
        }
        let iterable = if let Some(first) = args.first() {
            let first = first.trim();
            if first.is_empty() {
                return Err(Error::ScriptParse("Set argument cannot be empty".into()));
            }
            Some(Box::new(parse_expr(first)?))
        } else {
            None
        };
        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::SetConstruct {
            iterable,
            called_with_new,
        }));
    }

    if called_with_new {
        cursor.skip_ws();
        if cursor.eof() {
            return Ok(Some(Expr::SetConstruct {
                iterable: None,
                called_with_new: true,
            }));
        }
        return Ok(None);
    }

    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some(Expr::SetConstructor))
}

fn parse_symbol_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    let mut called_with_new = false;
    if cursor.consume_ascii("new") {
        if let Some(next) = cursor.peek() {
            if is_ident_char(next) {
                return Ok(None);
            }
        }
        called_with_new = true;
        cursor.skip_ws();
    }

    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(None);
        }
        cursor.skip_ws();
    }

    if !cursor.consume_ascii("Symbol") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();

    if cursor.peek() == Some(b'(') {
        let args_src = cursor.read_balanced_block(b'(', b')')?;
        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };
        if args.len() > 1 {
            return Err(Error::ScriptParse(
                "Symbol supports zero or one argument".into(),
            ));
        }
        if args.len() == 1 && args[0].trim().is_empty() {
            return Err(Error::ScriptParse(
                "Symbol description argument cannot be empty".into(),
            ));
        }
        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::SymbolConstruct {
            description: if args.is_empty() {
                None
            } else {
                Some(Box::new(parse_expr(args[0].trim())?))
            },
            called_with_new,
        }));
    }

    if called_with_new {
        cursor.skip_ws();
        if cursor.eof() {
            return Ok(Some(Expr::SymbolConstruct {
                description: None,
                called_with_new: true,
            }));
        }
        return Ok(None);
    }

    if cursor.consume_byte(b'.') {
        cursor.skip_ws();
        let Some(member) = cursor.parse_identifier() else {
            return Ok(None);
        };
        cursor.skip_ws();

        if cursor.peek() == Some(b'(') {
            let args_src = cursor.read_balanced_block(b'(', b')')?;
            let raw_args = split_top_level_by_char(&args_src, b',');
            let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
                Vec::new()
            } else {
                raw_args
            };
            let method = match member.as_str() {
                "for" => {
                    if args.len() != 1 || args[0].trim().is_empty() {
                        return Err(Error::ScriptParse(
                            "Symbol.for requires exactly one argument".into(),
                        ));
                    }
                    SymbolStaticMethod::For
                }
                "keyFor" => {
                    if args.len() != 1 || args[0].trim().is_empty() {
                        return Err(Error::ScriptParse(
                            "Symbol.keyFor requires exactly one argument".into(),
                        ));
                    }
                    SymbolStaticMethod::KeyFor
                }
                _ => return Ok(None),
            };

            let mut parsed = Vec::with_capacity(args.len());
            for arg in args {
                parsed.push(parse_expr(arg.trim())?);
            }
            cursor.skip_ws();
            if !cursor.eof() {
                return Ok(None);
            }
            return Ok(Some(Expr::SymbolStaticMethod {
                method,
                args: parsed,
            }));
        }

        let property = match member.as_str() {
            "asyncDispose" => SymbolStaticProperty::AsyncDispose,
            "asyncIterator" => SymbolStaticProperty::AsyncIterator,
            "dispose" => SymbolStaticProperty::Dispose,
            "hasInstance" => SymbolStaticProperty::HasInstance,
            "isConcatSpreadable" => SymbolStaticProperty::IsConcatSpreadable,
            "iterator" => SymbolStaticProperty::Iterator,
            "match" => SymbolStaticProperty::Match,
            "matchAll" => SymbolStaticProperty::MatchAll,
            "replace" => SymbolStaticProperty::Replace,
            "search" => SymbolStaticProperty::Search,
            "species" => SymbolStaticProperty::Species,
            "split" => SymbolStaticProperty::Split,
            "toPrimitive" => SymbolStaticProperty::ToPrimitive,
            "toStringTag" => SymbolStaticProperty::ToStringTag,
            "unscopables" => SymbolStaticProperty::Unscopables,
            _ => return Ok(None),
        };
        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::SymbolStaticProperty(property)));
    }

    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some(Expr::SymbolConstructor))
}

fn parse_array_buffer_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    let mut called_with_new = false;
    if cursor.consume_ascii("new") {
        if let Some(next) = cursor.peek() {
            if is_ident_char(next) {
                return Ok(None);
            }
        }
        called_with_new = true;
        cursor.skip_ws();
    }

    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(None);
        }
        cursor.skip_ws();
    }

    if !cursor.consume_ascii("ArrayBuffer") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();

    if cursor.peek() == Some(b'(') {
        let args_src = cursor.read_balanced_block(b'(', b')')?;
        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };
        if args.len() > 2 {
            return Err(Error::ScriptParse(
                "ArrayBuffer supports up to two arguments".into(),
            ));
        }
        if args.len() >= 1 && args[0].trim().is_empty() {
            return Err(Error::ScriptParse(
                "ArrayBuffer byteLength argument cannot be empty".into(),
            ));
        }
        if args.len() == 2 && args[1].trim().is_empty() {
            return Err(Error::ScriptParse(
                "ArrayBuffer options argument cannot be empty".into(),
            ));
        }
        let byte_length = if let Some(first) = args.first() {
            Some(Box::new(parse_expr(first.trim())?))
        } else {
            None
        };
        let options = if args.len() == 2 {
            Some(Box::new(parse_expr(args[1].trim())?))
        } else {
            None
        };
        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::ArrayBufferConstruct {
            byte_length,
            options,
            called_with_new,
        }));
    }

    if called_with_new {
        cursor.skip_ws();
        if cursor.eof() {
            return Ok(Some(Expr::ArrayBufferConstruct {
                byte_length: None,
                options: None,
                called_with_new: true,
            }));
        }
        return Ok(None);
    }

    if cursor.consume_byte(b'.') {
        cursor.skip_ws();
        let Some(member) = cursor.parse_identifier() else {
            return Ok(None);
        };
        cursor.skip_ws();
        if member != "isView" {
            return Ok(None);
        }
        if cursor.peek() != Some(b'(') {
            return Ok(None);
        }
        let args_src = cursor.read_balanced_block(b'(', b')')?;
        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };
        if args.len() != 1 || args[0].trim().is_empty() {
            return Err(Error::ScriptParse(
                "ArrayBuffer.isView requires exactly one argument".into(),
            ));
        }
        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::ArrayBufferIsView(Box::new(parse_expr(
            args[0].trim(),
        )?))));
    }

    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some(Expr::ArrayBufferConstructor))
}

fn parse_new_callee_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();
    if !cursor.consume_ascii("new") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();
    if cursor.peek() != Some(b'(') {
        return Ok(None);
    }
    let callee_src = cursor.read_balanced_block(b'(', b')')?;
    cursor.skip_ws();
    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let raw_args = split_top_level_by_char(&args_src, b',');
    let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
        Vec::new()
    } else {
        raw_args
    };
    let mut parsed = Vec::with_capacity(args.len());
    for arg in args {
        let arg = arg.trim();
        if arg.is_empty() {
            return Err(Error::ScriptParse(
                "constructor argument cannot be empty".into(),
            ));
        }
        parsed.push(parse_expr(arg)?);
    }
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }
    let callee = parse_expr(callee_src.trim())?;
    Ok(Some(Expr::TypedArrayConstructWithCallee {
        callee: Box::new(callee),
        args: parsed,
        called_with_new: true,
    }))
}

fn parse_array_buffer_access_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();
    let Some(target) = cursor.parse_identifier() else {
        return Ok(None);
    };
    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    let Some(member) = cursor.parse_identifier() else {
        return Ok(None);
    };
    cursor.skip_ws();

    let property_expr = match member.as_str() {
        "detached" => Some(Expr::ArrayBufferDetached(target.clone())),
        "maxByteLength" => Some(Expr::ArrayBufferMaxByteLength(target.clone())),
        "resizable" => Some(Expr::ArrayBufferResizable(target.clone())),
        _ => None,
    };
    if let Some(expr) = property_expr {
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(expr));
    }

    if cursor.peek() != Some(b'(') {
        return Ok(None);
    }

    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let raw_args = split_top_level_by_char(&args_src, b',');
    let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
        Vec::new()
    } else {
        raw_args
    };
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }

    match member.as_str() {
        "resize" => {
            if args.len() != 1 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "ArrayBuffer.resize requires exactly one argument".into(),
                ));
            }
            Ok(Some(Expr::ArrayBufferResize {
                target,
                new_byte_length: Box::new(parse_expr(args[0].trim())?),
            }))
        }
        "slice" => {
            if args.len() > 2 {
                return Err(Error::ScriptParse(
                    "ArrayBuffer.slice supports up to two arguments".into(),
                ));
            }
            if args.len() >= 1 && args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "ArrayBuffer.slice start cannot be empty".into(),
                ));
            }
            if args.len() == 2 && args[1].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "ArrayBuffer.slice end cannot be empty".into(),
                ));
            }
            let start = if let Some(first) = args.first() {
                Some(Box::new(parse_expr(first.trim())?))
            } else {
                None
            };
            let end = if args.len() == 2 {
                Some(Box::new(parse_expr(args[1].trim())?))
            } else {
                None
            };
            Ok(Some(Expr::ArrayBufferSlice { target, start, end }))
        }
        "transfer" => {
            if !args.is_empty() {
                return Err(Error::ScriptParse(
                    "ArrayBuffer.transfer does not take arguments".into(),
                ));
            }
            Ok(Some(Expr::ArrayBufferTransfer {
                target,
                to_fixed_length: false,
            }))
        }
        "transferToFixedLength" => {
            if !args.is_empty() {
                return Err(Error::ScriptParse(
                    "ArrayBuffer.transferToFixedLength does not take arguments".into(),
                ));
            }
            Ok(Some(Expr::ArrayBufferTransfer {
                target,
                to_fixed_length: true,
            }))
        }
        _ => Ok(None),
    }
}

fn parse_typed_array_access_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();
    let Some(target) = cursor.parse_identifier() else {
        return Ok(None);
    };
    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    let Some(member) = cursor.parse_identifier() else {
        return Ok(None);
    };
    cursor.skip_ws();

    let property_expr = match member.as_str() {
        "byteLength" => Some(Expr::TypedArrayByteLength(target.clone())),
        "byteOffset" => Some(Expr::TypedArrayByteOffset(target.clone())),
        "buffer" => Some(Expr::TypedArrayBuffer(target.clone())),
        "BYTES_PER_ELEMENT" => Some(Expr::TypedArrayBytesPerElement(target.clone())),
        _ => None,
    };
    if let Some(expr) = property_expr {
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(expr));
    }

    if cursor.peek() != Some(b'(') {
        return Ok(None);
    }
    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let raw_args = split_top_level_by_char(&args_src, b',');
    let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
        Vec::new()
    } else {
        raw_args
    };
    let method = match member.as_str() {
        "at" => TypedArrayInstanceMethod::At,
        "copyWithin" => TypedArrayInstanceMethod::CopyWithin,
        "entries" => TypedArrayInstanceMethod::Entries,
        "fill" => TypedArrayInstanceMethod::Fill,
        "findIndex" => TypedArrayInstanceMethod::FindIndex,
        "findLast" => TypedArrayInstanceMethod::FindLast,
        "findLastIndex" => TypedArrayInstanceMethod::FindLastIndex,
        "indexOf" => TypedArrayInstanceMethod::IndexOf,
        "keys" => TypedArrayInstanceMethod::Keys,
        "lastIndexOf" => TypedArrayInstanceMethod::LastIndexOf,
        "reduceRight" => TypedArrayInstanceMethod::ReduceRight,
        "reverse" => TypedArrayInstanceMethod::Reverse,
        "set" => TypedArrayInstanceMethod::Set,
        "sort" => TypedArrayInstanceMethod::Sort,
        "subarray" => TypedArrayInstanceMethod::Subarray,
        "toReversed" => TypedArrayInstanceMethod::ToReversed,
        "toSorted" => TypedArrayInstanceMethod::ToSorted,
        "values" => TypedArrayInstanceMethod::Values,
        "with" => TypedArrayInstanceMethod::With,
        _ => return Ok(None),
    };

    let mut parsed = Vec::with_capacity(args.len());
    for arg in args {
        let arg = arg.trim();
        if arg.is_empty() {
            return Err(Error::ScriptParse(format!(
                "{} argument cannot be empty",
                member
            )));
        }
        parsed.push(parse_expr(arg)?);
    }

    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some(Expr::TypedArrayMethod {
        target,
        method,
        args: parsed,
    }))
}

fn parse_map_access_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();
    let Some(target) = cursor.parse_identifier() else {
        return Ok(None);
    };
    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    let Some(member) = cursor.parse_identifier() else {
        return Ok(None);
    };
    cursor.skip_ws();
    if cursor.peek() != Some(b'(') {
        return Ok(None);
    }
    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let raw_args = split_top_level_by_char(&args_src, b',');
    let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
        Vec::new()
    } else {
        raw_args
    };

    let method = match member.as_str() {
        "get" => {
            if args.len() != 1 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Map.get requires exactly one argument".into(),
                ));
            }
            MapInstanceMethod::Get
        }
        "has" => {
            if args.len() != 1 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Map.has requires exactly one argument".into(),
                ));
            }
            MapInstanceMethod::Has
        }
        "delete" => {
            if args.len() != 1 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Map.delete requires exactly one argument".into(),
                ));
            }
            MapInstanceMethod::Delete
        }
        "clear" => {
            if !args.is_empty() {
                return Err(Error::ScriptParse(
                    "Map.clear does not take arguments".into(),
                ));
            }
            MapInstanceMethod::Clear
        }
        "forEach" => {
            if args.is_empty() || args.len() > 2 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Map.forEach requires a callback and optional thisArg".into(),
                ));
            }
            if args.len() == 2 && args[1].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Map.forEach thisArg cannot be empty".into(),
                ));
            }
            MapInstanceMethod::ForEach
        }
        "getOrInsert" => {
            if args.len() != 2 || args[0].trim().is_empty() || args[1].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Map.getOrInsert requires exactly two arguments".into(),
                ));
            }
            MapInstanceMethod::GetOrInsert
        }
        "getOrInsertComputed" => {
            if args.len() != 2 || args[0].trim().is_empty() || args[1].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Map.getOrInsertComputed requires exactly two arguments".into(),
                ));
            }
            MapInstanceMethod::GetOrInsertComputed
        }
        _ => return Ok(None),
    };

    let mut parsed = Vec::with_capacity(args.len());
    for arg in args {
        let arg = arg.trim();
        if arg.is_empty() {
            return Err(Error::ScriptParse(format!(
                "Map.{} argument cannot be empty",
                member
            )));
        }
        parsed.push(parse_expr(arg)?);
    }

    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some(Expr::MapMethod {
        target,
        method,
        args: parsed,
    }))
}

fn parse_set_access_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();
    let Some(target) = cursor.parse_identifier() else {
        return Ok(None);
    };
    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    let Some(member) = cursor.parse_identifier() else {
        return Ok(None);
    };
    cursor.skip_ws();
    if cursor.peek() != Some(b'(') {
        return Ok(None);
    }
    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let raw_args = split_top_level_by_char(&args_src, b',');
    let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
        Vec::new()
    } else {
        raw_args
    };

    let method = match member.as_str() {
        "add" => {
            if args.len() != 1 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Set.add requires exactly one argument".into(),
                ));
            }
            SetInstanceMethod::Add
        }
        "union" => {
            if args.len() != 1 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Set.union requires exactly one argument".into(),
                ));
            }
            SetInstanceMethod::Union
        }
        "intersection" => {
            if args.len() != 1 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Set.intersection requires exactly one argument".into(),
                ));
            }
            SetInstanceMethod::Intersection
        }
        "difference" => {
            if args.len() != 1 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Set.difference requires exactly one argument".into(),
                ));
            }
            SetInstanceMethod::Difference
        }
        "symmetricDifference" => {
            if args.len() != 1 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Set.symmetricDifference requires exactly one argument".into(),
                ));
            }
            SetInstanceMethod::SymmetricDifference
        }
        "isDisjointFrom" => {
            if args.len() != 1 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Set.isDisjointFrom requires exactly one argument".into(),
                ));
            }
            SetInstanceMethod::IsDisjointFrom
        }
        "isSubsetOf" => {
            if args.len() != 1 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Set.isSubsetOf requires exactly one argument".into(),
                ));
            }
            SetInstanceMethod::IsSubsetOf
        }
        "isSupersetOf" => {
            if args.len() != 1 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Set.isSupersetOf requires exactly one argument".into(),
                ));
            }
            SetInstanceMethod::IsSupersetOf
        }
        _ => return Ok(None),
    };

    let mut parsed = Vec::with_capacity(args.len());
    for arg in args {
        let arg = arg.trim();
        if arg.is_empty() {
            return Err(Error::ScriptParse(format!(
                "Set.{} argument cannot be empty",
                member
            )));
        }
        parsed.push(parse_expr(arg)?);
    }

    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some(Expr::SetMethod {
        target,
        method,
        args: parsed,
    }))
}

fn parse_is_nan_expr(src: &str) -> Result<Option<Expr>> {
    parse_global_single_arg_expr(src, "isNaN", "isNaN requires exactly one argument")
}

fn parse_encode_uri_expr(src: &str) -> Result<Option<Expr>> {
    parse_global_single_arg_expr(src, "encodeURI", "encodeURI requires exactly one argument")
}

fn parse_encode_uri_component_expr(src: &str) -> Result<Option<Expr>> {
    parse_global_single_arg_expr(
        src,
        "encodeURIComponent",
        "encodeURIComponent requires exactly one argument",
    )
}

fn parse_decode_uri_expr(src: &str) -> Result<Option<Expr>> {
    parse_global_single_arg_expr(src, "decodeURI", "decodeURI requires exactly one argument")
}

fn parse_decode_uri_component_expr(src: &str) -> Result<Option<Expr>> {
    parse_global_single_arg_expr(
        src,
        "decodeURIComponent",
        "decodeURIComponent requires exactly one argument",
    )
}

fn parse_escape_expr(src: &str) -> Result<Option<Expr>> {
    parse_global_single_arg_expr(src, "escape", "escape requires exactly one argument")
}

fn parse_unescape_expr(src: &str) -> Result<Option<Expr>> {
    parse_global_single_arg_expr(src, "unescape", "unescape requires exactly one argument")
}

fn parse_is_finite_expr(src: &str) -> Result<Option<Expr>> {
    parse_global_single_arg_expr(src, "isFinite", "isFinite requires exactly one argument")
}

fn parse_atob_expr(src: &str) -> Result<Option<Expr>> {
    parse_global_single_arg_expr(src, "atob", "atob requires exactly one argument")
}

fn parse_btoa_expr(src: &str) -> Result<Option<Expr>> {
    parse_global_single_arg_expr(src, "btoa", "btoa requires exactly one argument")
}

fn parse_global_single_arg_expr(
    src: &str,
    function_name: &str,
    arg_error: &str,
) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(None);
        }
        cursor.skip_ws();
    }

    if !cursor.consume_ascii(function_name) {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();

    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let args = split_top_level_by_char(&args_src, b',');
    if args.len() != 1 || args[0].trim().is_empty() {
        return Err(Error::ScriptParse(arg_error.into()));
    }

    let value = parse_expr(args[0].trim())?;
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some(value))
}

fn parse_parse_int_expr(src: &str) -> Result<Option<(Expr, Option<Expr>)>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(None);
        }
        cursor.skip_ws();
    }

    if !cursor.consume_ascii("parseInt") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();

    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let args = split_top_level_by_char(&args_src, b',');
    if args.is_empty() || args.len() > 2 || args[0].trim().is_empty() {
        return Err(Error::ScriptParse(
            "parseInt requires one or two arguments".into(),
        ));
    }
    if args.len() == 2 && args[1].trim().is_empty() {
        return Err(Error::ScriptParse(
            "parseInt radix argument cannot be empty".into(),
        ));
    }

    let value = parse_expr(args[0].trim())?;
    let radix = if args.len() == 2 {
        Some(parse_expr(args[1].trim())?)
    } else {
        None
    };

    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some((value, radix)))
}

fn parse_parse_float_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(None);
        }
        cursor.skip_ws();
    }

    if !cursor.consume_ascii("parseFloat") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();

    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let args = split_top_level_by_char(&args_src, b',');
    if args.len() != 1 || args[0].trim().is_empty() {
        return Err(Error::ScriptParse(
            "parseFloat requires exactly one argument".into(),
        ));
    }

    let value = parse_expr(args[0].trim())?;
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some(value))
}

fn parse_json_parse_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(None);
        }
        cursor.skip_ws();
    }

    if !cursor.consume_ascii("JSON") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();

    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.consume_ascii("parse") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();

    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let args = split_top_level_by_char(&args_src, b',');
    if args.len() != 1 || args[0].trim().is_empty() {
        return Err(Error::ScriptParse(
            "JSON.parse requires exactly one argument".into(),
        ));
    }

    let value = parse_expr(args[0].trim())?;
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some(value))
}

fn parse_json_stringify_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(None);
        }
        cursor.skip_ws();
    }

    if !cursor.consume_ascii("JSON") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.consume_ascii("stringify") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();

    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let args = split_top_level_by_char(&args_src, b',');
    if args.len() != 1 || args[0].trim().is_empty() {
        return Err(Error::ScriptParse(
            "JSON.stringify requires exactly one argument".into(),
        ));
    }

    let value = parse_expr(args[0].trim())?;
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some(value))
}

fn parse_object_literal_expr(src: &str) -> Result<Option<Vec<ObjectLiteralEntry>>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();
    if cursor.peek() != Some(b'{') {
        return Ok(None);
    }

    let entries_src = cursor.read_balanced_block(b'{', b'}')?;
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }

    let mut entries = split_top_level_by_char(&entries_src, b',');
    while entries.len() > 1 && entries.last().is_some_and(|entry| entry.trim().is_empty()) {
        entries.pop();
    }
    if entries.len() == 1 && entries[0].trim().is_empty() {
        return Ok(Some(Vec::new()));
    }

    let mut out = Vec::with_capacity(entries.len());
    for entry in entries {
        let entry = entry.trim();
        if entry.is_empty() {
            return Err(Error::ScriptParse(
                "object literal does not support empty entries".into(),
            ));
        }

        if let Some(rest) = entry.strip_prefix("...") {
            let rest = rest.trim();
            if rest.is_empty() {
                return Err(Error::ScriptParse(
                    "object spread source cannot be empty".into(),
                ));
            }
            out.push(ObjectLiteralEntry::Spread(parse_expr(rest)?));
            continue;
        }

        let Some(colon) = find_first_top_level_colon(entry) else {
            return Err(Error::ScriptParse(
                "object literal entry must use key: value".into(),
            ));
        };

        let key_src = entry[..colon].trim();
        let value_src = entry[colon + 1..].trim();
        if value_src.is_empty() {
            return Err(Error::ScriptParse(
                "object literal value cannot be empty".into(),
            ));
        }

        let key = if key_src.starts_with('[') && key_src.ends_with(']') && key_src.len() >= 2 {
            let computed_src = key_src[1..key_src.len() - 1].trim();
            if computed_src.is_empty() {
                return Err(Error::ScriptParse(
                    "object literal computed key cannot be empty".into(),
                ));
            }
            ObjectLiteralKey::Computed(Box::new(parse_expr(computed_src)?))
        } else if (key_src.starts_with('\'') && key_src.ends_with('\''))
            || (key_src.starts_with('"') && key_src.ends_with('"'))
        {
            ObjectLiteralKey::Static(parse_string_literal_exact(key_src)?)
        } else if is_ident(key_src) {
            ObjectLiteralKey::Static(key_src.to_string())
        } else {
            return Err(Error::ScriptParse(
                "object literal key must be identifier, string literal, or computed key".into(),
            ));
        };

        out.push(ObjectLiteralEntry::Pair(key, parse_expr(value_src)?));
    }

    Ok(Some(out))
}

fn find_first_top_level_colon(src: &str) -> Option<usize> {
    let bytes = src.as_bytes();
    let mut i = 0usize;

    let mut paren = 0usize;
    let mut bracket = 0usize;
    let mut brace = 0usize;

    #[derive(Clone, Copy, PartialEq, Eq)]
    enum StrState {
        None,
        Single,
        Double,
        Backtick,
    }
    let mut state = StrState::None;

    while i < bytes.len() {
        let b = bytes[i];
        match state {
            StrState::None => match b {
                b'\'' => state = StrState::Single,
                b'"' => state = StrState::Double,
                b'`' => state = StrState::Backtick,
                b'(' => paren += 1,
                b')' => paren = paren.saturating_sub(1),
                b'[' => bracket += 1,
                b']' => bracket = bracket.saturating_sub(1),
                b'{' => brace += 1,
                b'}' => brace = brace.saturating_sub(1),
                b':' if paren == 0 && bracket == 0 && brace == 0 => return Some(i),
                _ => {}
            },
            StrState::Single => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'\'' {
                    state = StrState::None;
                }
            }
            StrState::Double => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'"' {
                    state = StrState::None;
                }
            }
            StrState::Backtick => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'`' {
                    state = StrState::None;
                }
            }
        }
        i += 1;
    }

    None
}

fn parse_object_static_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(None);
        }
        cursor.skip_ws();
    }

    if !cursor.consume_ascii("Object") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();

    if cursor.peek() == Some(b'(') {
        let args_src = cursor.read_balanced_block(b'(', b')')?;
        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };
        if args.len() > 1 {
            return Err(Error::ScriptParse(
                "Object supports zero or one argument".into(),
            ));
        }
        if args.len() == 1 && args[0].trim().is_empty() {
            return Err(Error::ScriptParse("Object argument cannot be empty".into()));
        }
        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::ObjectConstruct {
            value: if args.is_empty() {
                None
            } else {
                Some(Box::new(parse_expr(args[0].trim())?))
            },
        }));
    }

    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    let Some(method) = cursor.parse_identifier() else {
        return Ok(None);
    };
    cursor.skip_ws();

    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let raw_args = split_top_level_by_char(&args_src, b',');
    let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
        Vec::new()
    } else {
        raw_args
    };

    let expr = match method.as_str() {
        "getOwnPropertySymbols" => {
            if args.len() != 1 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Object.getOwnPropertySymbols requires exactly one argument".into(),
                ));
            }
            Expr::ObjectGetOwnPropertySymbols(Box::new(parse_expr(args[0].trim())?))
        }
        "keys" => {
            if args.len() != 1 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Object.keys requires exactly one argument".into(),
                ));
            }
            Expr::ObjectKeys(Box::new(parse_expr(args[0].trim())?))
        }
        "values" => {
            if args.len() != 1 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Object.values requires exactly one argument".into(),
                ));
            }
            Expr::ObjectValues(Box::new(parse_expr(args[0].trim())?))
        }
        "entries" => {
            if args.len() != 1 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Object.entries requires exactly one argument".into(),
                ));
            }
            Expr::ObjectEntries(Box::new(parse_expr(args[0].trim())?))
        }
        "hasOwn" => {
            if args.len() != 2 || args[0].trim().is_empty() || args[1].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Object.hasOwn requires exactly two arguments".into(),
                ));
            }
            Expr::ObjectHasOwn {
                object: Box::new(parse_expr(args[0].trim())?),
                key: Box::new(parse_expr(args[1].trim())?),
            }
        }
        "getPrototypeOf" => {
            if args.len() != 1 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Object.getPrototypeOf requires exactly one argument".into(),
                ));
            }
            Expr::ObjectGetPrototypeOf(Box::new(parse_expr(args[0].trim())?))
        }
        "freeze" => {
            if args.len() != 1 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Object.freeze requires exactly one argument".into(),
                ));
            }
            Expr::ObjectFreeze(Box::new(parse_expr(args[0].trim())?))
        }
        _ => return Ok(None),
    };

    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some(expr))
}

fn parse_object_has_own_property_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();
    let Some(target) = cursor.parse_identifier() else {
        return Ok(None);
    };
    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.consume_ascii("hasOwnProperty") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();

    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let args = split_top_level_by_char(&args_src, b',');
    if args.len() != 1 || args[0].trim().is_empty() {
        return Err(Error::ScriptParse(
            "hasOwnProperty requires exactly one argument".into(),
        ));
    }
    let key = parse_expr(args[0].trim())?;
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }

    Ok(Some(Expr::ObjectHasOwnProperty {
        target,
        key: Box::new(key),
    }))
}

fn parse_object_get_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();
    let Some(target) = cursor.parse_identifier() else {
        return Ok(None);
    };
    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    let mut path = Vec::new();
    loop {
        cursor.skip_ws();
        let Some(key) = cursor.parse_identifier() else {
            return Ok(None);
        };
        path.push(key);
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            break;
        }
    }
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }

    if path.len() == 1 {
        return Ok(Some(Expr::ObjectGet {
            target,
            key: path.remove(0),
        }));
    }
    Ok(Some(Expr::ObjectPathGet { target, path }))
}

fn parse_function_call_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();
    let Some(target) = cursor.parse_identifier() else {
        return Ok(None);
    };
    cursor.skip_ws();
    if cursor.peek() != Some(b'(') {
        return Ok(None);
    }

    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let raw_args = split_top_level_by_char(&args_src, b',');
    let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
        Vec::new()
    } else {
        raw_args
    };

    let mut parsed = Vec::with_capacity(args.len());
    for arg in args {
        let arg = arg.trim();
        if arg.is_empty() {
            return Err(Error::ScriptParse(
                "function call arguments cannot be empty".into(),
            ));
        }
        parsed.push(parse_expr(arg)?);
    }

    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }

    Ok(Some(Expr::FunctionCall {
        target,
        args: parsed,
    }))
}

fn parse_fetch_expr(src: &str) -> Result<Option<Expr>> {
    parse_global_single_arg_expr(src, "fetch", "fetch requires exactly one argument")
}

fn parse_match_media_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(None);
        }
        cursor.skip_ws();
    }

    if !cursor.consume_ascii("matchMedia") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();

    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let args = split_top_level_by_char(&args_src, b',');
    if args.len() != 1 || args[0].trim().is_empty() {
        return Err(Error::ScriptParse(
            "matchMedia requires exactly one argument".into(),
        ));
    }
    let query = parse_expr(args[0].trim())?;

    cursor.skip_ws();
    if cursor.consume_byte(b'.') {
        cursor.skip_ws();
        let Some(prop_name) = cursor.parse_identifier() else {
            return Ok(None);
        };
        let prop = match prop_name.as_str() {
            "matches" => MatchMediaProp::Matches,
            "media" => MatchMediaProp::Media,
            _ => return Ok(None),
        };
        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::MatchMediaProp {
            query: Box::new(query),
            prop,
        }));
    }

    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some(Expr::MatchMedia(Box::new(query))))
}

fn parse_structured_clone_expr(src: &str) -> Result<Option<Expr>> {
    parse_global_single_arg_expr(
        src,
        "structuredClone",
        "structuredClone requires exactly one argument",
    )
}

fn parse_alert_expr(src: &str) -> Result<Option<Expr>> {
    parse_global_single_arg_expr(src, "alert", "alert requires exactly one argument")
}

fn parse_confirm_expr(src: &str) -> Result<Option<Expr>> {
    parse_global_single_arg_expr(src, "confirm", "confirm requires exactly one argument")
}

fn parse_prompt_expr(src: &str) -> Result<Option<(Expr, Option<Expr>)>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(None);
        }
        cursor.skip_ws();
    }

    if !cursor.consume_ascii("prompt") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();

    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let args = split_top_level_by_char(&args_src, b',');
    if args.is_empty() || args.len() > 2 || args[0].trim().is_empty() {
        return Err(Error::ScriptParse(
            "prompt requires one or two arguments".into(),
        ));
    }
    if args.len() == 2 && args[1].trim().is_empty() {
        return Err(Error::ScriptParse(
            "prompt default argument cannot be empty".into(),
        ));
    }

    let message = parse_expr(args[0].trim())?;
    let default = if args.len() == 2 {
        Some(parse_expr(args[1].trim())?)
    } else {
        None
    };

    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some((message, default)))
}

fn parse_array_literal_expr(src: &str) -> Result<Option<Vec<Expr>>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();
    if cursor.peek() != Some(b'[') {
        return Ok(None);
    }

    let items_src = cursor.read_balanced_block(b'[', b']')?;
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }

    let mut items = split_top_level_by_char(&items_src, b',');
    while items.len() > 1 && items.last().is_some_and(|item| item.trim().is_empty()) {
        items.pop();
    }
    if items.len() == 1 && items[0].trim().is_empty() {
        return Ok(Some(Vec::new()));
    }

    let mut out = Vec::with_capacity(items.len());
    for item in items {
        let item = item.trim();
        if item.is_empty() {
            return Err(Error::ScriptParse(
                "array literal does not support empty elements".into(),
            ));
        }
        if let Some(rest) = item.strip_prefix("...") {
            let rest = rest.trim();
            if rest.is_empty() {
                return Err(Error::ScriptParse(
                    "array spread source cannot be empty".into(),
                ));
            }
            out.push(Expr::Spread(Box::new(parse_expr(rest)?)));
        } else {
            out.push(parse_expr(item)?);
        }
    }
    Ok(Some(out))
}

fn parse_array_is_array_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(None);
        }
        cursor.skip_ws();
    }

    if !cursor.consume_ascii("Array") {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.consume_ascii("isArray") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();
    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let args = split_top_level_by_char(&args_src, b',');
    if args.len() != 1 || args[0].trim().is_empty() {
        return Err(Error::ScriptParse(
            "Array.isArray requires exactly one argument".into(),
        ));
    }

    let value = parse_expr(args[0].trim())?;
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some(value))
}

fn parse_array_from_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(None);
        }
        cursor.skip_ws();
    }

    if !cursor.consume_ascii("Array") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.consume_ascii("from") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();

    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let args = split_top_level_by_char(&args_src, b',');
    if args.is_empty() || args.len() > 2 || args[0].trim().is_empty() {
        return Err(Error::ScriptParse(
            "Array.from requires one or two arguments".into(),
        ));
    }
    if args.len() == 2 && args[1].trim().is_empty() {
        return Err(Error::ScriptParse(
            "Array.from map function cannot be empty".into(),
        ));
    }

    let source = parse_expr(args[0].trim())?;
    let map_fn = if args.len() == 2 {
        Some(Box::new(parse_expr(args[1].trim())?))
    } else {
        None
    };

    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some(Expr::ArrayFrom {
        source: Box::new(source),
        map_fn,
    }))
}

fn parse_array_access_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();
    let Some(target) = cursor.parse_identifier() else {
        return Ok(None);
    };
    cursor.skip_ws();

    if cursor.peek() == Some(b'[') {
        let index_src = cursor.read_balanced_block(b'[', b']')?;
        cursor.skip_ws();
        if !cursor.eof() {
            return Ok(None);
        }
        if index_src.trim().is_empty() {
            return Err(Error::ScriptParse("array index cannot be empty".into()));
        }
        let index = parse_expr(index_src.trim())?;
        return Ok(Some(Expr::ArrayIndex {
            target,
            index: Box::new(index),
        }));
    }

    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    let Some(method) = cursor.parse_identifier() else {
        return Ok(None);
    };
    cursor.skip_ws();

    if method == "length" {
        if !cursor.eof() {
            return Ok(None);
        }
        return Ok(Some(Expr::ArrayLength(target)));
    }

    if cursor.peek() != Some(b'(') {
        return Ok(None);
    }

    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let raw_args = split_top_level_by_char(&args_src, b',');
    let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
        Vec::new()
    } else {
        raw_args
    };

    let expr = match method.as_str() {
        "push" => {
            let mut parsed = Vec::with_capacity(args.len());
            for arg in args {
                if arg.trim().is_empty() {
                    return Err(Error::ScriptParse("push argument cannot be empty".into()));
                }
                parsed.push(parse_expr(arg.trim())?);
            }
            Expr::ArrayPush {
                target,
                args: parsed,
            }
        }
        "pop" => {
            if !args.is_empty() {
                return Err(Error::ScriptParse("pop does not take arguments".into()));
            }
            Expr::ArrayPop(target)
        }
        "shift" => {
            if !args.is_empty() {
                return Err(Error::ScriptParse("shift does not take arguments".into()));
            }
            Expr::ArrayShift(target)
        }
        "unshift" => {
            let mut parsed = Vec::with_capacity(args.len());
            for arg in args {
                if arg.trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "unshift argument cannot be empty".into(),
                    ));
                }
                parsed.push(parse_expr(arg.trim())?);
            }
            Expr::ArrayUnshift {
                target,
                args: parsed,
            }
        }
        "map" => {
            if args.len() != 1 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "map requires exactly one callback argument".into(),
                ));
            }
            let callback = parse_array_callback_arg(args[0], 3, "array callback parameters")?;
            Expr::ArrayMap { target, callback }
        }
        "filter" => {
            if args.len() != 1 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "filter requires exactly one callback argument".into(),
                ));
            }
            let callback = parse_array_callback_arg(args[0], 3, "array callback parameters")?;
            Expr::ArrayFilter { target, callback }
        }
        "reduce" => {
            if args.is_empty() || args.len() > 2 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "reduce requires callback and optional initial value".into(),
                ));
            }
            let callback = parse_array_callback_arg(args[0], 4, "array callback parameters")?;
            let initial = if args.len() == 2 {
                if args[1].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "reduce initial value cannot be empty".into(),
                    ));
                }
                Some(Box::new(parse_expr(args[1].trim())?))
            } else {
                None
            };
            Expr::ArrayReduce {
                target,
                callback,
                initial,
            }
        }
        "forEach" => {
            if args.len() != 1 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "forEach requires exactly one callback argument".into(),
                ));
            }
            let callback = parse_array_callback_arg(args[0], 3, "array callback parameters")?;
            Expr::ArrayForEach { target, callback }
        }
        "find" => {
            if args.len() != 1 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "find requires exactly one callback argument".into(),
                ));
            }
            let callback = parse_array_callback_arg(args[0], 3, "array callback parameters")?;
            Expr::ArrayFind { target, callback }
        }
        "some" => {
            if args.len() != 1 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "some requires exactly one callback argument".into(),
                ));
            }
            let callback = parse_array_callback_arg(args[0], 3, "array callback parameters")?;
            Expr::ArraySome { target, callback }
        }
        "every" => {
            if args.len() != 1 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "every requires exactly one callback argument".into(),
                ));
            }
            let callback = parse_array_callback_arg(args[0], 3, "array callback parameters")?;
            Expr::ArrayEvery { target, callback }
        }
        "includes" => {
            if args.is_empty() || args.len() > 2 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "includes requires one or two arguments".into(),
                ));
            }
            if args.len() == 2 && args[1].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "includes fromIndex cannot be empty".into(),
                ));
            }
            Expr::ArrayIncludes {
                target,
                search: Box::new(parse_expr(args[0].trim())?),
                from_index: if args.len() == 2 {
                    Some(Box::new(parse_expr(args[1].trim())?))
                } else {
                    None
                },
            }
        }
        "slice" => {
            if args.len() > 2 {
                return Err(Error::ScriptParse(
                    "slice supports up to two arguments".into(),
                ));
            }
            let start = if !args.is_empty() {
                if args[0].trim().is_empty() {
                    return Err(Error::ScriptParse("slice start cannot be empty".into()));
                }
                Some(Box::new(parse_expr(args[0].trim())?))
            } else {
                None
            };
            let end = if args.len() == 2 {
                if args[1].trim().is_empty() {
                    return Err(Error::ScriptParse("slice end cannot be empty".into()));
                }
                Some(Box::new(parse_expr(args[1].trim())?))
            } else {
                None
            };
            Expr::ArraySlice { target, start, end }
        }
        "splice" => {
            if args.is_empty() || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "splice requires at least start index".into(),
                ));
            }
            let start = Box::new(parse_expr(args[0].trim())?);
            let delete_count = if args.len() >= 2 {
                if args[1].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "splice deleteCount cannot be empty".into(),
                    ));
                }
                Some(Box::new(parse_expr(args[1].trim())?))
            } else {
                None
            };
            let mut items = Vec::new();
            for arg in args.iter().skip(2) {
                if arg.trim().is_empty() {
                    return Err(Error::ScriptParse("splice item cannot be empty".into()));
                }
                items.push(parse_expr(arg.trim())?);
            }
            Expr::ArraySplice {
                target,
                start,
                delete_count,
                items,
            }
        }
        "join" => {
            if args.len() > 1 {
                return Err(Error::ScriptParse(
                    "join supports at most one argument".into(),
                ));
            }
            let separator = if args.len() == 1 {
                if args[0].trim().is_empty() {
                    return Err(Error::ScriptParse("join separator cannot be empty".into()));
                }
                Some(Box::new(parse_expr(args[0].trim())?))
            } else {
                None
            };
            Expr::ArrayJoin { target, separator }
        }
        "sort" => {
            if args.len() > 1 {
                return Err(Error::ScriptParse(
                    "sort supports at most one argument".into(),
                ));
            }
            if args.len() == 1 && args[0].trim().is_empty() {
                return Err(Error::ScriptParse("sort comparator cannot be empty".into()));
            }
            Expr::ArraySort {
                target,
                comparator: if args.len() == 1 {
                    Some(Box::new(parse_expr(args[0].trim())?))
                } else {
                    None
                },
            }
        }
        _ => return Ok(None),
    };

    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some(expr))
}

fn parse_array_callback_arg(arg: &str, max_params: usize, label: &str) -> Result<ScriptHandler> {
    let callback_arg = strip_js_comments(arg);
    let mut callback_cursor = Cursor::new(callback_arg.as_str().trim());
    let (params, body, concise_body) = parse_callback(&mut callback_cursor, max_params, label)?;
    callback_cursor.skip_ws();
    if !callback_cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "unsupported array callback: {}",
            arg.trim()
        )));
    }

    let stmts = if concise_body {
        vec![Stmt::Return {
            value: Some(parse_expr(body.trim())?),
        }]
    } else {
        parse_block_statements(&body)?
    };

    Ok(ScriptHandler { params, stmts })
}

fn parse_number_method_expr(src: &str) -> Result<Option<Expr>> {
    let src = src.trim();
    let dots = collect_top_level_char_positions(src, b'.');
    for dot in dots.into_iter().rev() {
        let Some(base_src) = src.get(..dot) else {
            continue;
        };
        let base_src = base_src.trim();
        if base_src.is_empty() {
            continue;
        }
        let Some(tail_src) = src.get(dot + 1..) else {
            continue;
        };
        let tail_src = tail_src.trim();

        let mut cursor = Cursor::new(tail_src);
        let Some(method) = cursor.parse_identifier() else {
            continue;
        };
        cursor.skip_ws();
        if cursor.peek() != Some(b'(') {
            continue;
        }
        let args_src = cursor.read_balanced_block(b'(', b')')?;
        cursor.skip_ws();
        if !cursor.eof() {
            continue;
        }

        let Some(method) = parse_number_instance_method_name(&method) else {
            continue;
        };

        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };

        let parsed = match method {
            NumberInstanceMethod::ToLocaleString | NumberInstanceMethod::ValueOf => {
                if !args.is_empty() {
                    let method_name = match method {
                        NumberInstanceMethod::ToLocaleString => "toLocaleString",
                        NumberInstanceMethod::ValueOf => "valueOf",
                        _ => unreachable!(),
                    };
                    return Err(Error::ScriptParse(format!(
                        "{method_name} does not take arguments"
                    )));
                }
                Vec::new()
            }
            NumberInstanceMethod::ToExponential
            | NumberInstanceMethod::ToFixed
            | NumberInstanceMethod::ToPrecision
            | NumberInstanceMethod::ToString => {
                if args.len() > 1 {
                    let method_name = match method {
                        NumberInstanceMethod::ToExponential => "toExponential",
                        NumberInstanceMethod::ToFixed => "toFixed",
                        NumberInstanceMethod::ToPrecision => "toPrecision",
                        NumberInstanceMethod::ToString => "toString",
                        _ => unreachable!(),
                    };
                    return Err(Error::ScriptParse(format!(
                        "{method_name} supports at most one argument"
                    )));
                }
                if args.len() == 1 && args[0].trim().is_empty() {
                    let method_name = match method {
                        NumberInstanceMethod::ToExponential => "toExponential",
                        NumberInstanceMethod::ToFixed => "toFixed",
                        NumberInstanceMethod::ToPrecision => "toPrecision",
                        NumberInstanceMethod::ToString => "toString",
                        _ => unreachable!(),
                    };
                    return Err(Error::ScriptParse(format!(
                        "{method_name} argument cannot be empty"
                    )));
                }
                if args.len() == 1 {
                    vec![parse_expr(args[0].trim())?]
                } else {
                    Vec::new()
                }
            }
        };

        return Ok(Some(Expr::NumberInstanceMethod {
            value: Box::new(parse_expr(base_src)?),
            method,
            args: parsed,
        }));
    }

    Ok(None)
}

fn parse_number_instance_method_name(name: &str) -> Option<NumberInstanceMethod> {
    match name {
        "toExponential" => Some(NumberInstanceMethod::ToExponential),
        "toFixed" => Some(NumberInstanceMethod::ToFixed),
        "toLocaleString" => Some(NumberInstanceMethod::ToLocaleString),
        "toPrecision" => Some(NumberInstanceMethod::ToPrecision),
        "toString" => Some(NumberInstanceMethod::ToString),
        "valueOf" => Some(NumberInstanceMethod::ValueOf),
        _ => None,
    }
}

fn parse_bigint_method_expr(src: &str) -> Result<Option<Expr>> {
    let src = src.trim();
    let dots = collect_top_level_char_positions(src, b'.');
    for dot in dots.into_iter().rev() {
        let Some(base_src) = src.get(..dot) else {
            continue;
        };
        let base_src = base_src.trim();
        if base_src.is_empty() {
            continue;
        }
        let Some(tail_src) = src.get(dot + 1..) else {
            continue;
        };
        let tail_src = tail_src.trim();

        let mut cursor = Cursor::new(tail_src);
        let Some(method_name) = cursor.parse_identifier() else {
            continue;
        };
        cursor.skip_ws();
        if cursor.peek() != Some(b'(') {
            continue;
        }
        let args_src = cursor.read_balanced_block(b'(', b')')?;
        cursor.skip_ws();
        if !cursor.eof() {
            continue;
        }

        let Some(method) = parse_bigint_instance_method_name(&method_name) else {
            continue;
        };

        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };

        let parsed = match method {
            BigIntInstanceMethod::ToLocaleString | BigIntInstanceMethod::ValueOf => {
                if !args.is_empty() {
                    let method_name = match method {
                        BigIntInstanceMethod::ToLocaleString => "toLocaleString",
                        BigIntInstanceMethod::ValueOf => "valueOf",
                        _ => unreachable!(),
                    };
                    return Err(Error::ScriptParse(format!(
                        "{method_name} does not take arguments"
                    )));
                }
                Vec::new()
            }
            BigIntInstanceMethod::ToString => {
                if args.len() > 1 {
                    return Err(Error::ScriptParse(
                        "toString supports at most one argument".into(),
                    ));
                }
                if args.len() == 1 && args[0].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "toString argument cannot be empty".into(),
                    ));
                }
                if args.len() == 1 {
                    vec![parse_expr(args[0].trim())?]
                } else {
                    Vec::new()
                }
            }
        };

        return Ok(Some(Expr::BigIntInstanceMethod {
            value: Box::new(parse_expr(base_src)?),
            method,
            args: parsed,
        }));
    }

    Ok(None)
}

fn parse_bigint_instance_method_name(name: &str) -> Option<BigIntInstanceMethod> {
    match name {
        "toLocaleString" => Some(BigIntInstanceMethod::ToLocaleString),
        "toString" => Some(BigIntInstanceMethod::ToString),
        "valueOf" => Some(BigIntInstanceMethod::ValueOf),
        _ => None,
    }
}

fn parse_intl_format_expr(src: &str) -> Result<Option<Expr>> {
    let src = src.trim();
    let dots = collect_top_level_char_positions(src, b'.');
    for dot in dots.into_iter().rev() {
        let Some(base_src) = src.get(..dot) else {
            continue;
        };
        let base_src = base_src.trim();
        if base_src.is_empty() {
            continue;
        }
        let Some(tail_src) = src.get(dot + 1..) else {
            continue;
        };
        let tail_src = tail_src.trim();

        let mut cursor = Cursor::new(tail_src);
        let Some(method_name) = cursor.parse_identifier() else {
            continue;
        };

        if method_name == "compare" {
            cursor.skip_ws();
            if cursor.eof() {
                return Ok(Some(Expr::IntlCollatorCompareGetter {
                    collator: Box::new(parse_expr(base_src)?),
                }));
            }
            if cursor.peek() != Some(b'(') {
                continue;
            }
            let args_src = cursor.read_balanced_block(b'(', b')')?;
            cursor.skip_ws();
            if !cursor.eof() {
                continue;
            }
            let raw_args = split_top_level_by_char(&args_src, b',');
            let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
                Vec::new()
            } else {
                raw_args
            };
            if args.len() != 2 || args[0].trim().is_empty() || args[1].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Intl.Collator.compare requires exactly two arguments".into(),
                ));
            }
            return Ok(Some(Expr::IntlCollatorCompare {
                collator: Box::new(parse_expr(base_src)?),
                left: Box::new(parse_expr(args[0].trim())?),
                right: Box::new(parse_expr(args[1].trim())?),
            }));
        }

        if method_name == "formatRangeToParts" {
            cursor.skip_ws();
            if cursor.peek() != Some(b'(') {
                continue;
            }
            let args_src = cursor.read_balanced_block(b'(', b')')?;
            cursor.skip_ws();
            if !cursor.eof() {
                continue;
            }
            let raw_args = split_top_level_by_char(&args_src, b',');
            let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
                Vec::new()
            } else {
                raw_args
            };
            if args.len() != 2 || args[0].trim().is_empty() || args[1].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Intl.DateTimeFormat.formatRangeToParts requires exactly two arguments".into(),
                ));
            }
            return Ok(Some(Expr::IntlDateTimeFormatRangeToParts {
                formatter: Box::new(parse_expr(base_src)?),
                start: Box::new(parse_expr(args[0].trim())?),
                end: Box::new(parse_expr(args[1].trim())?),
            }));
        }

        if method_name == "formatRange" {
            cursor.skip_ws();
            if cursor.peek() != Some(b'(') {
                continue;
            }
            let args_src = cursor.read_balanced_block(b'(', b')')?;
            cursor.skip_ws();
            if !cursor.eof() {
                continue;
            }
            let raw_args = split_top_level_by_char(&args_src, b',');
            let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
                Vec::new()
            } else {
                raw_args
            };
            if args.len() != 2 || args[0].trim().is_empty() || args[1].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Intl.DateTimeFormat.formatRange requires exactly two arguments".into(),
                ));
            }
            return Ok(Some(Expr::IntlDateTimeFormatRange {
                formatter: Box::new(parse_expr(base_src)?),
                start: Box::new(parse_expr(args[0].trim())?),
                end: Box::new(parse_expr(args[1].trim())?),
            }));
        }

        if method_name == "formatToParts" {
            cursor.skip_ws();
            if cursor.peek() != Some(b'(') {
                continue;
            }
            let args_src = cursor.read_balanced_block(b'(', b')')?;
            cursor.skip_ws();
            if !cursor.eof() {
                continue;
            }
            let raw_args = split_top_level_by_char(&args_src, b',');
            let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
                Vec::new()
            } else {
                raw_args
            };
            if args.len() == 2 && !args[0].trim().is_empty() && !args[1].trim().is_empty() {
                return Ok(Some(Expr::IntlRelativeTimeFormatToParts {
                    formatter: Box::new(parse_expr(base_src)?),
                    value: Box::new(parse_expr(args[0].trim())?),
                    unit: Box::new(parse_expr(args[1].trim())?),
                }));
            }
            if args.len() > 1 {
                return Err(Error::ScriptParse(
                    "Intl.DateTimeFormat.formatToParts supports at most one argument".into(),
                ));
            }
            if args.len() == 1 && args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Intl.DateTimeFormat.formatToParts argument cannot be empty".into(),
                ));
            }
            return Ok(Some(Expr::IntlDateTimeFormatToParts {
                formatter: Box::new(parse_expr(base_src)?),
                value: args
                    .first()
                    .map(|arg| parse_expr(arg.trim()))
                    .transpose()?
                    .map(Box::new),
            }));
        }

        if method_name == "of" {
            cursor.skip_ws();
            if cursor.peek() != Some(b'(') {
                continue;
            }
            let args_src = cursor.read_balanced_block(b'(', b')')?;
            cursor.skip_ws();
            if !cursor.eof() {
                continue;
            }
            let raw_args = split_top_level_by_char(&args_src, b',');
            let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
                Vec::new()
            } else {
                raw_args
            };
            if args.len() != 1 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Intl.DisplayNames.of requires exactly one argument".into(),
                ));
            }
            return Ok(Some(Expr::IntlDisplayNamesOf {
                display_names: Box::new(parse_expr(base_src)?),
                code: Box::new(parse_expr(args[0].trim())?),
            }));
        }

        if method_name == "select" {
            cursor.skip_ws();
            if cursor.peek() != Some(b'(') {
                continue;
            }
            let args_src = cursor.read_balanced_block(b'(', b')')?;
            cursor.skip_ws();
            if !cursor.eof() {
                continue;
            }
            let raw_args = split_top_level_by_char(&args_src, b',');
            let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
                Vec::new()
            } else {
                raw_args
            };
            if args.len() != 1 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Intl.PluralRules.select requires exactly one argument".into(),
                ));
            }
            return Ok(Some(Expr::IntlPluralRulesSelect {
                plural_rules: Box::new(parse_expr(base_src)?),
                value: Box::new(parse_expr(args[0].trim())?),
            }));
        }

        if method_name == "selectRange" {
            cursor.skip_ws();
            if cursor.peek() != Some(b'(') {
                continue;
            }
            let args_src = cursor.read_balanced_block(b'(', b')')?;
            cursor.skip_ws();
            if !cursor.eof() {
                continue;
            }
            let raw_args = split_top_level_by_char(&args_src, b',');
            let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
                Vec::new()
            } else {
                raw_args
            };
            if args.len() != 2 || args[0].trim().is_empty() || args[1].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Intl.PluralRules.selectRange requires exactly two arguments".into(),
                ));
            }
            return Ok(Some(Expr::IntlPluralRulesSelectRange {
                plural_rules: Box::new(parse_expr(base_src)?),
                start: Box::new(parse_expr(args[0].trim())?),
                end: Box::new(parse_expr(args[1].trim())?),
            }));
        }

        if method_name == "segment" {
            cursor.skip_ws();
            if cursor.peek() != Some(b'(') {
                continue;
            }
            let args_src = cursor.read_balanced_block(b'(', b')')?;
            cursor.skip_ws();
            if !cursor.eof() {
                continue;
            }
            let raw_args = split_top_level_by_char(&args_src, b',');
            let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
                Vec::new()
            } else {
                raw_args
            };
            if args.len() != 1 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Intl.Segmenter.segment requires exactly one argument".into(),
                ));
            }
            return Ok(Some(Expr::IntlSegmenterSegment {
                segmenter: Box::new(parse_expr(base_src)?),
                value: Box::new(parse_expr(args[0].trim())?),
            }));
        }

        let intl_locale_method = match method_name.as_str() {
            "getCalendars" => Some(IntlLocaleMethod::GetCalendars),
            "getCollations" => Some(IntlLocaleMethod::GetCollations),
            "getHourCycles" => Some(IntlLocaleMethod::GetHourCycles),
            "getNumberingSystems" => Some(IntlLocaleMethod::GetNumberingSystems),
            "getTextInfo" => Some(IntlLocaleMethod::GetTextInfo),
            "getTimeZones" => Some(IntlLocaleMethod::GetTimeZones),
            "getWeekInfo" => Some(IntlLocaleMethod::GetWeekInfo),
            "maximize" => Some(IntlLocaleMethod::Maximize),
            "minimize" => Some(IntlLocaleMethod::Minimize),
            "toString" => Some(IntlLocaleMethod::ToString),
            _ => None,
        };
        if let Some(method) = intl_locale_method {
            cursor.skip_ws();
            if cursor.peek() != Some(b'(') {
                continue;
            }
            let args_src = cursor.read_balanced_block(b'(', b')')?;
            cursor.skip_ws();
            if !cursor.eof() {
                continue;
            }
            let raw_args = split_top_level_by_char(&args_src, b',');
            let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
                Vec::new()
            } else {
                raw_args
            };
            if !args.is_empty() {
                return Err(Error::ScriptParse(format!(
                    "Intl.Locale.{method_name} does not take arguments"
                )));
            }
            return Ok(Some(Expr::IntlLocaleMethod {
                locale: Box::new(parse_expr(base_src)?),
                method,
            }));
        }

        if method_name == "resolvedOptions" {
            cursor.skip_ws();
            if cursor.peek() != Some(b'(') {
                continue;
            }
            let args_src = cursor.read_balanced_block(b'(', b')')?;
            cursor.skip_ws();
            if !cursor.eof() {
                continue;
            }
            let raw_args = split_top_level_by_char(&args_src, b',');
            let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
                Vec::new()
            } else {
                raw_args
            };
            if !args.is_empty() {
                return Err(Error::ScriptParse(
                    "Intl formatter resolvedOptions does not take arguments".into(),
                ));
            }
            return Ok(Some(Expr::IntlDateTimeResolvedOptions {
                formatter: Box::new(parse_expr(base_src)?),
            }));
        }

        if method_name == "format" {
            cursor.skip_ws();
            if cursor.eof() {
                return Ok(Some(Expr::IntlFormatGetter {
                    formatter: Box::new(parse_expr(base_src)?),
                }));
            }
            if cursor.peek() != Some(b'(') {
                continue;
            }
            let args_src = cursor.read_balanced_block(b'(', b')')?;
            cursor.skip_ws();
            if !cursor.eof() {
                continue;
            }

            let raw_args = split_top_level_by_char(&args_src, b',');
            let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
                Vec::new()
            } else {
                raw_args
            };
            if args.len() == 2 && !args[0].trim().is_empty() && !args[1].trim().is_empty() {
                return Ok(Some(Expr::IntlRelativeTimeFormat {
                    formatter: Box::new(parse_expr(base_src)?),
                    value: Box::new(parse_expr(args[0].trim())?),
                    unit: Box::new(parse_expr(args[1].trim())?),
                }));
            }
            if args.len() > 1 {
                return Err(Error::ScriptParse(
                    "Intl formatter format supports at most one argument".into(),
                ));
            }
            if args.len() == 1 && args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "Intl formatter format argument cannot be empty".into(),
                ));
            }

            return Ok(Some(Expr::IntlFormat {
                formatter: Box::new(parse_expr(base_src)?),
                value: args
                    .first()
                    .map(|arg| parse_expr(arg.trim()))
                    .transpose()?
                    .map(Box::new),
            }));
        }
    }

    Ok(None)
}

fn parse_string_method_expr(src: &str) -> Result<Option<Expr>> {
    let src = src.trim();
    let dots = collect_top_level_char_positions(src, b'.');
    for dot in dots.into_iter().rev() {
        let Some(base_src) = src.get(..dot) else {
            continue;
        };
        let base_src = base_src.trim();
        if base_src.is_empty() {
            continue;
        }
        let Some(tail_src) = src.get(dot + 1..) else {
            continue;
        };
        let tail_src = tail_src.trim();

        let mut cursor = Cursor::new(tail_src);
        let Some(method) = cursor.parse_identifier() else {
            continue;
        };
        cursor.skip_ws();
        if cursor.peek() != Some(b'(') {
            continue;
        }
        let args_src = cursor.read_balanced_block(b'(', b')')?;
        cursor.skip_ws();
        if !cursor.eof() {
            continue;
        }

        let raw_args = split_top_level_by_char(&args_src, b',');
        let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
            Vec::new()
        } else {
            raw_args
        };

        if !matches!(
            method.as_str(),
            "charAt"
                | "charCodeAt"
                | "codePointAt"
                | "at"
                | "concat"
                | "trim"
                | "trimStart"
                | "trimEnd"
                | "toUpperCase"
                | "toLocaleUpperCase"
                | "toLowerCase"
                | "toLocaleLowerCase"
                | "includes"
                | "startsWith"
                | "endsWith"
                | "slice"
                | "substring"
                | "match"
                | "split"
                | "replace"
                | "replaceAll"
                | "indexOf"
                | "lastIndexOf"
                | "search"
                | "repeat"
                | "padStart"
                | "padEnd"
                | "localeCompare"
                | "isWellFormed"
                | "toWellFormed"
                | "valueOf"
                | "toString"
        ) {
            continue;
        }

        if (method == "toString" || method == "valueOf") && !args.is_empty() {
            continue;
        }

        let base = Box::new(parse_expr(base_src)?);
        let expr = match method.as_str() {
            "charAt" => {
                if args.len() > 1 {
                    return Err(Error::ScriptParse(
                        "charAt supports zero or one argument".into(),
                    ));
                }
                if args.len() == 1 && args[0].trim().is_empty() {
                    return Err(Error::ScriptParse("charAt index cannot be empty".into()));
                }
                Expr::StringCharAt {
                    value: base,
                    index: args
                        .first()
                        .map(|arg| parse_expr(arg.trim()))
                        .transpose()?
                        .map(Box::new),
                }
            }
            "charCodeAt" => {
                if args.len() > 1 {
                    return Err(Error::ScriptParse(
                        "charCodeAt supports zero or one argument".into(),
                    ));
                }
                if args.len() == 1 && args[0].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "charCodeAt index cannot be empty".into(),
                    ));
                }
                Expr::StringCharCodeAt {
                    value: base,
                    index: args
                        .first()
                        .map(|arg| parse_expr(arg.trim()))
                        .transpose()?
                        .map(Box::new),
                }
            }
            "codePointAt" => {
                if args.len() > 1 {
                    return Err(Error::ScriptParse(
                        "codePointAt supports zero or one argument".into(),
                    ));
                }
                if args.len() == 1 && args[0].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "codePointAt index cannot be empty".into(),
                    ));
                }
                Expr::StringCodePointAt {
                    value: base,
                    index: args
                        .first()
                        .map(|arg| parse_expr(arg.trim()))
                        .transpose()?
                        .map(Box::new),
                }
            }
            "at" => {
                if args.len() > 1 {
                    return Err(Error::ScriptParse(
                        "at supports zero or one argument".into(),
                    ));
                }
                if args.len() == 1 && args[0].trim().is_empty() {
                    return Err(Error::ScriptParse("at index cannot be empty".into()));
                }
                Expr::StringAt {
                    value: base,
                    index: args
                        .first()
                        .map(|arg| parse_expr(arg.trim()))
                        .transpose()?
                        .map(Box::new),
                }
            }
            "concat" => {
                let mut parsed = Vec::with_capacity(args.len());
                for arg in args {
                    if arg.trim().is_empty() {
                        return Err(Error::ScriptParse("concat argument cannot be empty".into()));
                    }
                    parsed.push(parse_expr(arg.trim())?);
                }
                Expr::StringConcat {
                    value: base,
                    args: parsed,
                }
            }
            "trim" => {
                if !args.is_empty() {
                    return Err(Error::ScriptParse("trim does not take arguments".into()));
                }
                Expr::StringTrim {
                    value: base,
                    mode: StringTrimMode::Both,
                }
            }
            "trimStart" => {
                if !args.is_empty() {
                    return Err(Error::ScriptParse(
                        "trimStart does not take arguments".into(),
                    ));
                }
                Expr::StringTrim {
                    value: base,
                    mode: StringTrimMode::Start,
                }
            }
            "trimEnd" => {
                if !args.is_empty() {
                    return Err(Error::ScriptParse("trimEnd does not take arguments".into()));
                }
                Expr::StringTrim {
                    value: base,
                    mode: StringTrimMode::End,
                }
            }
            "toUpperCase" => {
                if !args.is_empty() {
                    return Err(Error::ScriptParse(
                        "toUpperCase does not take arguments".into(),
                    ));
                }
                Expr::StringToUpperCase(base)
            }
            "toLocaleUpperCase" => {
                if args.len() > 1 {
                    return Err(Error::ScriptParse(
                        "toLocaleUpperCase supports up to one argument".into(),
                    ));
                }
                if args.len() == 1 && args[0].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "toLocaleUpperCase locale cannot be empty".into(),
                    ));
                }
                Expr::StringToUpperCase(base)
            }
            "toLowerCase" => {
                if !args.is_empty() {
                    return Err(Error::ScriptParse(
                        "toLowerCase does not take arguments".into(),
                    ));
                }
                Expr::StringToLowerCase(base)
            }
            "toLocaleLowerCase" => {
                if args.len() > 1 {
                    return Err(Error::ScriptParse(
                        "toLocaleLowerCase supports up to one argument".into(),
                    ));
                }
                if args.len() == 1 && args[0].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "toLocaleLowerCase locale cannot be empty".into(),
                    ));
                }
                Expr::StringToLowerCase(base)
            }
            "includes" => {
                if args.is_empty() || args.len() > 2 || args[0].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "String.includes requires one or two arguments".into(),
                    ));
                }
                if args.len() == 2 && args[1].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "String.includes position cannot be empty".into(),
                    ));
                }
                Expr::StringIncludes {
                    value: base,
                    search: Box::new(parse_expr(args[0].trim())?),
                    position: if args.len() == 2 {
                        Some(Box::new(parse_expr(args[1].trim())?))
                    } else {
                        None
                    },
                }
            }
            "startsWith" => {
                if args.is_empty() || args.len() > 2 || args[0].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "startsWith requires one or two arguments".into(),
                    ));
                }
                if args.len() == 2 && args[1].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "startsWith position cannot be empty".into(),
                    ));
                }
                Expr::StringStartsWith {
                    value: base,
                    search: Box::new(parse_expr(args[0].trim())?),
                    position: if args.len() == 2 {
                        Some(Box::new(parse_expr(args[1].trim())?))
                    } else {
                        None
                    },
                }
            }
            "endsWith" => {
                if args.is_empty() || args.len() > 2 || args[0].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "endsWith requires one or two arguments".into(),
                    ));
                }
                if args.len() == 2 && args[1].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "endsWith length argument cannot be empty".into(),
                    ));
                }
                Expr::StringEndsWith {
                    value: base,
                    search: Box::new(parse_expr(args[0].trim())?),
                    length: if args.len() == 2 {
                        Some(Box::new(parse_expr(args[1].trim())?))
                    } else {
                        None
                    },
                }
            }
            "slice" => {
                if args.len() > 2 {
                    return Err(Error::ScriptParse(
                        "String.slice supports up to two arguments".into(),
                    ));
                }
                let start = if !args.is_empty() {
                    if args[0].trim().is_empty() {
                        return Err(Error::ScriptParse(
                            "String.slice start cannot be empty".into(),
                        ));
                    }
                    Some(Box::new(parse_expr(args[0].trim())?))
                } else {
                    None
                };
                let end = if args.len() == 2 {
                    if args[1].trim().is_empty() {
                        return Err(Error::ScriptParse(
                            "String.slice end cannot be empty".into(),
                        ));
                    }
                    Some(Box::new(parse_expr(args[1].trim())?))
                } else {
                    None
                };
                Expr::StringSlice {
                    value: base,
                    start,
                    end,
                }
            }
            "substring" => {
                if args.len() > 2 {
                    return Err(Error::ScriptParse(
                        "substring supports up to two arguments".into(),
                    ));
                }
                let start = if !args.is_empty() {
                    if args[0].trim().is_empty() {
                        return Err(Error::ScriptParse("substring start cannot be empty".into()));
                    }
                    Some(Box::new(parse_expr(args[0].trim())?))
                } else {
                    None
                };
                let end = if args.len() == 2 {
                    if args[1].trim().is_empty() {
                        return Err(Error::ScriptParse("substring end cannot be empty".into()));
                    }
                    Some(Box::new(parse_expr(args[1].trim())?))
                } else {
                    None
                };
                Expr::StringSubstring {
                    value: base,
                    start,
                    end,
                }
            }
            "match" => {
                if args.len() != 1 || args[0].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "match requires exactly one argument".into(),
                    ));
                }
                Expr::StringMatch {
                    value: base,
                    pattern: Box::new(parse_expr(args[0].trim())?),
                }
            }
            "split" => {
                if args.len() > 2 {
                    return Err(Error::ScriptParse(
                        "split supports up to two arguments".into(),
                    ));
                }
                let separator = if !args.is_empty() {
                    if args[0].trim().is_empty() {
                        return Err(Error::ScriptParse(
                            "split separator cannot be empty expression".into(),
                        ));
                    }
                    Some(Box::new(parse_expr(args[0].trim())?))
                } else {
                    None
                };
                let limit = if args.len() == 2 {
                    if args[1].trim().is_empty() {
                        return Err(Error::ScriptParse("split limit cannot be empty".into()));
                    }
                    Some(Box::new(parse_expr(args[1].trim())?))
                } else {
                    None
                };
                Expr::StringSplit {
                    value: base,
                    separator,
                    limit,
                }
            }
            "replace" => {
                if args.len() != 2 || args[0].trim().is_empty() || args[1].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "replace requires exactly two arguments".into(),
                    ));
                }
                Expr::StringReplace {
                    value: base,
                    from: Box::new(parse_expr(args[0].trim())?),
                    to: Box::new(parse_expr(args[1].trim())?),
                }
            }
            "replaceAll" => {
                if args.len() != 2 || args[0].trim().is_empty() || args[1].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "replaceAll requires exactly two arguments".into(),
                    ));
                }
                Expr::StringReplaceAll {
                    value: base,
                    from: Box::new(parse_expr(args[0].trim())?),
                    to: Box::new(parse_expr(args[1].trim())?),
                }
            }
            "indexOf" => {
                if args.is_empty() || args.len() > 2 || args[0].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "indexOf requires one or two arguments".into(),
                    ));
                }
                if args.len() == 2 && args[1].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "indexOf position cannot be empty".into(),
                    ));
                }
                Expr::StringIndexOf {
                    value: base,
                    search: Box::new(parse_expr(args[0].trim())?),
                    position: if args.len() == 2 {
                        Some(Box::new(parse_expr(args[1].trim())?))
                    } else {
                        None
                    },
                }
            }
            "lastIndexOf" => {
                if args.is_empty() || args.len() > 2 || args[0].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "lastIndexOf requires one or two arguments".into(),
                    ));
                }
                if args.len() == 2 && args[1].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "lastIndexOf position cannot be empty".into(),
                    ));
                }
                Expr::StringLastIndexOf {
                    value: base,
                    search: Box::new(parse_expr(args[0].trim())?),
                    position: if args.len() == 2 {
                        Some(Box::new(parse_expr(args[1].trim())?))
                    } else {
                        None
                    },
                }
            }
            "search" => {
                if args.len() != 1 || args[0].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "search requires exactly one argument".into(),
                    ));
                }
                Expr::StringSearch {
                    value: base,
                    pattern: Box::new(parse_expr(args[0].trim())?),
                }
            }
            "repeat" => {
                if args.len() != 1 || args[0].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "repeat requires exactly one argument".into(),
                    ));
                }
                Expr::StringRepeat {
                    value: base,
                    count: Box::new(parse_expr(args[0].trim())?),
                }
            }
            "padStart" => {
                if args.is_empty() || args.len() > 2 || args[0].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "padStart requires one or two arguments".into(),
                    ));
                }
                if args.len() == 2 && args[1].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "padStart pad string cannot be empty expression".into(),
                    ));
                }
                Expr::StringPadStart {
                    value: base,
                    target_length: Box::new(parse_expr(args[0].trim())?),
                    pad: if args.len() == 2 {
                        Some(Box::new(parse_expr(args[1].trim())?))
                    } else {
                        None
                    },
                }
            }
            "padEnd" => {
                if args.is_empty() || args.len() > 2 || args[0].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "padEnd requires one or two arguments".into(),
                    ));
                }
                if args.len() == 2 && args[1].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "padEnd pad string cannot be empty expression".into(),
                    ));
                }
                Expr::StringPadEnd {
                    value: base,
                    target_length: Box::new(parse_expr(args[0].trim())?),
                    pad: if args.len() == 2 {
                        Some(Box::new(parse_expr(args[1].trim())?))
                    } else {
                        None
                    },
                }
            }
            "localeCompare" => {
                if args.is_empty() || args.len() > 3 || args[0].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "localeCompare requires one to three arguments".into(),
                    ));
                }
                if args.len() >= 2 && args[1].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "localeCompare locales argument cannot be empty".into(),
                    ));
                }
                if args.len() == 3 && args[2].trim().is_empty() {
                    return Err(Error::ScriptParse(
                        "localeCompare options argument cannot be empty".into(),
                    ));
                }
                Expr::StringLocaleCompare {
                    value: base,
                    compare: Box::new(parse_expr(args[0].trim())?),
                    locales: if args.len() >= 2 {
                        Some(Box::new(parse_expr(args[1].trim())?))
                    } else {
                        None
                    },
                    options: if args.len() == 3 {
                        Some(Box::new(parse_expr(args[2].trim())?))
                    } else {
                        None
                    },
                }
            }
            "isWellFormed" => {
                if !args.is_empty() {
                    return Err(Error::ScriptParse(
                        "isWellFormed does not take arguments".into(),
                    ));
                }
                Expr::StringIsWellFormed(base)
            }
            "toWellFormed" => {
                if !args.is_empty() {
                    return Err(Error::ScriptParse(
                        "toWellFormed does not take arguments".into(),
                    ));
                }
                Expr::StringToWellFormed(base)
            }
            "valueOf" => Expr::StringValueOf(base),
            "toString" => Expr::StringToString(base),
            _ => unreachable!(),
        };

        return Ok(Some(expr));
    }

    Ok(None)
}

fn parse_date_method_expr(src: &str) -> Result<Option<Expr>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();
    let Some(target) = cursor.parse_identifier() else {
        return Ok(None);
    };
    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    let Some(method) = cursor.parse_identifier() else {
        return Ok(None);
    };
    cursor.skip_ws();
    if cursor.peek() != Some(b'(') {
        return Ok(None);
    }

    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let raw_args = split_top_level_by_char(&args_src, b',');
    let args = if raw_args.len() == 1 && raw_args[0].trim().is_empty() {
        Vec::new()
    } else {
        raw_args
    };

    let expr = match method.as_str() {
        "getTime" => {
            if !args.is_empty() {
                return Err(Error::ScriptParse("getTime does not take arguments".into()));
            }
            Expr::DateGetTime(target)
        }
        "setTime" => {
            if args.len() != 1 || args[0].trim().is_empty() {
                return Err(Error::ScriptParse(
                    "setTime requires exactly one argument".into(),
                ));
            }
            Expr::DateSetTime {
                target,
                value: Box::new(parse_expr(args[0].trim())?),
            }
        }
        "toISOString" => {
            if !args.is_empty() {
                return Err(Error::ScriptParse(
                    "toISOString does not take arguments".into(),
                ));
            }
            Expr::DateToIsoString(target)
        }
        "getFullYear" => {
            if !args.is_empty() {
                return Err(Error::ScriptParse(
                    "getFullYear does not take arguments".into(),
                ));
            }
            Expr::DateGetFullYear(target)
        }
        "getMonth" => {
            if !args.is_empty() {
                return Err(Error::ScriptParse(
                    "getMonth does not take arguments".into(),
                ));
            }
            Expr::DateGetMonth(target)
        }
        "getDate" => {
            if !args.is_empty() {
                return Err(Error::ScriptParse("getDate does not take arguments".into()));
            }
            Expr::DateGetDate(target)
        }
        "getHours" => {
            if !args.is_empty() {
                return Err(Error::ScriptParse(
                    "getHours does not take arguments".into(),
                ));
            }
            Expr::DateGetHours(target)
        }
        "getMinutes" => {
            if !args.is_empty() {
                return Err(Error::ScriptParse(
                    "getMinutes does not take arguments".into(),
                ));
            }
            Expr::DateGetMinutes(target)
        }
        "getSeconds" => {
            if !args.is_empty() {
                return Err(Error::ScriptParse(
                    "getSeconds does not take arguments".into(),
                ));
            }
            Expr::DateGetSeconds(target)
        }
        _ => return Ok(None),
    };

    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some(expr))
}

fn collect_top_level_char_positions(src: &str, target: u8) -> Vec<usize> {
    let bytes = src.as_bytes();
    let mut out = Vec::new();
    let mut i = 0usize;

    let mut paren = 0usize;
    let mut bracket = 0usize;
    let mut brace = 0usize;

    #[derive(Clone, Copy, PartialEq, Eq)]
    enum StrState {
        None,
        Single,
        Double,
        Backtick,
    }
    let mut state = StrState::None;

    while i < bytes.len() {
        let b = bytes[i];
        match state {
            StrState::None => match b {
                b'\'' => state = StrState::Single,
                b'"' => state = StrState::Double,
                b'`' => state = StrState::Backtick,
                b'(' => paren += 1,
                b')' => paren = paren.saturating_sub(1),
                b'[' => bracket += 1,
                b']' => bracket = bracket.saturating_sub(1),
                b'{' => brace += 1,
                b'}' => brace = brace.saturating_sub(1),
                _ => {
                    if b == target && paren == 0 && bracket == 0 && brace == 0 {
                        out.push(i);
                    }
                }
            },
            StrState::Single => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'\'' {
                    state = StrState::None;
                }
            }
            StrState::Double => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'"' {
                    state = StrState::None;
                }
            }
            StrState::Backtick => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'`' {
                    state = StrState::None;
                }
            }
        }
        i += 1;
    }

    out
}

fn parse_set_timeout_expr(src: &str) -> Result<Option<(TimerInvocation, Expr)>> {
    let mut cursor = Cursor::new(src);
    let Some((handler, delay_ms)) = parse_set_timeout_call(&mut cursor)? else {
        return Ok(None);
    };
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some((handler, delay_ms)))
}

fn parse_set_interval_expr(src: &str) -> Result<Option<(TimerInvocation, Expr)>> {
    let mut cursor = Cursor::new(src);
    let Some((handler, delay_ms)) = parse_set_interval_call(&mut cursor)? else {
        return Ok(None);
    };
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some((handler, delay_ms)))
}

fn parse_request_animation_frame_expr(src: &str) -> Result<Option<TimerCallback>> {
    let mut cursor = Cursor::new(src);
    let callback = parse_request_animation_frame_call(&mut cursor)?;
    cursor.skip_ws();
    if cursor.eof() { Ok(callback) } else { Ok(None) }
}

fn parse_request_animation_frame_call(cursor: &mut Cursor<'_>) -> Result<Option<TimerCallback>> {
    cursor.skip_ws();
    if cursor.consume_ascii("window") {
        cursor.skip_ws();
        if !cursor.consume_byte(b'.') {
            return Ok(None);
        }
        cursor.skip_ws();
    }

    if !cursor.consume_ascii("requestAnimationFrame") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            return Ok(None);
        }
    }
    cursor.skip_ws();

    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let args = split_top_level_by_char(&args_src, b',');
    if args.len() != 1 || args[0].trim().is_empty() {
        return Err(Error::ScriptParse(
            "requestAnimationFrame requires exactly one argument".into(),
        ));
    }

    let callback_arg = strip_js_comments(args[0]);
    let callback = parse_timer_callback("requestAnimationFrame", callback_arg.as_str().trim())?;
    Ok(Some(callback))
}

fn parse_queue_microtask_expr(src: &str) -> Result<Option<ScriptHandler>> {
    let mut cursor = Cursor::new(src);
    let handler = parse_queue_microtask_call(&mut cursor)?;
    cursor.skip_ws();
    if cursor.eof() { Ok(handler) } else { Ok(None) }
}

fn parse_queue_microtask_stmt(stmt: &str) -> Result<Option<Stmt>> {
    let stmt = stmt.trim();
    let mut cursor = Cursor::new(stmt);
    let Some(handler) = parse_queue_microtask_call(&mut cursor)? else {
        return Ok(None);
    };

    cursor.skip_ws();
    cursor.consume_byte(b';');
    cursor.skip_ws();
    if !cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "unsupported queueMicrotask statement tail: {stmt}"
        )));
    }

    Ok(Some(Stmt::QueueMicrotask { handler }))
}

fn parse_queue_microtask_call(cursor: &mut Cursor<'_>) -> Result<Option<ScriptHandler>> {
    cursor.skip_ws();
    if !cursor.consume_ascii("queueMicrotask") {
        return Ok(None);
    }

    cursor.skip_ws();
    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let args = split_top_level_by_char(&args_src, b',');
    if args.is_empty() {
        return Err(Error::ScriptParse(
            "queueMicrotask requires 1 argument".into(),
        ));
    }
    if args.len() != 1 {
        return Err(Error::ScriptParse(
            "queueMicrotask supports only 1 argument".into(),
        ));
    }

    let callback_arg = strip_js_comments(args[0]);
    let mut callback_cursor = Cursor::new(callback_arg.as_str().trim());
    let (params, body, _) = parse_callback(&mut callback_cursor, 1, "callback parameters")?;
    callback_cursor.skip_ws();
    if !callback_cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "unsupported queueMicrotask callback: {}",
            args[0].trim()
        )));
    }

    Ok(Some(ScriptHandler {
        params,
        stmts: parse_block_statements(&body)?,
    }))
}

fn parse_template_literal(src: &str) -> Result<Expr> {
    let inner = &src[1..src.len() - 1];
    let bytes = inner.as_bytes();

    let mut parts: Vec<Expr> = Vec::new();
    let mut text_start = 0usize;
    let mut i = 0usize;

    while i < bytes.len() {
        if bytes[i] == b'\\' {
            i = (i + 2).min(bytes.len());
            continue;
        }

        if bytes[i] == b'$' && i + 1 < bytes.len() && bytes[i + 1] == b'{' {
            if let Some(text) = inner.get(text_start..i) {
                let text = unescape_string(text);
                if !text.is_empty() {
                    parts.push(Expr::String(text));
                }
            }
            let expr_start = i + 2;
            let expr_end = find_matching_brace(inner, expr_start)?;
            let expr_src = inner
                .get(expr_start..expr_end)
                .ok_or_else(|| Error::ScriptParse("invalid template expression".into()))?;
            let expr = parse_expr(expr_src.trim())?;
            parts.push(expr);

            i = expr_end + 1;
            text_start = i;
            continue;
        }

        i += 1;
    }

    if let Some(text) = inner.get(text_start..) {
        let text = unescape_string(text);
        if !text.is_empty() {
            parts.push(Expr::String(text));
        }
    }

    if parts.is_empty() {
        return Ok(Expr::String(String::new()));
    }

    if parts.len() == 1 {
        return Ok(parts.remove(0));
    }

    Ok(Expr::Add(parts))
}

fn parse_dom_access(src: &str) -> Result<Option<(DomQuery, DomProp)>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    let target = match parse_element_target(&mut cursor) {
        Ok(target) => target,
        Err(_) => return Ok(None),
    };

    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();

    let head = cursor
        .parse_identifier()
        .ok_or_else(|| Error::ScriptParse(format!("expected property name in: {src}")))?;

    cursor.skip_ws();
    let nested = if cursor.consume_byte(b'.') {
        cursor.skip_ws();
        Some(
            cursor
                .parse_identifier()
                .ok_or_else(|| Error::ScriptParse(format!("expected nested property in: {src}")))?,
        )
    } else {
        None
    };

    let prop = match (head.as_str(), nested.as_ref()) {
        ("value", None) => DomProp::Value,
        ("checked", None) => DomProp::Checked,
        ("open", None) => DomProp::Open,
        ("returnValue", None) => DomProp::ReturnValue,
        ("closedBy", None) | ("closedby", None) => DomProp::ClosedBy,
        ("readonly", None) | ("readOnly", None) => DomProp::Readonly,
        ("required", None) => DomProp::Required,
        ("disabled", None) => DomProp::Disabled,
        ("textContent", None) => DomProp::TextContent,
        ("innerHTML", None) => DomProp::InnerHtml,
        ("className", None) => DomProp::ClassName,
        ("id", None) => DomProp::Id,
        ("name", None) => DomProp::Name,
        ("offsetWidth", None) => DomProp::OffsetWidth,
        ("offsetHeight", None) => DomProp::OffsetHeight,
        ("offsetLeft", None) => DomProp::OffsetLeft,
        ("offsetTop", None) => DomProp::OffsetTop,
        ("scrollWidth", None) => DomProp::ScrollWidth,
        ("scrollHeight", None) => DomProp::ScrollHeight,
        ("scrollLeft", None) => DomProp::ScrollLeft,
        ("scrollTop", None) => DomProp::ScrollTop,
        ("activeElement", None) if matches!(target, DomQuery::DocumentRoot) => {
            DomProp::ActiveElement
        }
        ("characterSet", None) | ("charset", None) | ("inputEncoding", None)
            if matches!(target, DomQuery::DocumentRoot) =>
        {
            DomProp::CharacterSet
        }
        ("compatMode", None) if matches!(target, DomQuery::DocumentRoot) => DomProp::CompatMode,
        ("contentType", None) if matches!(target, DomQuery::DocumentRoot) => DomProp::ContentType,
        ("readyState", None) if matches!(target, DomQuery::DocumentRoot) => DomProp::ReadyState,
        ("referrer", None) if matches!(target, DomQuery::DocumentRoot) => DomProp::Referrer,
        ("title", None) if matches!(target, DomQuery::DocumentRoot) => DomProp::Title,
        ("URL", None) if matches!(target, DomQuery::DocumentRoot) => DomProp::Url,
        ("documentURI", None) if matches!(target, DomQuery::DocumentRoot) => DomProp::DocumentUri,
        ("location", None) if matches!(target, DomQuery::DocumentRoot) => DomProp::Location,
        ("location", Some(href)) if matches!(target, DomQuery::DocumentRoot) && href == "href" => {
            DomProp::LocationHref
        }
        ("location", Some(protocol))
            if matches!(target, DomQuery::DocumentRoot) && protocol == "protocol" =>
        {
            DomProp::LocationProtocol
        }
        ("location", Some(host)) if matches!(target, DomQuery::DocumentRoot) && host == "host" => {
            DomProp::LocationHost
        }
        ("location", Some(hostname))
            if matches!(target, DomQuery::DocumentRoot) && hostname == "hostname" =>
        {
            DomProp::LocationHostname
        }
        ("location", Some(port)) if matches!(target, DomQuery::DocumentRoot) && port == "port" => {
            DomProp::LocationPort
        }
        ("location", Some(pathname))
            if matches!(target, DomQuery::DocumentRoot) && pathname == "pathname" =>
        {
            DomProp::LocationPathname
        }
        ("location", Some(search))
            if matches!(target, DomQuery::DocumentRoot) && search == "search" =>
        {
            DomProp::LocationSearch
        }
        ("location", Some(hash)) if matches!(target, DomQuery::DocumentRoot) && hash == "hash" => {
            DomProp::LocationHash
        }
        ("location", Some(origin))
            if matches!(target, DomQuery::DocumentRoot) && origin == "origin" =>
        {
            DomProp::LocationOrigin
        }
        ("location", Some(ancestor_origins))
            if matches!(target, DomQuery::DocumentRoot)
                && ancestor_origins == "ancestorOrigins" =>
        {
            DomProp::LocationAncestorOrigins
        }
        ("history", None) if matches!(target, DomQuery::DocumentRoot) => DomProp::History,
        ("history", Some(length))
            if matches!(target, DomQuery::DocumentRoot) && length == "length" =>
        {
            DomProp::HistoryLength
        }
        ("history", Some(state))
            if matches!(target, DomQuery::DocumentRoot) && state == "state" =>
        {
            DomProp::HistoryState
        }
        ("history", Some(scroll_restoration))
            if matches!(target, DomQuery::DocumentRoot)
                && scroll_restoration == "scrollRestoration" =>
        {
            DomProp::HistoryScrollRestoration
        }
        ("defaultView", None) if matches!(target, DomQuery::DocumentRoot) => DomProp::DefaultView,
        ("hidden", None) if matches!(target, DomQuery::DocumentRoot) => DomProp::Hidden,
        ("visibilityState", None) if matches!(target, DomQuery::DocumentRoot) => {
            DomProp::VisibilityState
        }
        ("forms", None) if matches!(target, DomQuery::DocumentRoot) => DomProp::Forms,
        ("images", None) if matches!(target, DomQuery::DocumentRoot) => DomProp::Images,
        ("links", None) if matches!(target, DomQuery::DocumentRoot) => DomProp::Links,
        ("scripts", None) if matches!(target, DomQuery::DocumentRoot) => DomProp::Scripts,
        ("children", None) if matches!(target, DomQuery::DocumentRoot) => DomProp::Children,
        ("childElementCount", None) if matches!(target, DomQuery::DocumentRoot) => {
            DomProp::ChildElementCount
        }
        ("firstElementChild", None) if matches!(target, DomQuery::DocumentRoot) => {
            DomProp::FirstElementChild
        }
        ("lastElementChild", None) if matches!(target, DomQuery::DocumentRoot) => {
            DomProp::LastElementChild
        }
        ("currentScript", None) if matches!(target, DomQuery::DocumentRoot) => {
            DomProp::CurrentScript
        }
        ("forms", Some(length))
            if matches!(target, DomQuery::DocumentRoot) && length == "length" =>
        {
            DomProp::FormsLength
        }
        ("images", Some(length))
            if matches!(target, DomQuery::DocumentRoot) && length == "length" =>
        {
            DomProp::ImagesLength
        }
        ("links", Some(length))
            if matches!(target, DomQuery::DocumentRoot) && length == "length" =>
        {
            DomProp::LinksLength
        }
        ("scripts", Some(length))
            if matches!(target, DomQuery::DocumentRoot) && length == "length" =>
        {
            DomProp::ScriptsLength
        }
        ("children", Some(length))
            if matches!(target, DomQuery::DocumentRoot) && length == "length" =>
        {
            DomProp::ChildrenLength
        }
        ("dataset", Some(key)) => DomProp::Dataset(key.clone()),
        ("style", Some(name)) => DomProp::Style(name.clone()),
        _ => {
            let src_trimmed = src.trim_start();
            if matches!(target, DomQuery::DocumentRoot)
                && src_trimmed.starts_with("window.")
                && matches!(
                    head.as_str(),
                    "window"
                        | "self"
                        | "top"
                        | "parent"
                        | "frames"
                        | "length"
                        | "closed"
                        | "document"
                        | "navigator"
                        | "clientInformation"
                        | "origin"
                        | "isSecureContext"
                        | "name"
                )
            {
                return Ok(None);
            }
            if matches!(target, DomQuery::Var(_) | DomQuery::VarPath { .. }) {
                return Ok(None);
            }
            let prop_label = if let Some(nested) = nested {
                format!("{head}.{nested}")
            } else {
                head
            };
            return Err(Error::ScriptParse(format!(
                "unsupported DOM property '{}' in: {src}",
                prop_label
            )));
        }
    };

    Ok(Some((target, prop)))
}

fn parse_get_attribute_expr(src: &str) -> Result<Option<(DomQuery, String)>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();
    let target = match parse_element_target(&mut cursor) {
        Ok(target) => target,
        Err(_) => return Ok(None),
    };

    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.consume_ascii("getAttribute") {
        return Ok(None);
    }
    cursor.skip_ws();
    cursor.expect_byte(b'(')?;
    cursor.skip_ws();
    let name = cursor.parse_string_literal()?;
    cursor.skip_ws();
    cursor.expect_byte(b')')?;
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }

    Ok(Some((target, name)))
}

fn parse_has_attribute_expr(src: &str) -> Result<Option<(DomQuery, String)>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();
    let target = match parse_element_target(&mut cursor) {
        Ok(target) => target,
        Err(_) => return Ok(None),
    };

    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.consume_ascii("hasAttribute") {
        return Ok(None);
    }
    cursor.skip_ws();
    cursor.expect_byte(b'(')?;
    cursor.skip_ws();
    let name = cursor.parse_string_literal()?;
    cursor.skip_ws();
    cursor.expect_byte(b')')?;
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }

    Ok(Some((target, name)))
}

fn parse_dom_matches_expr(src: &str) -> Result<Option<(DomQuery, String)>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();
    let target = match parse_element_target(&mut cursor) {
        Ok(target) => target,
        Err(_) => return Ok(None),
    };

    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.consume_ascii("matches") {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.consume_byte(b'(') {
        return Ok(None);
    }
    cursor.skip_ws();
    let selector = cursor.parse_string_literal()?;
    cursor.skip_ws();
    cursor.expect_byte(b')')?;
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }

    Ok(Some((target, selector)))
}

fn parse_dom_closest_expr(src: &str) -> Result<Option<(DomQuery, String)>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();
    let target = match parse_element_target(&mut cursor) {
        Ok(target) => target,
        Err(_) => return Ok(None),
    };

    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.consume_ascii("closest") {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.consume_byte(b'(') {
        return Ok(None);
    }
    cursor.skip_ws();
    let selector = cursor.parse_string_literal()?;
    cursor.skip_ws();
    cursor.expect_byte(b')')?;
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }

    Ok(Some((target, selector)))
}

fn parse_dom_computed_style_property_expr(src: &str) -> Result<Option<(DomQuery, String)>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();
    if !cursor.consume_ascii("getComputedStyle") {
        return Ok(None);
    }
    cursor.skip_ws();
    cursor.expect_byte(b'(')?;
    cursor.skip_ws();
    let target = parse_element_target(&mut cursor)?;
    cursor.skip_ws();
    cursor.expect_byte(b')')?;
    cursor.skip_ws();
    cursor.expect_byte(b'.')?;
    cursor.skip_ws();
    if !cursor.consume_ascii("getPropertyValue") {
        return Ok(None);
    }
    cursor.skip_ws();
    cursor.expect_byte(b'(')?;
    cursor.skip_ws();
    let property = cursor.parse_string_literal()?;
    cursor.skip_ws();
    cursor.expect_byte(b')')?;
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some((target, property)))
}

fn parse_event_property_expr(src: &str) -> Result<Option<(String, EventExprProp)>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    let Some(event_var) = cursor.parse_identifier() else {
        return Ok(None);
    };
    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    let Some(head) = cursor.parse_identifier() else {
        return Ok(None);
    };

    let mut nested = None;
    cursor.skip_ws();
    if cursor.consume_byte(b'.') {
        cursor.skip_ws();
        nested = cursor.parse_identifier();
    }
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }

    if event_var == "history"
        && matches!(
            (head.as_str(), nested.as_deref()),
            ("state", None) | ("oldState", None) | ("newState", None)
        )
    {
        return Ok(None);
    }

    let prop = match (head.as_str(), nested.as_deref()) {
        ("type", None) => EventExprProp::Type,
        ("target", None) => EventExprProp::Target,
        ("currentTarget", None) => EventExprProp::CurrentTarget,
        ("target", Some("name")) => EventExprProp::TargetName,
        ("currentTarget", Some("name")) => EventExprProp::CurrentTargetName,
        ("defaultPrevented", None) => EventExprProp::DefaultPrevented,
        ("isTrusted", None) => EventExprProp::IsTrusted,
        ("bubbles", None) => EventExprProp::Bubbles,
        ("cancelable", None) => EventExprProp::Cancelable,
        ("target", Some("id")) => EventExprProp::TargetId,
        ("currentTarget", Some("id")) => EventExprProp::CurrentTargetId,
        ("eventPhase", None) => EventExprProp::EventPhase,
        ("timeStamp", None) => EventExprProp::TimeStamp,
        ("state", None) => EventExprProp::State,
        ("oldState", None) => EventExprProp::OldState,
        ("newState", None) => EventExprProp::NewState,
        _ => return Ok(None),
    };

    Ok(Some((event_var, prop)))
}

fn parse_class_list_contains_expr(src: &str) -> Result<Option<(DomQuery, String)>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    let target = match parse_element_target(&mut cursor) {
        Ok(target) => target,
        Err(_) => return Ok(None),
    };

    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.consume_ascii("classList") {
        return Ok(None);
    }
    cursor.skip_ws();
    cursor.expect_byte(b'.')?;
    cursor.skip_ws();
    if !cursor.consume_ascii("contains") {
        return Ok(None);
    }
    cursor.skip_ws();
    cursor.expect_byte(b'(')?;
    cursor.skip_ws();
    let class_name = cursor.parse_string_literal()?;
    cursor.skip_ws();
    cursor.expect_byte(b')')?;
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }

    Ok(Some((target, class_name)))
}

fn parse_query_selector_all_length_expr(src: &str) -> Result<Option<DomQuery>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    let target = match parse_element_target(&mut cursor) {
        Ok(target) => target,
        Err(_) => return Ok(None),
    };
    let is_list_target = matches!(
        target,
        DomQuery::BySelectorAll { .. } | DomQuery::QuerySelectorAll { .. } | DomQuery::Var(_)
    );
    if !is_list_target {
        return Ok(None);
    }

    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.consume_ascii("length") {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }

    Ok(Some(target))
}

fn parse_form_elements_length_expr(src: &str) -> Result<Option<DomQuery>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();
    let form = match parse_form_elements_base(&mut cursor) {
        Ok(target) => target,
        Err(_) => return Ok(None),
    };
    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.consume_ascii("elements") {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.consume_ascii("length") {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some(form))
}

fn parse_new_form_data_expr(src: &str) -> Result<Option<DomQuery>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();
    let Some(form) = parse_new_form_data_target(&mut cursor)? else {
        return Ok(None);
    };
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }
    Ok(Some(form))
}

fn parse_form_data_get_expr(src: &str) -> Result<Option<(FormDataSource, String)>> {
    parse_form_data_method_expr(src, "get")
}

fn parse_form_data_has_expr(src: &str) -> Result<Option<(FormDataSource, String)>> {
    parse_form_data_method_expr(src, "has")
}

fn parse_form_data_get_all_expr(src: &str) -> Result<Option<(FormDataSource, String)>> {
    parse_form_data_method_expr(src, "getAll")
}

fn parse_form_data_get_all_length_expr(src: &str) -> Result<Option<(FormDataSource, String)>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    let Some(source) = parse_form_data_source(&mut cursor)? else {
        return Ok(None);
    };

    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    let Some(method) = cursor.parse_identifier() else {
        return Ok(None);
    };
    if method != "getAll" {
        return Ok(None);
    }

    cursor.skip_ws();
    cursor.expect_byte(b'(')?;
    cursor.skip_ws();
    let name = cursor.parse_string_literal()?;
    cursor.skip_ws();
    cursor.expect_byte(b')')?;
    cursor.skip_ws();

    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.consume_ascii("length") {
        return Ok(None);
    }
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }

    Ok(Some((source, name)))
}

fn parse_form_data_method_expr(
    src: &str,
    method: &str,
) -> Result<Option<(FormDataSource, String)>> {
    let mut cursor = Cursor::new(src);
    cursor.skip_ws();

    let Some(source) = parse_form_data_source(&mut cursor)? else {
        return Ok(None);
    };

    cursor.skip_ws();
    if !cursor.consume_byte(b'.') {
        return Ok(None);
    }
    cursor.skip_ws();
    let Some(actual_method) = cursor.parse_identifier() else {
        return Ok(None);
    };
    if actual_method != method {
        return Ok(None);
    }
    cursor.skip_ws();
    cursor.expect_byte(b'(')?;
    cursor.skip_ws();
    let name = cursor.parse_string_literal()?;
    cursor.skip_ws();
    cursor.expect_byte(b')')?;
    cursor.skip_ws();
    if !cursor.eof() {
        return Ok(None);
    }

    Ok(Some((source, name)))
}

fn parse_form_data_source(cursor: &mut Cursor<'_>) -> Result<Option<FormDataSource>> {
    if let Some(form) = parse_new_form_data_target(cursor)? {
        return Ok(Some(FormDataSource::NewForm(form)));
    }

    if let Some(var_name) = cursor.parse_identifier() {
        return Ok(Some(FormDataSource::Var(var_name)));
    }

    Ok(None)
}

fn parse_new_form_data_target(cursor: &mut Cursor<'_>) -> Result<Option<DomQuery>> {
    cursor.skip_ws();
    let start = cursor.pos();

    if !cursor.consume_ascii("new") {
        return Ok(None);
    }
    if let Some(next) = cursor.peek() {
        if is_ident_char(next) {
            cursor.set_pos(start);
            return Ok(None);
        }
    }
    cursor.skip_ws();
    if !cursor.consume_ascii("FormData") {
        cursor.set_pos(start);
        return Ok(None);
    }
    cursor.skip_ws();

    let args_src = cursor.read_balanced_block(b'(', b')')?;
    let args = split_top_level_by_char(args_src.trim(), b',');
    if args.len() != 1 {
        return Err(Error::ScriptParse(
            "new FormData requires exactly one argument".into(),
        ));
    }

    let arg = args[0].trim();
    let mut arg_cursor = Cursor::new(arg);
    arg_cursor.skip_ws();
    let form = parse_form_elements_base(&mut arg_cursor)?;
    arg_cursor.skip_ws();
    if !arg_cursor.eof() {
        return Err(Error::ScriptParse(format!(
            "unsupported FormData argument: {arg}"
        )));
    }

    Ok(Some(form))
}

fn parse_string_literal_exact(src: &str) -> Result<String> {
    let bytes = src.as_bytes();
    if bytes.len() < 2 {
        return Err(Error::ScriptParse("invalid string literal".into()));
    }
    let quote = bytes[0];
    if (quote != b'\'' && quote != b'"') || bytes[bytes.len() - 1] != quote {
        return Err(Error::ScriptParse(format!("invalid string literal: {src}")));
    }

    let mut escaped = false;
    let mut i = 1;
    while i + 1 < bytes.len() {
        let b = bytes[i];
        if escaped {
            escaped = false;
        } else if b == b'\\' {
            escaped = true;
        } else if b == quote {
            return Err(Error::ScriptParse(format!("unexpected quote in: {src}")));
        }
        i += 1;
    }

    Ok(unescape_string(&src[1..src.len() - 1]))
}

fn unescape_string(src: &str) -> String {
    let mut out = String::new();
    let chars = src.chars().collect::<Vec<_>>();
    let mut i = 0usize;
    while i < chars.len() {
        if chars[i] == '\\' && i + 1 < chars.len() {
            match chars[i + 1] {
                'n' => {
                    out.push('\n');
                    i += 2;
                }
                'r' => {
                    out.push('\r');
                    i += 2;
                }
                't' => {
                    out.push('\t');
                    i += 2;
                }
                '\\' => {
                    out.push('\\');
                    i += 2;
                }
                '\'' => {
                    out.push('\'');
                    i += 2;
                }
                '"' => {
                    out.push('"');
                    i += 2;
                }
                '`' => {
                    out.push('`');
                    i += 2;
                }
                '$' => {
                    out.push('$');
                    i += 2;
                }
                'u' if i + 5 < chars.len() => {
                    let hex = [chars[i + 2], chars[i + 3], chars[i + 4], chars[i + 5]];
                    let mut parsed = String::new();
                    for ch in hex {
                        parsed.push(ch);
                    }
                    if parsed.chars().all(|ch| ch.is_ascii_hexdigit()) {
                        if let Ok(codepoint) = u32::from_str_radix(&parsed, 16) {
                            if let Some(ch) = char::from_u32(codepoint) {
                                out.push(ch);
                                i += 6;
                                continue;
                            }
                        }
                    }
                    out.push('u');
                    i += 2;
                }
                'x' if i + 3 < chars.len() => {
                    let hex = [chars[i + 2], chars[i + 3]];
                    let mut parsed = String::new();
                    for ch in hex {
                        parsed.push(ch);
                    }
                    if parsed.chars().all(|ch| ch.is_ascii_hexdigit()) {
                        if let Ok(codepoint) = u32::from_str_radix(&parsed, 16) {
                            if let Some(ch) = char::from_u32(codepoint) {
                                out.push(ch);
                                i += 4;
                                continue;
                            }
                        }
                    }
                    out.push('x');
                    i += 2;
                }
                other => {
                    out.push(other);
                    i += 2;
                }
            }
        } else {
            out.push(chars[i]);
            i += 1;
        }
    }
    out
}

fn decode_html_character_references(src: &str) -> String {
    if !src.contains('&') {
        return src.to_string();
    }

    fn is_entity_token_char(ch: char) -> bool {
        ch.is_ascii_alphanumeric() || ch == '#' || ch == 'x' || ch == 'X'
    }

    fn decode_numeric(value: &str) -> Option<char> {
        let codepoint =
            if let Some(hex) = value.strip_prefix("x").or_else(|| value.strip_prefix("X")) {
                u32::from_str_radix(hex, 16).ok()?
            } else {
                u32::from_str_radix(value, 10).ok()?
            };
        char::from_u32(codepoint)
    }

    fn decode_named(value: &str) -> Option<char> {
        match value {
            "amp" => Some('&'),
            "lt" => Some('<'),
            "gt" => Some('>'),
            "quot" => Some('"'),
            "apos" => Some('\''),
            "nbsp" => Some('\u{00A0}'),
            "divide" => Some(''),
            "times" => Some(''),
            "ensp" => Some('\u{2002}'),
            "emsp" => Some('\u{2003}'),
            "thinsp" => Some('\u{2009}'),
            "copy" => Some(''),
            "reg" => Some(''),
            "trade" => Some(''),
            "euro" => Some(''),
            "pound" => Some(''),
            "yen" => Some(''),
            "laquo" => Some(''),
            "raquo" => Some(''),
            "ldquo" => Some(''),
            "rdquo" => Some(''),
            "lsquo" => Some(''),
            "rsquo" => Some(''),
            "hellip" => Some(''),
            "middot" => Some(''),
            "frac14" => Some(''),
            "frac12" => Some(''),
            "frac34" => Some(''),
            "frac13" => Some('\u{2153}'),
            "frac15" => Some('\u{2155}'),
            "frac16" => Some('\u{2159}'),
            "frac18" => Some('\u{215B}'),
            "frac23" => Some('\u{2154}'),
            "frac25" => Some('\u{2156}'),
            "frac35" => Some('\u{2157}'),
            "frac38" => Some('\u{215C}'),
            "frac45" => Some('\u{2158}'),
            "frac56" => Some('\u{215A}'),
            "frac58" => Some('\u{215E}'),
            "not" => Some(''),
            "deg" => Some(''),
            "plusmn" => Some(''),
            "larr" => Some(''),
            "rarr" => Some(''),
            _ => None,
        }
    }

    let mut out = String::with_capacity(src.len());
    let mut i = 0usize;

    while i < src.len() {
        let ch = src[i..].chars().next().unwrap_or_default();
        if ch != '&' {
            out.push(ch);
            i += ch.len_utf8();
            continue;
        }

        let tail = &src[i + 1..];
        let mut semicolon_end = None;
        if let Some(semicolon_pos) = tail.find(';') {
            match tail.find('&') {
                Some(next_amp_pos) if next_amp_pos < semicolon_pos => {}
                _ => semicolon_end = Some(semicolon_pos),
            }
        }

        let Some(end_offset) = semicolon_end else {
            let entity_end = tail
                .char_indices()
                .find_map(|(idx, ch)| {
                    if is_entity_token_char(ch) {
                        None
                    } else {
                        Some(idx)
                    }
                })
                .unwrap_or(tail.len());

            if entity_end == 0 {
                out.push('&');
                i += 1;
                continue;
            }

            let raw = &tail[..entity_end];
            let decoded = if let Some(rest) = raw.strip_prefix('#') {
                decode_numeric(rest)
            } else {
                decode_named(raw)
            };

            if let Some(value) = decoded {
                out.push(value);
                i += entity_end + 1;
            } else {
                out.push('&');
                i += 1;
            }
            continue;
        };

        let raw = &tail[..end_offset];
        let decoded = if let Some(rest) = raw.strip_prefix('#') {
            decode_numeric(rest)
        } else {
            decode_named(raw)
        };

        if let Some(value) = decoded {
            out.push(value);
            i += end_offset + 2;
        } else {
            out.push('&');
            i += 1;
        }
    }

    out
}

fn strip_outer_parens(mut src: &str) -> &str {
    loop {
        let trimmed = src.trim();
        if !trimmed.starts_with('(') || !trimmed.ends_with(')') {
            return trimmed;
        }

        if !is_fully_wrapped_in_parens(trimmed) {
            return trimmed;
        }

        src = &trimmed[1..trimmed.len() - 1];
    }
}

fn is_fully_wrapped_in_parens(src: &str) -> bool {
    let bytes = src.as_bytes();
    let mut depth = 0isize;
    let mut i = 0usize;

    #[derive(Clone, Copy, PartialEq, Eq)]
    enum StrState {
        None,
        Single,
        Double,
        Backtick,
    }
    let mut state = StrState::None;

    while i < bytes.len() {
        let b = bytes[i];
        match state {
            StrState::None => match b {
                b'\'' => state = StrState::Single,
                b'"' => state = StrState::Double,
                b'`' => state = StrState::Backtick,
                b'(' => depth += 1,
                b')' => {
                    depth -= 1;
                    if depth == 0 && i + 1 < bytes.len() {
                        return false;
                    }
                }
                _ => {}
            },
            StrState::Single => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'\'' {
                    state = StrState::None;
                }
            }
            StrState::Double => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'"' {
                    state = StrState::None;
                }
            }
            StrState::Backtick => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'`' {
                    state = StrState::None;
                }
            }
        }
        i += 1;
    }

    depth == 0
}

fn find_top_level_assignment(src: &str) -> Option<(usize, usize)> {
    let bytes = src.as_bytes();
    let mut i = 0usize;

    let mut paren = 0usize;
    let mut bracket = 0usize;
    let mut brace = 0usize;

    #[derive(Clone, Copy, PartialEq, Eq)]
    enum StrState {
        None,
        Single,
        Double,
        Backtick,
    }
    let mut state = StrState::None;

    while i < bytes.len() {
        let b = bytes[i];
        match state {
            StrState::None => match b {
                b'\'' => state = StrState::Single,
                b'"' => state = StrState::Double,
                b'`' => state = StrState::Backtick,
                b'(' => paren += 1,
                b')' => paren = paren.saturating_sub(1),
                b'[' => bracket += 1,
                b']' => bracket = bracket.saturating_sub(1),
                b'{' => brace += 1,
                b'}' => brace = brace.saturating_sub(1),
                b'=' => {
                    if paren == 0 && bracket == 0 && brace == 0 {
                        if i + 1 < bytes.len() && bytes[i + 1] == b'=' {
                            if i + 2 < bytes.len() && bytes[i + 2] == b'=' {
                                i += 2;
                            } else {
                                i += 1;
                            }
                        } else if i >= 2 && &bytes[i - 2..=i] == b"&&=" {
                            return Some((i - 2, 3));
                        } else if i >= 2 && &bytes[i - 2..=i] == b"||=" {
                            return Some((i - 2, 3));
                        } else if i >= 2 && &bytes[i - 2..=i] == b"??=" {
                            return Some((i - 2, 3));
                        } else if i >= 2 && &bytes[i - 2..=i] == b"**=" {
                            return Some((i - 2, 3));
                        } else if i >= 3 && &bytes[i - 3..=i] == b">>>=" {
                            return Some((i - 3, 4));
                        } else if i >= 2 && &bytes[i - 2..=i] == b"<<=" {
                            return Some((i - 2, 3));
                        } else if i >= 2 && &bytes[i - 2..=i] == b">>=" {
                            return Some((i - 2, 3));
                        } else if i > 0
                            && matches!(
                                bytes[i - 1],
                                b'+' | b'-' | b'*' | b'/' | b'%' | b'&' | b'|' | b'^'
                            )
                        {
                            return Some((i - 1, 2));
                        } else {
                            return Some((i, 1));
                        }
                    }
                }
                _ => {}
            },
            StrState::Single => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'\'' {
                    state = StrState::None;
                }
            }
            StrState::Double => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'"' {
                    state = StrState::None;
                }
            }
            StrState::Backtick => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'`' {
                    state = StrState::None;
                }
            }
        }
        i += 1;
    }

    None
}

fn find_top_level_ternary_question(src: &str) -> Option<usize> {
    let bytes = src.as_bytes();
    let mut i = 0usize;

    let mut paren = 0usize;
    let mut bracket = 0usize;
    let mut brace = 0usize;

    #[derive(Clone, Copy, PartialEq, Eq)]
    enum StrState {
        None,
        Single,
        Double,
        Backtick,
    }
    let mut state = StrState::None;

    while i < bytes.len() {
        let b = bytes[i];
        match state {
            StrState::None => match b {
                b'\'' => state = StrState::Single,
                b'"' => state = StrState::Double,
                b'`' => state = StrState::Backtick,
                b'(' => paren += 1,
                b')' => paren = paren.saturating_sub(1),
                b'[' => bracket += 1,
                b']' => bracket = bracket.saturating_sub(1),
                b'{' => brace += 1,
                b'}' => brace = brace.saturating_sub(1),
                b'?' if paren == 0 && bracket == 0 && brace == 0 => {
                    if i + 1 < bytes.len() && bytes[i + 1] == b'?' {
                        i += 1;
                    } else {
                        return Some(i);
                    }
                }
                _ => {}
            },
            StrState::Single => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'\'' {
                    state = StrState::None;
                }
            }
            StrState::Double => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'"' {
                    state = StrState::None;
                }
            }
            StrState::Backtick => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'`' {
                    state = StrState::None;
                }
            }
        }

        i += 1;
    }

    None
}

fn find_matching_ternary_colon(src: &str, from: usize) -> Option<usize> {
    let bytes = src.as_bytes();
    let mut i = from;

    let mut paren = 0usize;
    let mut bracket = 0usize;
    let mut brace = 0usize;
    let mut nested_ternary = 0usize;

    #[derive(Clone, Copy, PartialEq, Eq)]
    enum StrState {
        None,
        Single,
        Double,
        Backtick,
    }
    let mut state = StrState::None;

    while i < bytes.len() {
        let b = bytes[i];
        match state {
            StrState::None => match b {
                b'\'' => state = StrState::Single,
                b'"' => state = StrState::Double,
                b'`' => state = StrState::Backtick,
                b'(' => paren += 1,
                b')' => paren = paren.saturating_sub(1),
                b'[' => bracket += 1,
                b']' => bracket = bracket.saturating_sub(1),
                b'{' => brace += 1,
                b'}' => brace = brace.saturating_sub(1),
                b'?' if paren == 0 && bracket == 0 && brace == 0 => {
                    if i + 1 < bytes.len() && bytes[i + 1] == b'?' {
                        i += 1;
                    } else {
                        nested_ternary += 1;
                    }
                }
                b':' if paren == 0 && bracket == 0 && brace == 0 => {
                    if nested_ternary == 0 {
                        return Some(i);
                    }
                    nested_ternary -= 1;
                }
                _ => {}
            },
            StrState::Single => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'\'' {
                    state = StrState::None;
                }
            }
            StrState::Double => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'"' {
                    state = StrState::None;
                }
            }
            StrState::Backtick => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'`' {
                    state = StrState::None;
                }
            }
        }

        i += 1;
    }

    None
}

fn split_top_level_by_char(src: &str, target: u8) -> Vec<&str> {
    let bytes = src.as_bytes();
    let mut parts = Vec::new();
    let mut start = 0usize;
    let mut i = 0usize;

    let mut paren = 0usize;
    let mut bracket = 0usize;
    let mut brace = 0usize;

    #[derive(Clone, Copy, PartialEq, Eq)]
    enum StrState {
        None,
        Single,
        Double,
        Backtick,
    }
    let mut state = StrState::None;

    while i < bytes.len() {
        let b = bytes[i];
        match state {
            StrState::None => match b {
                b'\'' => state = StrState::Single,
                b'"' => state = StrState::Double,
                b'`' => state = StrState::Backtick,
                b'(' => paren += 1,
                b')' => paren = paren.saturating_sub(1),
                b'[' => bracket += 1,
                b']' => bracket = bracket.saturating_sub(1),
                b'{' => brace += 1,
                b'}' => brace = brace.saturating_sub(1),
                _ => {
                    if b == target && paren == 0 && bracket == 0 && brace == 0 {
                        if let Some(part) = src.get(start..i) {
                            parts.push(part);
                        }
                        start = i + 1;
                    }
                }
            },
            StrState::Single => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'\'' {
                    state = StrState::None;
                }
            }
            StrState::Double => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'"' {
                    state = StrState::None;
                }
            }
            StrState::Backtick => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'`' {
                    state = StrState::None;
                }
            }
        }

        i += 1;
    }

    if let Some(last) = src.get(start..) {
        parts.push(last);
    }

    parts
}

fn split_top_level_by_ops<'a>(src: &'a str, ops: &[&'a str]) -> (Vec<&'a str>, Vec<&'a str>) {
    let bytes = src.as_bytes();
    let mut parts = Vec::new();
    let mut found_ops = Vec::new();
    let mut start = 0usize;
    let mut i = 0usize;

    let mut paren = 0usize;
    let mut bracket = 0usize;
    let mut brace = 0usize;

    #[derive(Clone, Copy, PartialEq, Eq)]
    enum StrState {
        None,
        Single,
        Double,
        Backtick,
    }
    let mut state = StrState::None;

    while i < bytes.len() {
        let b = bytes[i];
        match state {
            StrState::None => match b {
                b'\'' => state = StrState::Single,
                b'"' => state = StrState::Double,
                b'`' => state = StrState::Backtick,
                b'(' => paren += 1,
                b')' => paren = paren.saturating_sub(1),
                b'[' => bracket += 1,
                b']' => bracket = bracket.saturating_sub(1),
                b'{' => brace += 1,
                b'}' => brace = brace.saturating_sub(1),
                _ => {
                    if paren == 0 && bracket == 0 && brace == 0 {
                        let mut matched = None;
                        for op in ops {
                            let op_bytes = op.as_bytes();
                            if i + op_bytes.len() <= bytes.len()
                                && &bytes[i..i + op_bytes.len()] == op_bytes
                            {
                                if op_bytes.iter().all(|b| b.is_ascii_alphabetic()) {
                                    if i > 0 && is_ident_char(bytes[i - 1]) {
                                        continue;
                                    }
                                    if i + op_bytes.len() < bytes.len()
                                        && is_ident_char(bytes[i + op_bytes.len()])
                                    {
                                        continue;
                                    }
                                } else if op.len() == 1 && (op == &"<" || op == &">") {
                                    let prev = if i == 0 { None } else { Some(bytes[i - 1]) };
                                    let next = bytes.get(i + 1).copied();
                                    if prev == Some(b'<')
                                        || prev == Some(b'>')
                                        || next == Some(b'<')
                                        || next == Some(b'>')
                                    {
                                        continue;
                                    }
                                }
                                matched = Some(*op);
                                break;
                            }
                        }
                        if let Some(op) = matched {
                            if let Some(part) = src.get(start..i) {
                                parts.push(part);
                                found_ops.push(op);
                                i += op.len();
                                start = i;
                                continue;
                            }
                        }
                    }
                }
            },
            StrState::Single => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'\'' {
                    state = StrState::None;
                }
            }
            StrState::Double => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'"' {
                    state = StrState::None;
                }
            }
            StrState::Backtick => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'`' {
                    state = StrState::None;
                }
            }
        }
        i += 1;
    }

    if let Some(last) = src.get(start..) {
        parts.push(last);
    }

    (parts, found_ops)
}

fn find_matching_brace(src: &str, start: usize) -> Result<usize> {
    let bytes = src.as_bytes();
    let mut i = start;
    let mut depth = 0usize;

    #[derive(Clone, Copy, PartialEq, Eq)]
    enum StrState {
        None,
        Single,
        Double,
        Backtick,
    }
    let mut state = StrState::None;

    while i < bytes.len() {
        let b = bytes[i];
        match state {
            StrState::None => match b {
                b'\'' => state = StrState::Single,
                b'"' => state = StrState::Double,
                b'`' => state = StrState::Backtick,
                b'{' => depth += 1,
                b'}' => {
                    if depth == 0 {
                        return Ok(i);
                    }
                    depth -= 1;
                }
                _ => {}
            },
            StrState::Single => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'\'' {
                    state = StrState::None;
                }
            }
            StrState::Double => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'"' {
                    state = StrState::None;
                }
            }
            StrState::Backtick => {
                if b == b'\\' {
                    i += 1;
                } else if b == b'`' {
                    state = StrState::None;
                }
            }
        }
        i += 1;
    }

    Err(Error::ScriptParse("unclosed template expression".into()))
}

fn is_ident(value: &str) -> bool {
    let mut chars = value.chars();
    let Some(first) = chars.next() else {
        return false;
    };

    if !(first == '_' || first == '$' || first.is_ascii_alphabetic()) {
        return false;
    }

    chars.all(|ch| ch == '_' || ch == '$' || ch.is_ascii_alphanumeric())
}

fn parse_html(html: &str) -> Result<ParseOutput> {
    let mut dom = Dom::new();
    let mut scripts = Vec::new();

    let mut stack = vec![dom.root];
    let bytes = html.as_bytes();
    let mut i = 0usize;

    while i < bytes.len() {
        if starts_with_at(bytes, i, b"<!--") {
            if let Some(end) = find_subslice(bytes, i + 4, b"-->") {
                i = end + 3;
            } else {
                return Err(Error::HtmlParse("unclosed HTML comment".into()));
            }
            continue;
        }

        if bytes[i] == b'<' {
            if starts_with_at(bytes, i, b"</") {
                let (tag, next) = parse_end_tag(html, i)?;
                i = next;

                while stack.len() > 1 {
                    let top = *stack
                        .last()
                        .ok_or_else(|| Error::HtmlParse("invalid stack state".into()))?;
                    let top_tag = dom.tag_name(top).unwrap_or("");
                    stack.pop();
                    if top_tag.eq_ignore_ascii_case(&tag) {
                        break;
                    }
                }
                continue;
            }

            let (tag, attrs, self_closing, next) = parse_start_tag(html, i)?;
            i = next;
            let executable_script = tag.eq_ignore_ascii_case("script")
                && is_executable_script_type(attrs.get("type").map(String::as_str));

            let parent = *stack
                .last()
                .ok_or_else(|| Error::HtmlParse("missing parent element".into()))?;
            let node = dom.create_element(parent, tag.clone(), attrs);

            if tag.eq_ignore_ascii_case("script") {
                let close = find_case_insensitive_end_tag(bytes, i, b"script")
                    .ok_or_else(|| Error::HtmlParse("unclosed <script>".into()))?;
                if let Some(script_body) = html.get(i..close) {
                    if !script_body.is_empty() {
                        dom.create_text(node, script_body.to_string());
                        if executable_script {
                            scripts.push(script_body.to_string());
                        }
                    }
                }
                i = close;
                let (_, after_end) = parse_end_tag(html, i)?;
                i = after_end;
                continue;
            }

            if !self_closing && !is_void_tag(&tag) {
                stack.push(node);
            }
            continue;
        }

        let text_start = i;
        while i < bytes.len() && bytes[i] != b'<' {
            i += 1;
        }

        if let Some(text) = html.get(text_start..i) {
            if !text.is_empty() {
                let parent = *stack
                    .last()
                    .ok_or_else(|| Error::HtmlParse("missing parent element".into()))?;
                dom.create_text(parent, decode_html_character_references(text));
            }
        }
    }

    dom.initialize_form_control_values()?;
    dom.normalize_radio_groups()?;
    Ok(ParseOutput { dom, scripts })
}

fn is_executable_script_type(raw_type: Option<&str>) -> bool {
    let Some(raw_type) = raw_type else {
        return true;
    };

    let media_type = raw_type
        .split(';')
        .next()
        .map(str::trim)
        .unwrap_or_default()
        .to_ascii_lowercase();

    if media_type.is_empty() {
        return true;
    }

    matches!(
        media_type.as_str(),
        "text/javascript"
            | "application/javascript"
            | "application/ecmascript"
            | "text/ecmascript"
            | "module"
    )
}

fn parse_start_tag(
    html: &str,
    at: usize,
) -> Result<(String, HashMap<String, String>, bool, usize)> {
    let bytes = html.as_bytes();
    let mut i = at;
    if bytes.get(i) != Some(&b'<') {
        return Err(Error::HtmlParse("expected '<'".into()));
    }
    i += 1;

    skip_ws(bytes, &mut i);
    let tag_start = i;
    while i < bytes.len() && is_tag_char(bytes[i]) {
        i += 1;
    }

    let tag = html
        .get(tag_start..i)
        .ok_or_else(|| Error::HtmlParse("invalid tag name".into()))?
        .to_ascii_lowercase();

    if tag.is_empty() {
        return Err(Error::HtmlParse("empty tag name".into()));
    }

    let mut attrs = HashMap::new();
    let mut self_closing = false;

    loop {
        skip_ws(bytes, &mut i);
        if i >= bytes.len() {
            return Err(Error::HtmlParse("unclosed start tag".into()));
        }

        if bytes[i] == b'>' {
            i += 1;
            break;
        }

        if bytes[i] == b'/' && i + 1 < bytes.len() && bytes[i + 1] == b'>' {
            self_closing = true;
            i += 2;
            break;
        }

        let name_start = i;
        while i < bytes.len() && is_attr_name_char(bytes[i]) {
            i += 1;
        }

        let name = html
            .get(name_start..i)
            .ok_or_else(|| Error::HtmlParse("invalid attribute name".into()))?
            .to_ascii_lowercase();

        if name.is_empty() {
            return Err(Error::HtmlParse("invalid attribute name".into()));
        }

        skip_ws(bytes, &mut i);

        let value = if i < bytes.len() && bytes[i] == b'=' {
            i += 1;
            skip_ws(bytes, &mut i);
            parse_attr_value(html, bytes, &mut i)?
        } else {
            "true".to_string()
        };

        attrs.insert(name, value);
    }

    Ok((tag, attrs, self_closing, i))
}

fn parse_end_tag(html: &str, at: usize) -> Result<(String, usize)> {
    let bytes = html.as_bytes();
    let mut i = at;

    if !(bytes.get(i) == Some(&b'<') && bytes.get(i + 1) == Some(&b'/')) {
        return Err(Error::HtmlParse("expected end tag".into()));
    }
    i += 2;
    skip_ws(bytes, &mut i);

    let tag_start = i;
    while i < bytes.len() && is_tag_char(bytes[i]) {
        i += 1;
    }

    let tag = html
        .get(tag_start..i)
        .ok_or_else(|| Error::HtmlParse("invalid end tag".into()))?
        .to_ascii_lowercase();

    while i < bytes.len() && bytes[i] != b'>' {
        i += 1;
    }
    if i >= bytes.len() {
        return Err(Error::HtmlParse("unclosed end tag".into()));
    }

    Ok((tag, i + 1))
}

fn parse_attr_value(html: &str, bytes: &[u8], i: &mut usize) -> Result<String> {
    if *i >= bytes.len() {
        return Err(Error::HtmlParse("missing attribute value".into()));
    }

    if bytes[*i] == b'\'' || bytes[*i] == b'"' {
        let quote = bytes[*i];
        *i += 1;
        let start = *i;
        while *i < bytes.len() && bytes[*i] != quote {
            *i += 1;
        }
        if *i >= bytes.len() {
            return Err(Error::HtmlParse("unclosed quoted attribute value".into()));
        }
        let value = html
            .get(start..*i)
            .ok_or_else(|| Error::HtmlParse("invalid attribute value".into()))?
            .to_string();
        *i += 1;
        return Ok(decode_html_character_references(&value));
    }

    let start = *i;
    while *i < bytes.len()
        && !bytes[*i].is_ascii_whitespace()
        && bytes[*i] != b'>'
        && !(bytes[*i] == b'/' && *i + 1 < bytes.len() && bytes[*i + 1] == b'>')
    {
        *i += 1;
    }

    let value = html
        .get(start..*i)
        .ok_or_else(|| Error::HtmlParse("invalid attribute value".into()))?
        .to_string();
    Ok(decode_html_character_references(&value))
}

fn skip_ws(bytes: &[u8], i: &mut usize) {
    while *i < bytes.len() && bytes[*i].is_ascii_whitespace() {
        *i += 1;
    }
}

fn is_tag_char(b: u8) -> bool {
    b.is_ascii_alphanumeric() || b == b'-' || b == b'_'
}

fn is_attr_name_char(b: u8) -> bool {
    b.is_ascii_alphanumeric() || b == b'-' || b == b'_' || b == b':'
}

fn is_void_tag(tag: &str) -> bool {
    matches!(
        tag,
        "area"
            | "base"
            | "br"
            | "col"
            | "embed"
            | "hr"
            | "img"
            | "input"
            | "link"
            | "meta"
            | "param"
            | "source"
            | "track"
            | "wbr"
    )
}

fn starts_with_at(bytes: &[u8], at: usize, needle: &[u8]) -> bool {
    if at + needle.len() > bytes.len() {
        return false;
    }
    &bytes[at..at + needle.len()] == needle
}

fn find_subslice(bytes: &[u8], from: usize, needle: &[u8]) -> Option<usize> {
    if needle.is_empty() || from > bytes.len() {
        return None;
    }

    let mut i = from;
    while i + needle.len() <= bytes.len() {
        if &bytes[i..i + needle.len()] == needle {
            return Some(i);
        }
        i += 1;
    }
    None
}

fn can_start_regex_literal(previous: Option<u8>) -> bool {
    match previous {
        None => true,
        Some(byte) => matches!(
            byte,
            b'(' | b'['
                | b'{'
                | b','
                | b';'
                | b':'
                | b'='
                | b'!'
                | b'?'
                | b'&'
                | b'|'
                | b'^'
                | b'~'
                | b'<'
                | b'>'
                | b'+'
                | b'-'
                | b'*'
                | b'%'
                | b'/'
        ),
    }
}

fn find_case_insensitive_end_tag(bytes: &[u8], from: usize, tag: &[u8]) -> Option<usize> {
    fn is_ident_separator(byte: u8) -> bool {
        !byte.is_ascii_alphanumeric()
    }

    let mut i = from;
    enum State {
        Normal,
        Single,
        Double,
        Template,
        Regex { in_class: bool },
    }
    let mut state = State::Normal;
    let mut previous_significant = None;

    while i < bytes.len() {
        let b = bytes[i];

        match state {
            State::Normal => {
                if b.is_ascii_whitespace() {
                    i += 1;
                    continue;
                }
                if b == b'\'' {
                    state = State::Single;
                    i += 1;
                    continue;
                }
                if b == b'"' {
                    state = State::Double;
                    i += 1;
                    continue;
                }
                if b == b'`' {
                    state = State::Template;
                    i += 1;
                    continue;
                }
                if i + 1 < bytes.len() && b == b'/' && bytes[i + 1] == b'/' {
                    i += 2;
                    while i < bytes.len() && bytes[i] != b'\n' {
                        i += 1;
                    }
                    continue;
                }
                if i + 1 < bytes.len() && b == b'/' && bytes[i + 1] == b'*' {
                    i += 2;
                    while i + 1 < bytes.len() && !(bytes[i] == b'*' && bytes[i + 1] == b'/') {
                        i += 1;
                    }
                    if i + 1 < bytes.len() {
                        i += 2;
                    } else {
                        i = bytes.len();
                    }
                    continue;
                }
                if b == b'/' {
                    if can_start_regex_literal(previous_significant) {
                        state = State::Regex { in_class: false };
                        i += 1;
                        continue;
                    }
                    previous_significant = Some(b);
                    i += 1;
                    continue;
                }
                if b == b'<' && bytes.get(i + 1) == Some(&b'/') {
                    let mut j = i + 2;
                    while j < bytes.len() && bytes[j].is_ascii_whitespace() {
                        j += 1;
                    }
                    let tag_end = j + tag.len();
                    if tag_end <= bytes.len() {
                        let mut matched = true;
                        for k in 0..tag.len() {
                            if bytes[j + k].to_ascii_lowercase() != tag[k].to_ascii_lowercase() {
                                matched = false;
                                break;
                            }
                        }
                        if matched {
                            let after = j + tag.len();
                            if after >= bytes.len() || is_ident_separator(bytes[after]) {
                                return Some(i);
                            }
                        }
                    }
                }
                previous_significant = Some(b);
                i += 1;
            }
            State::Single => {
                if b == b'\\' {
                    i += 2;
                } else {
                    if b == b'\'' {
                        state = State::Normal;
                        previous_significant = Some(b'\'');
                    }
                    i += 1;
                }
            }
            State::Double => {
                if b == b'\\' {
                    i += 2;
                } else {
                    if b == b'"' {
                        state = State::Normal;
                        previous_significant = Some(b'"');
                    }
                    i += 1;
                }
            }
            State::Template => {
                if b == b'\\' {
                    i += 2;
                } else {
                    if b == b'`' {
                        state = State::Normal;
                        previous_significant = Some(b'`');
                    }
                    i += 1;
                }
            }
            State::Regex { mut in_class } => {
                if b == b'\\' {
                    i += 2;
                    continue;
                }
                if b == b'[' {
                    in_class = true;
                    state = State::Regex { in_class };
                    i += 1;
                    continue;
                }
                if b == b']' && in_class {
                    in_class = false;
                    state = State::Regex { in_class };
                    i += 1;
                    continue;
                }
                if b == b'/' && !in_class {
                    i += 1;
                    while i < bytes.len() && bytes[i].is_ascii_alphabetic() {
                        i += 1;
                    }
                    state = State::Normal;
                    previous_significant = Some(b'/');
                    continue;
                }
                state = State::Regex { in_class };
                i += 1;
            }
        }
    }
    None
}

fn is_form_control(dom: &Dom, node_id: NodeId) -> bool {
    let Some(element) = dom.element(node_id) else {
        return false;
    };

    element.tag_name.eq_ignore_ascii_case("input")
        || element.tag_name.eq_ignore_ascii_case("select")
        || element.tag_name.eq_ignore_ascii_case("textarea")
        || element.tag_name.eq_ignore_ascii_case("button")
}

fn is_checkbox_input(dom: &Dom, node_id: NodeId) -> bool {
    let Some(element) = dom.element(node_id) else {
        return false;
    };

    if !element.tag_name.eq_ignore_ascii_case("input") {
        return false;
    }

    element
        .attrs
        .get("type")
        .map(|kind| kind.eq_ignore_ascii_case("checkbox"))
        .unwrap_or(false)
}

fn is_radio_input(dom: &Dom, node_id: NodeId) -> bool {
    let Some(element) = dom.element(node_id) else {
        return false;
    };

    if !element.tag_name.eq_ignore_ascii_case("input") {
        return false;
    }

    element
        .attrs
        .get("type")
        .map(|kind| kind.eq_ignore_ascii_case("radio"))
        .unwrap_or(false)
}

fn is_submit_control(dom: &Dom, node_id: NodeId) -> bool {
    let Some(element) = dom.element(node_id) else {
        return false;
    };

    if element.tag_name.eq_ignore_ascii_case("button") {
        return element
            .attrs
            .get("type")
            .map(|kind| kind.eq_ignore_ascii_case("submit"))
            .unwrap_or(true);
    }

    if element.tag_name.eq_ignore_ascii_case("input") {
        return element
            .attrs
            .get("type")
            .map(|kind| kind.eq_ignore_ascii_case("submit"))
            .unwrap_or(false);
    }

    false
}

#[derive(Debug)]
struct Cursor<'a> {
    src: &'a str,
    i: usize,
}

impl<'a> Cursor<'a> {
    fn new(src: &'a str) -> Self {
        Self { src, i: 0 }
    }

    fn eof(&self) -> bool {
        self.i >= self.src.len()
    }

    fn pos(&self) -> usize {
        self.i
    }

    fn set_pos(&mut self, pos: usize) {
        self.i = pos;
    }

    fn bytes(&self) -> &'a [u8] {
        self.src.as_bytes()
    }

    fn peek(&self) -> Option<u8> {
        self.bytes().get(self.i).copied()
    }

    fn consume_byte(&mut self, b: u8) -> bool {
        if self.peek() == Some(b) {
            self.i += 1;
            true
        } else {
            false
        }
    }

    fn expect_byte(&mut self, b: u8) -> Result<()> {
        if self.consume_byte(b) {
            Ok(())
        } else {
            Err(Error::ScriptParse(format!(
                "expected '{}' at {}",
                b as char, self.i
            )))
        }
    }

    fn consume_ascii(&mut self, token: &str) -> bool {
        let bytes = self.bytes();
        if self.i + token.len() > bytes.len() {
            return false;
        }
        let got = &bytes[self.i..self.i + token.len()];
        if got == token.as_bytes() {
            self.i += token.len();
            true
        } else {
            false
        }
    }

    fn expect_ascii(&mut self, token: &str) -> Result<()> {
        if self.consume_ascii(token) {
            Ok(())
        } else {
            Err(Error::ScriptParse(format!(
                "expected '{}' at {}",
                token, self.i
            )))
        }
    }

    fn skip_ws(&mut self) {
        self.skip_ws_and_comments()
    }

    fn skip_ws_and_comments(&mut self) {
        loop {
            self.skip_plain_ws();
            if self.consume_ascii("//") {
                while let Some(b) = self.peek() {
                    self.i += 1;
                    if b == b'\n' {
                        break;
                    }
                }
                continue;
            }
            if self.consume_ascii("/*") {
                while !self.eof() {
                    if self.consume_ascii("*/") {
                        break;
                    }
                    self.i += 1;
                }
                continue;
            }
            break;
        }
    }

    fn skip_plain_ws(&mut self) {
        while let Some(b) = self.peek() {
            if b.is_ascii_whitespace() {
                self.i += 1;
            } else {
                break;
            }
        }
    }

    fn parse_identifier(&mut self) -> Option<String> {
        let bytes = self.bytes();
        let start = self.i;
        let first = *bytes.get(self.i)?;
        if !(first == b'_' || first == b'$' || first.is_ascii_alphabetic()) {
            return None;
        }
        self.i += 1;
        while let Some(b) = bytes.get(self.i).copied() {
            if b == b'_' || b == b'$' || b.is_ascii_alphanumeric() {
                self.i += 1;
            } else {
                break;
            }
        }
        self.src.get(start..self.i).map(|s| s.to_string())
    }

    fn parse_string_literal(&mut self) -> Result<String> {
        let quote = self
            .peek()
            .ok_or_else(|| Error::ScriptParse("expected string literal".into()))?;
        if quote != b'\'' && quote != b'"' {
            return Err(Error::ScriptParse(format!(
                "expected string literal at {}",
                self.i
            )));
        }

        self.i += 1;
        let start = self.i;

        let bytes = self.bytes();
        while self.i < bytes.len() {
            let b = bytes[self.i];
            if b == b'\\' {
                self.i += 2;
                continue;
            }
            if b == quote {
                let raw = self
                    .src
                    .get(start..self.i)
                    .ok_or_else(|| Error::ScriptParse("invalid string literal".into()))?;
                self.i += 1;
                return Ok(unescape_string(raw));
            }
            self.i += 1;
        }

        Err(Error::ScriptParse("unclosed string literal".into()))
    }

    fn read_until_byte(&mut self, b: u8) -> Result<String> {
        let start = self.i;
        while let Some(current) = self.peek() {
            if current == b {
                return self
                    .src
                    .get(start..self.i)
                    .map(|s| s.to_string())
                    .ok_or_else(|| Error::ScriptParse("invalid substring".into()));
            }
            self.i += 1;
        }
        Err(Error::ScriptParse(format!(
            "expected '{}' before EOF",
            b as char
        )))
    }

    fn read_balanced_block(&mut self, open: u8, close: u8) -> Result<String> {
        self.expect_byte(open)?;
        let start = self.i;
        let bytes = self.bytes();

        let mut depth = 1usize;
        let mut idx = self.i;

        #[derive(Clone, Copy, PartialEq, Eq)]
        enum StrState {
            None,
            Single,
            Double,
            Backtick,
        }
        let mut state = StrState::None;

        while idx < bytes.len() {
            let b = bytes[idx];
            match state {
                StrState::None => match b {
                    b'\'' => state = StrState::Single,
                    b'"' => state = StrState::Double,
                    b'`' => state = StrState::Backtick,
                    _ => {
                        if b == open {
                            depth += 1;
                        } else if b == close {
                            depth -= 1;
                            if depth == 0 {
                                let body = self
                                    .src
                                    .get(start..idx)
                                    .ok_or_else(|| Error::ScriptParse("invalid block".into()))?
                                    .to_string();
                                self.i = idx + 1;
                                return Ok(body);
                            }
                        }
                    }
                },
                StrState::Single => {
                    if b == b'\\' {
                        idx += 1;
                    } else if b == b'\'' {
                        state = StrState::None;
                    }
                }
                StrState::Double => {
                    if b == b'\\' {
                        idx += 1;
                    } else if b == b'"' {
                        state = StrState::None;
                    }
                }
                StrState::Backtick => {
                    if b == b'\\' {
                        idx += 1;
                    } else if b == b'`' {
                        state = StrState::None;
                    }
                }
            }
            idx += 1;
        }

        Err(Error::ScriptParse("unclosed block".into()))
    }
}

include!("intl_impl.rs");

#[cfg(test)]
mod tests;
